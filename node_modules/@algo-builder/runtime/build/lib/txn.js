"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEncTxAssetConfig = exports.isEncTxAssetDeletion = exports.txAppArg = exports.txnSpecbyField = exports.checkIfAssetDeletionTx = exports.parseToStackElem = exports.assetTxnFields = void 0;
const web_1 = require("@algo-builder/web");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
const types_1 = require("../types");
exports.assetTxnFields = new Set([
    'ConfigAssetTotal',
    'ConfigAssetDecimals',
    'ConfigAssetDefaultFrozen',
    'ConfigAssetUnitName',
    'ConfigAssetName',
    'ConfigAssetURL',
    'ConfigAssetMetadataHash',
    'ConfigAssetManager',
    'ConfigAssetReserve',
    'ConfigAssetFreeze',
    'ConfigAssetClawback'
]);
const globalAndLocalNumTxnFields = new Set([
    'GlobalNumUint', 'GlobalNumByteSlice',
    'LocalNumUint', 'LocalNumByteSlice'
]);
// return default value of txField if undefined,
// otherwise return parsed data to interpreter
function parseToStackElem(a, field) {
    if (Buffer.isBuffer(a)) {
        return new Uint8Array(a);
    }
    if (typeof a === "number" || typeof a === "bigint" || typeof a === "boolean") {
        return BigInt(a);
    }
    if (typeof a === "string") {
        return web_1.parsing.stringToBytes(a);
    }
    return constants_1.TxFieldDefaults[field];
}
exports.parseToStackElem = parseToStackElem;
/**
 * Check if given transaction is asset deletion
 * @param txn EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function checkIfAssetDeletionTx(txn) {
    return txn.type === 'acfg' && // type should be asset config
        (txn.assetIndex > 0) && // assetIndex should not be 0
        !(txn.assetClawback || txn.assetFreeze || txn.assetManager || txn.assetReserve); // fields should be empty
}
exports.checkIfAssetDeletionTx = checkIfAssetDeletionTx;
/**
 * Description: returns specific transaction field value from tx object
 * @param txField: transaction field
 * @param tx Current transaction
 * @param txns Transaction group
 * @param tealVersion version of TEAL
 */
function txnSpecbyField(txField, tx, gtxns, tealVersion) {
    let result; // store raw result, parse and return
    // handle nested encoded obj (for AssetDef, AppGlobalNumFields, AppLocalNumFields)
    if (exports.assetTxnFields.has(txField)) {
        const s = constants_1.TxnFields[tealVersion][txField];
        const assetMetaData = tx.apar;
        result = assetMetaData?.[s];
        return parseToStackElem(result, txField);
    }
    if (globalAndLocalNumTxnFields.has(txField)) {
        const encAppGlobalSchema = txField.includes('Global') ? tx.apgs : tx.apls;
        const s = constants_1.TxnFields[tealVersion][txField];
        result = encAppGlobalSchema?.[s];
        return parseToStackElem(result, txField);
    }
    // handle other cases
    switch (txField) {
        case 'FirstValidTime': { // Causes program to fail; reserved for future use
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.REJECTED_BY_LOGIC);
        }
        case 'TypeEnum': {
            result = Number(types_1.TxnType[tx.type]); // TxnType['pay']
            break;
        }
        case 'TxID': {
            return web_1.parsing.stringToBytes(tx.txID);
        }
        case 'GroupIndex': {
            result = gtxns.indexOf(tx);
            break;
        }
        case 'NumAppArgs': {
            const appArg = constants_1.TxnFields[tealVersion].ApplicationArgs;
            const appArgs = tx[appArg];
            result = appArgs?.length;
            break;
        }
        case 'NumAccounts': {
            const appAcc = constants_1.TxnFields[tealVersion].Accounts;
            const appAccounts = tx[appAcc];
            result = appAccounts?.length;
            break;
        }
        case 'NumAssets': {
            const encAppAsset = constants_1.TxnFields[tealVersion].Assets; // 'apas'
            const foreignAssetsArr = tx[encAppAsset];
            result = foreignAssetsArr?.length;
            break;
        }
        case 'NumApplications': {
            const encApp = constants_1.TxnFields[tealVersion].Applications; // 'apfa'
            const foreignAppsArr = tx[encApp];
            result = foreignAppsArr?.length;
            break;
        }
        case 'AssetSender': {
            /// + for asset_transfer transactions, we use "snd"
            /// + for revoke asset tx (also an asset_transfer) tx, we use "asnd"
            if (tx.type === 'axfer') {
                result = tx.asnd ?? tx.snd;
            }
            break;
        }
        default: {
            const s = constants_1.TxnFields[tealVersion][txField]; // eg: rcv = TxnFields["Receiver"]
            result = tx[s]; // pk_buffer = tx['rcv']
        }
    }
    return parseToStackElem(result, txField);
}
exports.txnSpecbyField = txnSpecbyField;
/**
 * Returns specific transaction field value from array
 * of accounts or application args
 * @param tx current transaction
 * @param txField transaction field
 * @param idx array index
 * @param op Op object
 * @param tealVersion version of TEAL
 * @param line line number in TEAL file
 */
function txAppArg(txField, tx, idx, op, tealVersion, line) {
    const s = constants_1.TxnFields[tealVersion][txField]; // 'apaa' or 'apat'
    const result = tx[s]; // array of pk buffers (accounts or appArgs)
    if (!result) { // handle defaults
        return constants_1.TxFieldDefaults[txField];
    }
    /**
     * handle special case of accounts and applications:
     * + EncTx.Accounts[0] represents sender's account
     * + EncTx.Applications[0] represents current_application_id
     * https://pyteal.readthedocs.io/en/stable/accessing_transaction_field.html#special-case-txn-accounts-and-txn-applications
     */
    if (txField === 'Accounts') {
        if (idx === 0) {
            return parseToStackElem(tx.snd, txField);
        }
        idx--; // if not sender, then reduce index by 1
    }
    else if (txField === 'Applications') {
        if (idx === 0) {
            return parseToStackElem(tx.apid ?? 0n, txField);
        } // during ssc deploy tx.app_id is 0
        idx--;
    }
    op.checkIndexBound(idx, result, line);
    return parseToStackElem(result[idx], txField);
}
exports.txAppArg = txAppArg;
/**
 * Check if given encoded transaction obj is asset deletion
 * @param txn Encoded EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function isEncTxAssetDeletion(txn) {
    return txn.type === 'acfg' && // type should be asset config
        (txn.caid !== undefined && txn.caid !== 0) && // assetIndex should not be 0
        !(txn.apar?.m ?? txn.apar?.r ?? txn.apar?.f ?? txn.apar?.c); // fields should be empty
}
exports.isEncTxAssetDeletion = isEncTxAssetDeletion;
/**
 * Check if given encoded transaction obj is asset deletion
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetConfig(txn) {
    return txn.type === 'acfg' && // type should be asset config
        (txn.caid !== undefined && txn.caid !== 0) && // assetIndex should not be 0
        !isEncTxAssetDeletion(txn); // AND should not be asset deletion
}
exports.isEncTxAssetConfig = isEncTxAssetConfig;
//# sourceMappingURL=txn.js.map