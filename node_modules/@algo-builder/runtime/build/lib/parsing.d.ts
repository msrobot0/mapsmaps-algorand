/// <reference types="node" />
import { EncodingType } from "../types";
/**
 * assert if string contains digits only
 * "123" // ok.  "12+2" // error.
 * @param val : string
 */
export declare function assertOnlyDigits(val: string, line: number): void;
/**
 * assert if string is valid algorand number respesentation (octal / hex / unsigned int).
 * return val if format is correct
 * @param val : string
 */
export declare function assertNumber(val: string, line: number): string;
/**
 * assert that a line has given number of words
 * @param val Comparsion result
 * @param expected expected result
 * @param line Line number in TEAL file
 */
export declare function assertLen(val: number, expected: number, line: number): void;
/**
 * Checks if string is base64
 * @param str : string that needs to be checked
 * @param line : line number in TEAL file
 */
export declare function assertBase64(str: string, line: number): void;
/**
 * Checks if string is base32
 * @param str : string that needs to be checked
 * @param line : line number in TEAL file
 */
export declare function assertBase32(str: string, line: number): void;
/**
 * returns key as bytes
 * @param key : key in a stateful key-value pair
 */
export declare function keyToBytes(key: Uint8Array | string): Uint8Array;
export declare function convertToString(u: Uint8Array | Buffer): string;
/**
 * Description : converts string into buffer as per encoding type
 * @param s : string to be converted
 * @param encoding : encoding type
 */
export declare function convertToBuffer(s: string, encoding?: EncodingType): Buffer;
/**
 * returns encodingtype (base32, base64, utf8, hex) and the encoded string from words list
 * eg. base64 "dfc/==" => returns [dfc/==, EncodingType.BASE64]
 *     0xadkjka => returns [adkjka, EncodingType.HEX] (removing 0x)
 *     "hello" => returns [hello, EncodingType.UTF8] (removing quotes "")
 * @param args : words list for base64 and base32
 * @param line line number
 */
export declare function getEncoding(args: string[], line: number): [string, EncodingType];
/**
 * Parses binary string into bigint. Eg '101' OR ['1', '0', '1'] => 5n
 * @param binary Binary string array or a string
 */
export declare function parseBinaryStrToBigInt(binary: string[] | string): bigint;
/**
 * Parses bigint to big endian bytes (represeted as Uint8array)
 * NOTE: This is different from decodeUint64, encodeUint64 as it is capable of
 * handling bigint > 64 bit (8 bytes).
 * @param b value in bigint to parse
 */
export declare function bigintToBigEndianBytes(b: bigint): Uint8Array;
/**
 * Parses unsigned big endian bytes (represented as Uint8array) back to bigint
 * NOTE: This is different from decodeUint64, encodeUint64 as it is capable of
 * handling bigint > 64 bit (8 bytes).
 * @param bytes big endian bytes (buffer or Uint8array)
 */
export declare function bigEndianBytesToBigInt(bytes: Uint8Array | Buffer): bigint;
