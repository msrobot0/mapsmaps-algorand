"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEncodedTxnToExecParams = exports.setInnerTxField = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
const parsing_1 = require("./parsing");
const txn_1 = require("./txn");
// requires their type as number
const numberTxnFields = new Set([
    'Fee', 'FreezeAssetFrozen', 'ConfigAssetDecimals',
    'ConfigAssetDefaultFrozen'
]);
const uintTxnFields = new Set([
    'Amount', 'AssetAmount', 'TypeEnum', 'ConfigAssetTotal'
]);
// these are also uint values, but require that the asset
// be present in Txn.Assets[] array
const assetIDFields = new Set([
    'XferAsset', 'FreezeAsset', 'ConfigAsset'
]);
const byteTxnFields = new Set([
    'Type', 'ConfigAssetName', 'ConfigAssetUnitName',
    'ConfigAssetMetadataHash', 'ConfigAssetURL'
]);
const acfgAddrTxnFields = new Set([
    'ConfigAssetManager', 'ConfigAssetReserve', 'ConfigAssetFreeze', 'ConfigAssetClawback'
]);
const otherAddrTxnFields = new Set([
    'Sender', 'Receiver', 'CloseRemainderTo', 'AssetSender', 'AssetCloseTo',
    'AssetReceiver', 'FreezeAssetAccount'
]);
/**
 * Sets inner transaction field to subTxn (eg. set assetReceiver('rcv'))
 * https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#setting-transaction-properties
 */
/* eslint-disable sonarjs/cognitive-complexity */
function setInnerTxField(subTxn, field, val, op, interpreter, line) {
    let txValue;
    if (uintTxnFields.has(field)) {
        txValue = op.assertBigInt(val, line);
    }
    if (numberTxnFields.has(field)) {
        txValue = Number(op.assertBigInt(val, line));
    }
    if (assetIDFields.has(field)) {
        const id = op.assertBigInt(val, line);
        txValue = interpreter.getAssetIDByReference(Number(id), false, line, op);
    }
    if (byteTxnFields.has(field)) {
        const assertedVal = op.assertBytes(val, line);
        txValue = (0, parsing_1.convertToString)(assertedVal);
    }
    if (otherAddrTxnFields.has(field)) {
        const assertedVal = op.assertBytes(val, line);
        const accountState = interpreter.getAccount(assertedVal, line);
        txValue = Buffer.from((0, algosdk_1.decodeAddress)(accountState.address).publicKey);
    }
    // if address use for acfg we only check address is valid
    if (acfgAddrTxnFields.has(field)) {
        txValue = op.assertAlgorandAddress(val, line);
    }
    const encodedField = constants_1.TxnFields[interpreter.tealVersion][field]; // eg 'rcv'
    // txValue can be undefined for a field with not having TEALv5 support (eg. type 'appl')
    if (txValue === undefined) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_FIELD_ERR, {
            msg: `Field ${field} is invalid`,
            field: field,
            line: line,
            tealV: interpreter.tealVersion
        });
    }
    // handle individual cases
    let errMsg = "";
    switch (field) {
        case 'Type': {
            const txType = txValue;
            // either invalid string, or not allowed for TEALv5
            if (txType !== 'pay' && txType !== 'axfer' && txType !== 'acfg' && txType !== 'afrz') {
                errMsg = `Type does not represent 'pay', 'axfer', 'acfg' or 'afrz'`;
            }
            break;
        }
        case 'TypeEnum': {
            const txType = op.assertBigInt(val, line);
            if (constants_1.TxnTypeMap[Number(txType)] === undefined) {
                errMsg = `TypeEnum does not represent 'pay', 'axfer', 'acfg' or 'afrz'`;
            }
            subTxn.type = constants_1.TxnTypeMap[Number(txType)];
            break;
        }
        case 'ConfigAssetDecimals': {
            const assetDecimals = txValue;
            if (assetDecimals > 19n || assetDecimals < 0n) {
                errMsg = "Decimals must be between 0 (non divisible) and 19";
            }
            break;
        }
        case 'ConfigAssetMetadataHash': {
            const assetMetadataHash = txValue;
            if (assetMetadataHash.length !== 32) {
                errMsg = "assetMetadataHash must be a 32 byte Uint8Array or string.";
            }
            break;
        }
        case 'ConfigAssetUnitName': {
            const assetUnitName = txValue;
            if (assetUnitName.length > 8) {
                errMsg = "Unit name must not be longer than 8 bytes";
            }
            break;
        }
        case 'ConfigAssetName': {
            const assetName = txValue;
            if (assetName.length > 32) {
                errMsg = "AssetName must not be longer than 8 bytes";
            }
            break;
        }
        case 'ConfigAssetURL': {
            const assetURL = txValue;
            if (assetURL.length > 96) {
                errMsg = "URL must not be longer than 96 bytes";
            }
            break;
        }
        default: {
            break;
        }
    }
    if (errMsg) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_FIELD_ERR, {
            msg: errMsg,
            field: field,
            line: line,
            tealV: interpreter.tealVersion
        });
    }
    // if everything goes well, set the [key, value]
    if (encodedField === null) {
        return subTxn; // could be for "TypeEnum"
    }
    else if (txn_1.assetTxnFields.has(field)) {
        subTxn.apar = subTxn.apar ?? {};
        subTxn.apar[encodedField] = txValue;
    }
    else {
        subTxn[encodedField] = txValue;
    }
    return subTxn;
}
exports.setInnerTxField = setInnerTxField;
const _getRuntimeAccount = (publickey, interpreter, line) => {
    if (publickey === undefined) {
        return undefined;
    }
    const address = (0, algosdk_1.encodeAddress)(Uint8Array.from(publickey));
    const runtimeAcc = interpreter.runtime.assertAccountDefined(address, interpreter.runtime.ctx.state.accounts.get(address), line);
    return runtimeAcc.account;
};
const _getRuntimeAccountAddr = (publickey, interpreter, line) => {
    return _getRuntimeAccount(publickey, interpreter, line)?.addr;
};
const _getASAConfigAddr = (addr) => {
    if (addr) {
        return (0, algosdk_1.encodeAddress)(addr);
    }
    return "";
};
// parse encoded txn obj to execParams (params passed by user in algob)
/* eslint-disable sonarjs/cognitive-complexity */
function parseEncodedTxnToExecParams(tx, interpreter, line) {
    // signer is the contract
    const appID = interpreter.runtime.ctx.tx.apid ?? 0;
    const appAddress = (0, algosdk_1.getApplicationAddress)(appID);
    // initial common fields
    const execParams = {
        sign: web_1.types.SignType.SecretKey,
        fromAccount: { addr: appAddress, sk: Buffer.from([]) },
        fromAccountAddr: (0, algosdk_1.encodeAddress)(tx.snd),
        payFlags: {
            totalFee: tx.fee,
            firstValid: tx.fv
        }
    };
    switch (tx.type) {
        case 'pay': {
            execParams.type = web_1.types.TransactionType.TransferAlgo;
            execParams.toAccountAddr =
                _getRuntimeAccountAddr(tx.rcv, interpreter, line) ?? constants_1.ZERO_ADDRESS_STR;
            execParams.amountMicroAlgos = tx.amt ?? 0n;
            execParams.payFlags.closeRemainderTo = _getRuntimeAccountAddr(tx.close, interpreter, line);
            break;
        }
        case 'afrz': {
            execParams.type = web_1.types.TransactionType.FreezeAsset;
            execParams.assetID = tx.faid;
            execParams.freezeTarget = _getRuntimeAccountAddr(tx.fadd, interpreter, line);
            execParams.freezeState = BigInt(tx.afrz ?? 0n) === 1n;
            break;
        }
        case 'axfer': {
            if (tx.asnd !== undefined) { // if 'AssetSender' is set, it is clawback transaction
                execParams.type = web_1.types.TransactionType.RevokeAsset;
                execParams.recipient =
                    _getRuntimeAccountAddr(tx.arcv, interpreter, line) ?? constants_1.ZERO_ADDRESS_STR;
                execParams.revocationTarget = _getRuntimeAccountAddr(tx.asnd, interpreter, line);
            }
            else { // asset transfer
                execParams.type = web_1.types.TransactionType.TransferAsset;
                execParams.toAccountAddr =
                    _getRuntimeAccountAddr(tx.arcv, interpreter, line) ?? constants_1.ZERO_ADDRESS_STR;
            }
            // set common fields (asset amount, index, closeRemTo)
            execParams.amount = tx.aamt ?? 0n;
            execParams.assetID = tx.xaid ?? 0;
            execParams.payFlags.closeRemainderTo = _getRuntimeAccountAddr(tx.aclose, interpreter, line);
            break;
        }
        case 'acfg': { // can be asset modification, destroy, or deployment(create)
            if ((0, txn_1.isEncTxAssetDeletion)(tx)) {
                execParams.type = web_1.types.TransactionType.DestroyAsset;
                execParams.assetID = tx.caid;
            }
            else if ((0, txn_1.isEncTxAssetConfig)(tx)) {
                // from the docs: all fields must be reset, otherwise they will be cleared
                // https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#asset-configuration
                execParams.type = web_1.types.TransactionType.ModifyAsset;
                execParams.assetID = tx.caid;
                execParams.fields = {
                    manager: _getASAConfigAddr(tx.apar?.m),
                    reserve: _getASAConfigAddr(tx.apar?.r),
                    clawback: _getASAConfigAddr(tx.apar?.c),
                    freeze: _getASAConfigAddr(tx.apar?.f)
                };
            }
            else { // if not delete or modify, it's ASA deployment
                execParams.type = web_1.types.TransactionType.DeployASA;
                execParams.asaName = tx.apar?.an;
                execParams.asaDef = {
                    name: tx.apar?.an,
                    total: tx.apar?.t,
                    decimals: tx.apar?.dc !== undefined ? Number(tx.apar.dc) : undefined,
                    defaultFrozen: BigInt(tx.apar?.df ?? 0n) === 1n,
                    unitName: tx.apar?.un,
                    url: tx.apar?.au,
                    metadataHash: tx.apar?.am,
                    manager: _getASAConfigAddr(tx.apar?.m),
                    reserve: _getASAConfigAddr(tx.apar?.r),
                    clawback: _getASAConfigAddr(tx.apar?.c),
                    freeze: _getASAConfigAddr(tx.apar?.f)
                };
            }
            break;
        }
        default: {
            throw new Error(`unsupported type for itxn_submit at line ${line}, for version ${interpreter.tealVersion}`);
        }
    }
    return execParams;
}
exports.parseEncodedTxnToExecParams = parseEncodedTxnToExecParams;
//# sourceMappingURL=itxn.js.map