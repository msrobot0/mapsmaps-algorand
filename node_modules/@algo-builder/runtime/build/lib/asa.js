"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndSetASAFields = exports.loadASAFile = exports.validateASADefs = exports.overrideASADef = exports.parseASADef = exports.validateOptInAccNames = exports.ASSETS_DIR = void 0;
const web_1 = require("@algo-builder/web");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const z = __importStar(require("zod"));
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const validation_errors_1 = require("../errors/validation-errors");
const files_1 = require("./files");
exports.ASSETS_DIR = "assets";
/**
 * Validates asset definitions and checks if opt-in acc names are present in network
 * @param accounts AccountMap is the SDK account type, used in builder. RuntimeAccountMap is
 * for AccountStore used in runtime (where we use maps instead of arrays in sdk structures).
 * @param filename asa filename
 * @param asaDef asset definition
 */
function validateOptInAccNames(accounts, asaDef, source) {
    if (!asaDef.optInAccNames || asaDef.optInAccNames.length === 0) {
        return;
    }
    for (const accName of asaDef.optInAccNames) {
        if (!accounts.get(accName)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.PARAM_ERROR_NO_NAMED_OPT_IN_ACCOUNT, {
                source: source,
                optInAccName: accName
            });
        }
    }
}
exports.validateOptInAccNames = validateOptInAccNames;
/**
 * Validate and parse each field of asset definition. `metadataHash`, if provided as a Buffer
 * will be transformed into Uint8Array.
 * @param asaDef asset definition
 * @param source source of assetDef: asa.yaml file OR function deployASA
 * @returns parsed asa definition
 */
function parseASADef(asaDef, source) {
    try {
        if (asaDef.metadataHash && asaDef.metadataHash instanceof Buffer) {
            asaDef.metadataHash = new Uint8Array(asaDef.metadataHash);
        }
        const parsedDef = web_1.ASADefSchema.parse(asaDef);
        parsedDef.manager = parsedDef.manager !== "" ? parsedDef.manager : undefined;
        parsedDef.reserve = parsedDef.reserve !== "" ? parsedDef.reserve : undefined;
        parsedDef.freeze = parsedDef.freeze !== "" ? parsedDef.freeze : undefined;
        parsedDef.clawback = parsedDef.clawback !== "" ? parsedDef.clawback : undefined;
        parsedDef.defaultFrozen = parsedDef.defaultFrozen ?? false;
        return parsedDef;
    }
    catch (e) {
        if (e instanceof z.ZodError) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.PARAM_PARSE_ERROR, {
                reason: (0, validation_errors_1.parseZodError)(e),
                source: source
            }, e);
        }
        throw e;
    }
}
exports.parseASADef = parseASADef;
/**
 * Override & validate ASA definition in asa.yaml using custom params passed via deployASA
 * @param accounts accounts by name
 * @param origDef source asset definition (in asa.yaml)
 * @param newDef custom asset def params (passed during ASA deployment)
 * @returns overriden asset definition. If custom params are empty, return source asa def
 */
function overrideASADef(accounts, origDef, newDef) {
    if (newDef === undefined) {
        return origDef;
    }
    const source = 'ASA deployment';
    Object.assign(origDef, newDef);
    origDef = parseASADef(origDef, source);
    validateOptInAccNames(accounts, origDef, source);
    return origDef;
}
exports.overrideASADef = overrideASADef;
/**
 * Parses, overrides and validates asset defs map. Filaname parameter is used to
   indicate an ASA definition source when reporting errors.
 * @param asaDefs asset definitions to validate
 * @param accounts map of string => account. AccountMap is the SDK account type,
 * used in builder. RuntimeAccountMap is for AccountStore used in runtime
 * (where we use maps instead of arrays in sdk structures).
 * @param filename asa filename
 */
function validateASADefs(asaDefs, accounts, filename) {
    for (const name in asaDefs) {
        asaDefs[name] = parseASADef(asaDefs[name], filename);
        asaDefs[name].name = name; // save asa name in def as well
        validateOptInAccNames(accounts, asaDefs[name], filename);
    }
    return asaDefs;
}
exports.validateASADefs = validateASADefs;
/**
 * Loads, validates and returns asset definitions from the assets/asa.yaml file
 * @param accounts map of string => account. AccountMap is the SDK account type,
 * used in builder. RuntimeAccountMap is for AccountStore used in runtime
 * (where we use maps instead of arrays in sdk structures).
 */
function loadASAFile(accounts) {
    let filePath;
    if (!(0, fs_1.existsSync)(exports.ASSETS_DIR)) { // to handle tests
        filePath = path_1.default.join(exports.ASSETS_DIR, "asa.yaml");
    }
    else {
        filePath = (0, files_1.getPathFromDirRecursive)(exports.ASSETS_DIR, "asa.yaml", "ASA file not defined");
    }
    return validateASADefs((0, files_1.loadFromYamlFileSilent)(filePath), accounts, filePath);
}
exports.loadASAFile = loadASAFile;
function isDefined(value) {
    if (value !== undefined && value !== "")
        return true;
    return false;
}
/**
 * Check and Change ASA fields
 * @param fields Custom ASA fields
 * @param asset Defined ASA fields
 */
function checkAndSetASAFields(fields, asset) {
    for (const x of ['manager', 'reserve', 'freeze', 'clawback']) {
        const customField = fields[x];
        const asaField = asset[x];
        // Check if custom field is set and defined and ASA field is blank field
        if (isDefined(customField) && !isDefined(asaField)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.BLANK_ADDRESS_ERROR);
        }
        else if (customField !== undefined && isDefined(asaField)) { // Change if ASA field and custom field is defined
            asset[x] = customField;
        }
    }
}
exports.checkAndSetASAFields = checkAndSetASAFields;
//# sourceMappingURL=asa.js.map