/// <reference types="node" />
import { EncodedLogicSig, EncodedLogicSigAccount, EncodedMultisig, MultisigMetadata } from "algosdk";
/**
 * Note: We cannot use algosdk LogicSig class here,
 * because algosdk.makeLogicSig() takes compiled bytes as a argument
 * and currently we don't calculate compiled bytes from TEAL program.
 * We are using raw TEAL code as program.(by converting string into bytes)
 */
export declare class LogicSig {
    logic: Uint8Array;
    args: Uint8Array[];
    sig?: Uint8Array;
    msig?: EncodedMultisig;
    lsigAddress: string;
    tag: Buffer;
    constructor(program: string, programArgs?: Array<Uint8Array | Buffer> | null);
    /**
     * Creates signature (if no msig provided) or multi signature otherwise
     * @param secretKey sender's secret key
     * @param msig multisignature if it exists
     */
    sign(secretKey: Uint8Array, msig?: MultisigMetadata): void;
    /**
     * Sign Multisignature
     * @param secretKey Secret key to sign with
     * @param msig Multisignature
     */
    singleSignMultisig(secretKey: Uint8Array, msig: EncodedMultisig): [Uint8Array, number];
    /**
     * Appends a signature to multi signature
     * @param {Uint8Array} secretKey Secret key to sign with
     */
    appendToMultisig(secretKey: Uint8Array): void;
    /**
     * Performs signature verification
     * @param accAddr Sender's account address
     */
    verify(accPk: Uint8Array): boolean;
    /**
     * Verify multi-signature
     * @param msig Msig
     * @param accAddr Sender's account address
     */
    verifyMultisig(msig: EncodedMultisig, accAddr: string): boolean;
    /**
     * Returns signed logic
     * @param secretKey: account's secret key
     */
    signProgram(secretKey: Uint8Array): Uint8Array;
    /**
     * Returns logic signature address
     */
    address(): string;
    /**
     * Returns program associated with logic signature
     */
    program(): string;
    /**
     * Note: following functions are dummy functions
     * they are used only to match type with algosdk LogicSig
     * there is a possibility that we may use them in future.
     */
    toByte(): Uint8Array;
    fromByte(val: Uint8Array): LogicSig;
    get_obj_for_encoding(): EncodedLogicSig;
    static from_obj_for_encoding(lsig: EncodedLogicSig): LogicSig;
}
export declare class LogicSigAccount {
    lsig: LogicSig;
    sigkey?: Uint8Array;
    /**
     * Create a new LogicSigAccount. By default this will create an escrow
     * LogicSig account. Call `sign` or `signMultisig` on the newly created
     * LogicSigAccount to make it a delegated account.
     *
     * @param program - program in TEAL file
     * @param args - An optional array of arguments for the program.
     */
    constructor(program: string, programArgs?: Array<Uint8Array | Buffer> | null);
    /**
     * Note: following functions are dummy functions
     * they are used only to match type with algosdk LogicSigAccount
     * there is a possibility that we may use them in future.
     */
    get_obj_for_encoding(): EncodedLogicSigAccount;
    static from_obj_for_encoding(encoded: EncodedLogicSigAccount): LogicSigAccount;
    toByte(): Uint8Array;
    static fromByte(encoded: ArrayLike<any>): LogicSigAccount;
    /**
     * Check if this LogicSigAccount has been delegated to another account with a
     * signature.
     *
     * Note this function only checks for the presence of a delegation signature.
     * To verify the delegation signature, use `verify`.
     */
    isDelegated(): boolean;
    /**
     * Verifies this LogicSig's program and signatures.
     * @returns true if and only if the LogicSig program and signatures are valid.
     */
    verify(): boolean;
    /**
     * Get the address of this LogicSigAccount.
     *
     * If the LogicSig is delegated to another account, this will return the
     * address of that account.
     *
     * If the LogicSig is not delegated to another account, this will return an
     *  escrow address that is the hash of the LogicSig's program code.
     */
    address(): string;
    /**
     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
     * has the authority to sign transactions on behalf of another account, called
     * the delegating account. Use this function if the delegating account is a
     * multisig account.
     *
     * @param msig - The multisig delegating account
     * @param secretKey - The secret key of one of the members of the delegating
     *   multisig account. Use `appendToMultisig` to add additional signatures
     *   from other members.
     */
    signMultisig(msig: MultisigMetadata, secretKey: Uint8Array): void;
    /**
     * Adds an additional signature from a member of the delegating multisig
     * account.
     *
     * @param secretKey - The secret key of one of the members of the delegating
     *   multisig account.
     */
    appendToMultisig(secretKey: Uint8Array): void;
    /**
     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
     * has the authority to sign transactions on behalf of another account, called
     * the delegating account. If the delegating account is a multisig account,
     * use `signMultisig` instead.
     *
     * @param secretKey - The secret key of the delegating account.
     */
    sign(secretKey: Uint8Array): void;
}
