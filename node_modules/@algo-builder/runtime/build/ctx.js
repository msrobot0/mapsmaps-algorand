"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ctx = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const _1 = require(".");
const account_1 = require("./account");
const errors_list_1 = require("./errors/errors-list");
const runtime_errors_1 = require("./errors/runtime-errors");
const asa_1 = require("./lib/asa");
const constants_1 = require("./lib/constants");
const pycompile_op_1 = require("./lib/pycompile-op");
const tx_1 = require("./mock/tx");
const types_1 = require("./types");
const APPROVAL_PROGRAM = "approval-program";
class Ctx {
    constructor(state, tx, gtxs, args, runtime, debugStack) {
        this.state = state;
        this.tx = tx;
        this.gtxs = gtxs;
        this.args = args;
        this.runtime = runtime;
        this.debugStack = debugStack;
        // Mapping from the tx index number to the scratch space.
        // Scratch space is a list of elements.
        this.sharedScratchSpace = new Map();
        this.knowableID = new Map();
        this.pooledApplCost = 0;
        // inner transaction props
        this.isInnerTx = false;
        this.createdAssetID = 0;
    }
    setAndGetTxReceipt() {
        const info = { txn: this.tx, txID: this.tx.txID };
        this.state.txReceipts.set(this.tx.txID, info);
        return info;
    }
    // verify account's balance is above minimum required balance
    assertAccBalAboveMin(address) {
        const account = this.getAccount(address);
        if (account.balance() < account.minBalance) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_BALANCE, {
                accBalance: account.balance(),
                address: address,
                minbalance: account.minBalance
            });
        }
    }
    // verifies assetId is not frozen for an account
    assertAssetNotFrozen(assetIndex, address) {
        const assetHolding = this.getAssetHolding(assetIndex, address);
        if (assetHolding["is-frozen"]) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.ACCOUNT_ASSET_FROZEN, {
                assetId: assetIndex,
                address: address
            });
        }
    }
    /**
     * Fetches account from `runtime.ctx`
     * @param address account address
     */
    getAccount(address) {
        const account = this.state.accounts.get(address);
        return this.runtime.assertAccountDefined(address, account);
    }
    /**
     * Returns asset creator account from runtime.ctx or throws error is it doesn't exist
     * @param Asset Index
     */
    getAssetAccount(assetId) {
        const addr = this.state.assetDefs.get(assetId);
        if (addr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASSET_NOT_FOUND, { assetId: assetId });
        }
        return this.runtime.assertAccountDefined(addr, this.state.accounts.get(addr));
    }
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId) {
        const creatorAcc = this.getAssetAccount(assetId);
        const assetDef = creatorAcc.getAssetDef(assetId);
        return this.runtime.assertAssetDefined(assetId, assetDef);
    }
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex, address) {
        const account = this.runtime.assertAccountDefined(address, this.state.accounts.get(address));
        const assetHolding = account.getAssetHolding(assetIndex);
        if (assetHolding === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.ASA_NOT_OPTIN, {
                assetId: assetIndex,
                address: address
            });
        }
        return assetHolding;
    }
    /**
     * Fetches app from `ctx state`
     * @param appID Application Index'
     * @param line Line number in teal file
     */
    getApp(appID, line) {
        const lineNumber = line ?? 'unknown';
        if (!this.state.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, { appID: appID, line: lineNumber });
        }
        const accAddress = this.runtime.assertAddressDefined(this.state.globalApps.get(appID));
        const account = this.runtime.assertAccountDefined(accAddress, this.state.accounts.get(accAddress));
        return this.runtime.assertAppDefined(appID, account.getApp(appID));
    }
    // transfer ALGO as per transaction parameters
    transferAlgo(txParam) {
        const fromAccount = this.getAccount(web_1.tx.getFromAddress(txParam));
        const toAccount = this.getAccount(txParam.toAccountAddr);
        txParam.amountMicroAlgos = BigInt(txParam.amountMicroAlgos);
        fromAccount.amount -= txParam.amountMicroAlgos; // remove 'x' algo from sender
        toAccount.amount += BigInt(txParam.amountMicroAlgos); // add 'x' algo to receiver
        this.assertAccBalAboveMin(fromAccount.address);
        if (txParam.payFlags.closeRemainderTo) {
            const closeRemToAcc = this.getAccount(txParam.payFlags.closeRemainderTo);
            closeRemToAcc.amount += fromAccount.amount; // transfer funds of sender to closeRemTo account
            fromAccount.amount = 0n; // close sender's account
        }
        return this.setAndGetTxReceipt();
    }
    /**
     * Deploy asset using asa.yaml file
     * @param name asset name
     * @param fromAccountAddr account address
     * @param flags asa deployment flags
     */
    deployASA(name, fromAccountAddr, flags) {
        return this.deployASADef(name, this.runtime.loadedAssetsDefs[name], fromAccountAddr, flags);
    }
    /**
     * Deploy Asset without using asa.yaml file
     * @param name ASA name
     * @param asaDef asset defitions
     * @param fromAccountAddr account address of creator
     * @param flags ASA Deployment Flags
     */
    deployASADef(name, asaDef, fromAccountAddr, flags) {
        const senderAcc = this.getAccount(fromAccountAddr);
        (0, _1.parseASADef)(asaDef);
        (0, asa_1.validateOptInAccNames)(this.state.accountNameAddress, asaDef);
        // create asset(with holding) in sender account
        const asset = senderAcc.addAsset(++this.state.assetCounter, name, asaDef);
        this.assertAccBalAboveMin(fromAccountAddr);
        this.runtime.mkAssetCreateTx(name, flags, asset);
        this.state.assetDefs.set(this.state.assetCounter, senderAcc.address);
        this.state.assetNameInfo.set(name, {
            creator: senderAcc.address,
            assetIndex: this.state.assetCounter,
            assetDef: asset,
            txId: this.tx.txID,
            confirmedRound: this.runtime.getRound(),
            deleted: false
        });
        if (this.isInnerTx) {
            this.createdAssetID = this.state.assetCounter;
        }
        // set & return transaction receipt
        const receipt = {
            txn: this.tx,
            txID: this.tx.txID,
            assetID: this.state.assetCounter
        };
        this.state.txReceipts.set(this.tx.txID, receipt);
        return receipt;
    }
    /**
     * Asset Opt-In for account in context
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optIntoASA(assetIndex, address, flags) {
        const assetDef = this.getAssetDef(assetIndex);
        (0, algosdk_1.makeAssetTransferTxnWithSuggestedParams)(address, address, undefined, undefined, 0, undefined, assetIndex, (0, tx_1.mockSuggestedParams)(flags, this.runtime.getRound()));
        const assetHolding = {
            amount: 0n,
            'asset-id': assetIndex,
            creator: assetDef.creator,
            'is-frozen': assetDef.defaultFrozen ? assetDef.defaultFrozen : false
        };
        const account = this.getAccount(address);
        account.optInToASA(assetIndex, assetHolding);
        this.assertAccBalAboveMin(address);
        return this.setAndGetTxReceipt();
    }
    /**
     * deploy a new application and returns application id
     * @param fromAccountAddr creator account address
     * @param flags SSCDeployment flags
     * @param approvalProgram application approval program (TEAL code or program filename)
     * @param clearProgram application clear program (TEAL code or program filename)
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     * NOTE When creating or opting into an app, the minimum balance grows before the app code runs
     */
    deployApp(fromAccountAddr, flags, approvalProgram, clearProgram, idx, scTmplParams) {
        const senderAcc = this.getAccount(fromAccountAddr);
        const approvalProgTEAL = (approvalProgram.endsWith(pycompile_op_1.tealExt) || approvalProgram.endsWith(pycompile_op_1.pyExt))
            ? (0, _1.getProgram)(approvalProgram, scTmplParams)
            : approvalProgram;
        const clearProgTEAL = (clearProgram.endsWith(pycompile_op_1.tealExt) || clearProgram.endsWith(pycompile_op_1.pyExt))
            ? (0, _1.getProgram)(clearProgram, scTmplParams)
            : clearProgram;
        if (approvalProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_APPROVAL_PROGRAM);
        }
        if (clearProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_CLEAR_PROGRAM);
        }
        // create app with id = 0 in globalApps for teal execution
        const app = senderAcc.addApp(0, flags, approvalProgTEAL, clearProgTEAL);
        this.assertAccBalAboveMin(senderAcc.address);
        this.state.accounts.set(senderAcc.address, senderAcc);
        this.state.globalApps.set(app.id, senderAcc.address);
        this.runtime.run(approvalProgTEAL, types_1.ExecutionMode.APPLICATION, idx, this.debugStack); // execute TEAL code with appID = 0
        // create new application in globalApps map
        this.state.globalApps.set(++this.state.appCounter, senderAcc.address);
        const attributes = this.getApp(0);
        senderAcc.createdApps.delete(0); // remove zero app from sender's account
        this.state.globalApps.delete(0); // remove zero app from context
        senderAcc.createdApps.set(this.state.appCounter, attributes);
        this.state.appNameInfo.set(approvalProgram + "-" + clearProgram, {
            creator: senderAcc.address,
            appID: this.state.appCounter,
            applicationAccount: (0, algosdk_1.getApplicationAddress)(this.state.appCounter),
            txId: this.tx.txID,
            confirmedRound: this.runtime.getRound(),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false
        });
        const acc = new _1.AccountStore(0, new account_1.RuntimeAccount({
            addr: (0, algosdk_1.getApplicationAddress)(this.state.appCounter),
            sk: new Uint8Array(0)
        }));
        this.state.accounts.set(acc.address, acc);
        // set & return transaction receipt
        const receipt = this.state.txReceipts.get(this.tx.txID);
        receipt.appID = this.state.appCounter;
        return receipt;
    }
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address to opt into application
     * @param appID Application index
     * @param idx index of transaction in group
     * NOTE: When creating or opting into an app, the minimum balance grows before the app code runs
     */
    optInToApp(accountAddr, appID, idx) {
        const appParams = this.getApp(appID);
        const account = this.getAccount(accountAddr);
        account.optInToApp(appID, appParams);
        this.assertAccBalAboveMin(accountAddr);
        try {
            return this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
        }
        catch (error) {
            account.closeApp(appID); // remove already added state if optIn fails
            throw error;
        }
    }
    /**
     * Verify Pooled Transaction Fees
     * supports pooled fees where one transaction can pay the
     * fees of other transactions within an atomic group.
     * For atomic transactions, the protocol sums the number of
     * transactions and calculates the total amount of required fees,
     * then calculates the amount of fees submitted by all transactions.
     * If the collected fees are greater than or equal to the required amount,
     * the transaction fee requirement will be met.
     * https://developer.algorand.org/articles/introducing-algorand-virtual-machine-avm-09-release/
     */
    verifyMinimumFees() {
        if (this.isInnerTx) {
            return;
        } // pooled fee for inner tx is calculated at itx_submit
        let collected = 0;
        for (const val of this.gtxs) {
            if (val.fee === undefined)
                val.fee = 0;
            collected += val.fee;
        }
        const required = this.gtxs.length * constants_1.ALGORAND_MIN_TX_FEE;
        if (collected < required) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.FEES_NOT_ENOUGH, {
                required: required,
                collected: collected
            });
        }
    }
    /**
     * Deduct transaction fee from sender account.
     * @param sender Sender address
     * @param index Index of current tx being processed in tx group
     */
    deductFee(sender, index, params) {
        let fee = BigInt(this.gtxs[index].fee);
        // If flatFee boolean is not set, change fee value
        if (!params.flatFee && params.totalFee === undefined) {
            fee = BigInt(Math.max(constants_1.ALGORAND_MIN_TX_FEE, Number(this.gtxs[index].fee)));
        }
        const fromAccount = this.getAccount(sender);
        fromAccount.amount -= fee; // remove tx fee from Sender's account
        this.assertAccBalAboveMin(fromAccount.address);
    }
    // transfer ASSET as per transaction parameters
    transferAsset(txParam) {
        const fromAccountAddr = web_1.tx.getFromAddress(txParam);
        txParam.amount = BigInt(txParam.amount);
        if (txParam.amount === 0n && fromAccountAddr === txParam.toAccountAddr) {
            this.optIntoASA(txParam.assetID, fromAccountAddr, txParam.payFlags);
        }
        else if (txParam.amount !== 0n) {
            this.assertAssetNotFrozen(txParam.assetID, fromAccountAddr);
            this.assertAssetNotFrozen(txParam.assetID, txParam.toAccountAddr);
        }
        const fromAssetHolding = this.getAssetHolding(txParam.assetID, fromAccountAddr);
        const toAssetHolding = this.getAssetHolding(txParam.assetID, txParam.toAccountAddr);
        if (fromAssetHolding.amount - txParam.amount < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_ASSETS, {
                amount: txParam.amount,
                address: fromAccountAddr
            });
        }
        fromAssetHolding.amount -= txParam.amount;
        toAssetHolding.amount += BigInt(txParam.amount);
        if (txParam.payFlags.closeRemainderTo) {
            const closeToAddr = txParam.payFlags.closeRemainderTo;
            if (fromAccountAddr === fromAssetHolding.creator) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CANNOT_CLOSE_ASSET_BY_CREATOR);
            }
            this.assertAssetNotFrozen(txParam.assetID, closeToAddr);
            const closeRemToAssetHolding = this.getAssetHolding(txParam.assetID, closeToAddr);
            closeRemToAssetHolding.amount += fromAssetHolding.amount; // transfer assets of sender to closeRemTo account
            const fromAccount = this.getAccount(fromAccountAddr);
            fromAccount.closeAsset(txParam.assetID);
        }
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#modifying-an-asset
     * Modifies asset fields
     * @param assetId Asset Index
     * @param fields Asset modifying fields
     */
    modifyAsset(assetId, fields) {
        const creatorAcc = this.getAssetAccount(assetId);
        creatorAcc.modifyAsset(assetId, fields);
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#freezing-an-asset
     * Freezes assets for a target account
     * @param assetId asset index
     * @param freezeTarget target account
     * @param freezeState target state
     */
    freezeAsset(assetId, freezeTarget, freezeState) {
        const acc = this.runtime.assertAccountDefined(freezeTarget, this.state.accounts.get(freezeTarget));
        acc.setFreezeState(assetId, freezeState);
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#revoking-an-asset
     * Revoking an asset for an account removes a specific number of the asset
     * from the revoke target account.
     * @param recipient asset receiver address
     * @param assetId asset index
     * @param revocationTarget revoke target account
     * @param amount amount of assets
     */
    revokeAsset(recipient, assetID, revocationTarget, amount) {
        // Transfer assets
        const fromAssetHolding = this.getAssetHolding(assetID, revocationTarget);
        const toAssetHolding = this.getAssetHolding(assetID, recipient);
        if (fromAssetHolding.amount - amount < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_ASSETS, {
                amount: amount,
                address: revocationTarget
            });
        }
        fromAssetHolding.amount -= amount;
        toAssetHolding.amount += amount;
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#destroying-an-asset
     * Destroy asset
     * @param assetId asset index
     */
    destroyAsset(assetId) {
        const creatorAcc = this.getAssetAccount(assetId);
        // destroy asset from creator's account
        creatorAcc.destroyAsset(assetId);
        // delete asset holdings from all accounts
        this.state.accounts.forEach((value, key) => {
            value.assets.delete(assetId);
        });
        return this.setAndGetTxReceipt();
    }
    /**
     * Delete application from account's state and global state
     * @param appID Application Index
     */
    deleteApp(appID) {
        if (!this.state.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, { appID: appID, line: 'unknown' });
        }
        const accountAddr = this.runtime.assertAddressDefined(this.state.globalApps.get(appID));
        if (accountAddr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST);
        }
        const account = this.runtime.assertAccountDefined(accountAddr, this.state.accounts.get(accountAddr));
        account.deleteApp(appID);
        this.state.globalApps.delete(appID);
    }
    /**
     * Closes application from account's state
     * @param sender Sender address
     * @param appID application index
     */
    closeApp(sender, appID) {
        const fromAccount = this.getAccount(sender);
        // https://developer.algorand.org/docs/reference/cli/goal/app/closeout/#search-overlay
        this.runtime.assertAppDefined(appID, this.getApp(appID));
        fromAccount.closeApp(appID); // remove app from local state
    }
    /**
     * Update application
     * @param appID application Id
     * @param approvalProgram new approval program (TEAL code or program filename)
     * @param clearProgram new clear program (TEAL code or program filename)
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     */
    updateApp(appID, approvalProgram, clearProgram, idx, scTmplParams) {
        const approvalProgTEAL = (approvalProgram.endsWith(pycompile_op_1.tealExt) || approvalProgram.endsWith(pycompile_op_1.pyExt))
            ? (0, _1.getProgram)(approvalProgram, scTmplParams)
            : approvalProgram;
        const clearProgTEAL = (clearProgram.endsWith(pycompile_op_1.tealExt) || clearProgram.endsWith(pycompile_op_1.pyExt))
            ? (0, _1.getProgram)(clearProgram, scTmplParams)
            : clearProgram;
        if (approvalProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_APPROVAL_PROGRAM);
        }
        if (clearProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_CLEAR_PROGRAM);
        }
        const appParams = this.getApp(appID);
        const txReceipt = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
        const updatedApp = this.getApp(appID);
        updatedApp[APPROVAL_PROGRAM] = approvalProgTEAL;
        updatedApp["clear-state-program"] = clearProgTEAL;
        return txReceipt;
    }
    // apply rekey config on from account
    rekeyTo(txParam) {
        if (!txParam.payFlags.rekeyTo)
            return;
        const fromAccount = this.getAccount(web_1.tx.getFromAddress(txParam));
        // apply rekey
        fromAccount.rekeyTo(txParam.payFlags.rekeyTo);
    }
    /**
     * Process transactions in ctx
     * - Runs TEAL code if associated with transaction
     * - Executes the transaction on ctx
     * Note: we're doing this because if any one tx in group fails,
     * then it does not affect runtime.store, otherwise we just update
     * store with ctx (if all transactions are executed successfully).
     * @param txParams Transaction Parameters
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    processTransactions(txParams) {
        const txReceipts = [];
        let r;
        this.verifyMinimumFees();
        txParams.forEach((txParam, idx) => {
            const fromAccountAddr = web_1.tx.getFromAddress(txParam);
            this.deductFee(fromAccountAddr, idx, txParam.payFlags);
            if (txParam.sign === web_1.types.SignType.LogicSignature) {
                this.tx = this.gtxs[idx]; // update current tx to index of stateless
                r = this.runtime.validateLsigAndRun(txParam, this.debugStack);
                this.tx = this.gtxs[0]; // after executing stateless tx updating current tx to default (index 0)
            }
            else if (txParam.sign === web_1.types.SignType.SecretKey) {
                this.runtime.validateAccountSignature(txParam);
            }
            // https://developer.algorand.org/docs/features/asc1/stateful/#the-lifecycle-of-a-stateful-smart-contract
            switch (txParam.type) {
                case web_1.types.TransactionType.TransferAlgo: {
                    r = this.transferAlgo(txParam);
                    break;
                }
                case web_1.types.TransactionType.TransferAsset: {
                    r = this.transferAsset(txParam);
                    break;
                }
                case web_1.types.TransactionType.CallApp: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    const appParams = this.getApp(txParam.appID);
                    r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                    break;
                }
                case web_1.types.TransactionType.CloseApp: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    const appParams = this.getApp(txParam.appID);
                    r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                    this.closeApp(fromAccountAddr, txParam.appID);
                    break;
                }
                case web_1.types.TransactionType.UpdateApp: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    r = this.updateApp(txParam.appID, txParam.newApprovalProgram, txParam.newClearProgram, idx);
                    break;
                }
                case web_1.types.TransactionType.ClearApp: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    const appParams = this.runtime.assertAppDefined(txParam.appID, this.getApp(txParam.appID));
                    try {
                        r = this.runtime.run(appParams["clear-state-program"], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                    }
                    catch (error) {
                        // if transaction type is Clear Call, remove the app without throwing error (rejecting tx)
                        // tested by running on algorand network
                        // https://developer.algorand.org/docs/features/asc1/stateful/#the-lifecycle-of-a-stateful-smart-contract
                    }
                    this.closeApp(fromAccountAddr, txParam.appID); // remove app from local state
                    break;
                }
                case web_1.types.TransactionType.DeleteApp: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    const appParams = this.getApp(txParam.appID);
                    r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                    this.deleteApp(txParam.appID);
                    break;
                }
                case web_1.types.TransactionType.ModifyAsset: {
                    const asset = this.getAssetDef(txParam.assetID);
                    if (asset.manager !== fromAccountAddr) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.MANAGER_ERROR, { address: asset.manager });
                    }
                    // modify asset in ctx.
                    r = this.modifyAsset(txParam.assetID, txParam.fields);
                    break;
                }
                case web_1.types.TransactionType.FreezeAsset: {
                    const asset = this.getAssetDef(txParam.assetID);
                    if (asset.freeze !== fromAccountAddr) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.FREEZE_ERROR, { address: asset.freeze });
                    }
                    r = this.freezeAsset(txParam.assetID, txParam.freezeTarget, txParam.freezeState);
                    break;
                }
                case web_1.types.TransactionType.RevokeAsset: {
                    const asset = this.getAssetDef(txParam.assetID);
                    if (asset.clawback !== fromAccountAddr) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CLAWBACK_ERROR, { address: asset.clawback });
                    }
                    if (txParam.payFlags.closeRemainderTo) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CANNOT_CLOSE_ASSET_BY_CLAWBACK);
                    }
                    r = this.revokeAsset(txParam.recipient, txParam.assetID, txParam.revocationTarget, BigInt(txParam.amount));
                    break;
                }
                case web_1.types.TransactionType.DestroyAsset: {
                    const asset = this.getAssetDef(txParam.assetID);
                    if (asset.manager !== fromAccountAddr) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.MANAGER_ERROR, { address: asset.manager });
                    }
                    r = this.destroyAsset(txParam.assetID);
                    break;
                }
                case web_1.types.TransactionType.DeployASA: {
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    const senderAcc = this.getAccount(fromAccountAddr);
                    const flags = {
                        ...txParam.payFlags,
                        creator: { ...senderAcc.account, name: senderAcc.address }
                    };
                    if (txParam.asaDef) {
                        r = this.deployASADef(txParam.asaName, txParam.asaDef, fromAccountAddr, flags);
                    }
                    else {
                        r = this.deployASA(txParam.asaName, fromAccountAddr, flags);
                    }
                    this.knowableID.set(idx, r.assetID);
                    break;
                }
                case web_1.types.TransactionType.OptInASA: {
                    r = this.optIntoASA(txParam.assetID, fromAccountAddr, txParam.payFlags);
                    break;
                }
                case web_1.types.TransactionType.DeployApp: {
                    const senderAcc = this.getAccount(fromAccountAddr);
                    const flags = {
                        sender: senderAcc.account,
                        localInts: txParam.localInts,
                        localBytes: txParam.localBytes,
                        globalInts: txParam.globalInts,
                        globalBytes: txParam.globalBytes
                    };
                    this.tx = this.gtxs[idx]; // update current tx to the requested index
                    r = this.deployApp(fromAccountAddr, flags, txParam.approvalProgram, txParam.clearProgram, idx);
                    this.knowableID.set(idx, r.appID);
                    break;
                }
                case web_1.types.TransactionType.OptInToApp: {
                    this.tx = this.gtxs[idx]; // update current tx to tx being exectuted in group
                    r = this.optInToApp(fromAccountAddr, txParam.appID, idx);
                    break;
                }
            }
            // apply rekey after pass all logic
            this.rekeyTo(txParam);
            if (r) {
                txReceipts.push(r);
            }
        });
        return txReceipts;
    }
}
exports.Ctx = Ctx;
//# sourceMappingURL=ctx.js.map