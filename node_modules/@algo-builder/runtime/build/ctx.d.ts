import { types } from "@algo-builder/web";
import { modelsv2 } from "algosdk";
import { Runtime } from ".";
import { AccountAddress, AccountStoreI, AppDeploymentFlags, ASADeploymentFlags, AssetHoldingM, Context, DeployedAppTxReceipt, DeployedAssetTxReceipt, EncTx, ID, SCParams, SSCAttributesM, StackElem, State, TxReceipt } from "./types";
export declare class Ctx implements Context {
    state: State;
    tx: EncTx;
    gtxs: EncTx[];
    args: Uint8Array[];
    runtime: Runtime;
    debugStack?: number;
    sharedScratchSpace: Map<number, StackElem[]>;
    knowableID: Map<number, ID>;
    pooledApplCost: number;
    isInnerTx: boolean;
    createdAssetID: number;
    constructor(state: State, tx: EncTx, gtxs: EncTx[], args: Uint8Array[], runtime: Runtime, debugStack?: number);
    private setAndGetTxReceipt;
    assertAccBalAboveMin(address: string): void;
    assertAssetNotFrozen(assetIndex: number, address: AccountAddress): void;
    /**
     * Fetches account from `runtime.ctx`
     * @param address account address
     */
    getAccount(address: string): AccountStoreI;
    /**
     * Returns asset creator account from runtime.ctx or throws error is it doesn't exist
     * @param Asset Index
     */
    getAssetAccount(assetId: number): AccountStoreI;
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId: number): modelsv2.AssetParams;
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex: number, address: AccountAddress): AssetHoldingM;
    /**
     * Fetches app from `ctx state`
     * @param appID Application Index'
     * @param line Line number in teal file
     */
    getApp(appID: number, line?: number): SSCAttributesM;
    transferAlgo(txParam: types.AlgoTransferParam): TxReceipt;
    /**
     * Deploy asset using asa.yaml file
     * @param name asset name
     * @param fromAccountAddr account address
     * @param flags asa deployment flags
     */
    deployASA(name: string, fromAccountAddr: AccountAddress, flags: ASADeploymentFlags): DeployedAssetTxReceipt;
    /**
     * Deploy Asset without using asa.yaml file
     * @param name ASA name
     * @param asaDef asset defitions
     * @param fromAccountAddr account address of creator
     * @param flags ASA Deployment Flags
     */
    deployASADef(name: string, asaDef: types.ASADef, fromAccountAddr: AccountAddress, flags: ASADeploymentFlags): DeployedAssetTxReceipt;
    /**
     * Asset Opt-In for account in context
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optIntoASA(assetIndex: number, address: AccountAddress, flags: types.TxParams): TxReceipt;
    /**
     * deploy a new application and returns application id
     * @param fromAccountAddr creator account address
     * @param flags SSCDeployment flags
     * @param approvalProgram application approval program (TEAL code or program filename)
     * @param clearProgram application clear program (TEAL code or program filename)
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     * NOTE When creating or opting into an app, the minimum balance grows before the app code runs
     */
    deployApp(fromAccountAddr: AccountAddress, flags: AppDeploymentFlags, approvalProgram: string, clearProgram: string, idx: number, scTmplParams?: SCParams): DeployedAppTxReceipt;
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address to opt into application
     * @param appID Application index
     * @param idx index of transaction in group
     * NOTE: When creating or opting into an app, the minimum balance grows before the app code runs
     */
    optInToApp(accountAddr: AccountAddress, appID: number, idx: number): TxReceipt;
    /**
     * Verify Pooled Transaction Fees
     * supports pooled fees where one transaction can pay the
     * fees of other transactions within an atomic group.
     * For atomic transactions, the protocol sums the number of
     * transactions and calculates the total amount of required fees,
     * then calculates the amount of fees submitted by all transactions.
     * If the collected fees are greater than or equal to the required amount,
     * the transaction fee requirement will be met.
     * https://developer.algorand.org/articles/introducing-algorand-virtual-machine-avm-09-release/
     */
    verifyMinimumFees(): void;
    /**
     * Deduct transaction fee from sender account.
     * @param sender Sender address
     * @param index Index of current tx being processed in tx group
     */
    deductFee(sender: AccountAddress, index: number, params: types.TxParams): void;
    transferAsset(txParam: types.AssetTransferParam): TxReceipt;
    /**
     * https://developer.algorand.org/docs/features/asa/#modifying-an-asset
     * Modifies asset fields
     * @param assetId Asset Index
     * @param fields Asset modifying fields
     */
    modifyAsset(assetId: number, fields: types.AssetModFields): TxReceipt;
    /**
     * https://developer.algorand.org/docs/features/asa/#freezing-an-asset
     * Freezes assets for a target account
     * @param assetId asset index
     * @param freezeTarget target account
     * @param freezeState target state
     */
    freezeAsset(assetId: number, freezeTarget: string, freezeState: boolean): TxReceipt;
    /**
     * https://developer.algorand.org/docs/features/asa/#revoking-an-asset
     * Revoking an asset for an account removes a specific number of the asset
     * from the revoke target account.
     * @param recipient asset receiver address
     * @param assetId asset index
     * @param revocationTarget revoke target account
     * @param amount amount of assets
     */
    revokeAsset(recipient: string, assetID: number, revocationTarget: string, amount: bigint): TxReceipt;
    /**
     * https://developer.algorand.org/docs/features/asa/#destroying-an-asset
     * Destroy asset
     * @param assetId asset index
     */
    destroyAsset(assetId: number): TxReceipt;
    /**
     * Delete application from account's state and global state
     * @param appID Application Index
     */
    deleteApp(appID: number): void;
    /**
     * Closes application from account's state
     * @param sender Sender address
     * @param appID application index
     */
    closeApp(sender: AccountAddress, appID: number): void;
    /**
     * Update application
     * @param appID application Id
     * @param approvalProgram new approval program (TEAL code or program filename)
     * @param clearProgram new clear program (TEAL code or program filename)
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     */
    updateApp(appID: number, approvalProgram: string, clearProgram: string, idx: number, scTmplParams?: SCParams): TxReceipt;
    rekeyTo(txParam: types.ExecParams): void;
    /**
     * Process transactions in ctx
     * - Runs TEAL code if associated with transaction
     * - Executes the transaction on ctx
     * Note: we're doing this because if any one tx in group fails,
     * then it does not affect runtime.store, otherwise we just update
     * store with ctx (if all transactions are executed successfully).
     * @param txParams Transaction Parameters
     */
    processTransactions(txParams: types.ExecParams[]): TxReceipt[];
}
