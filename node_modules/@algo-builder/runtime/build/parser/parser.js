"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parser = exports.assertMaxCost = exports.opcodeFromSentence = exports.wordsFromLine = void 0;
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const opcode_list_1 = require("../interpreter/opcode-list");
const constants_1 = require("../lib/constants");
const parsing_1 = require("../lib/parsing");
const types_1 = require("../types");
// teal v1 opcodes
const opCodeMap = {
    1: {
        // Pragma
        "#pragma": opcode_list_1.Pragma,
        len: opcode_list_1.Len,
        err: opcode_list_1.Err,
        // Arithmetic ops
        "+": opcode_list_1.Add,
        "-": opcode_list_1.Sub,
        "/": opcode_list_1.Div,
        "*": opcode_list_1.Mul,
        arg: opcode_list_1.Arg,
        bytecblock: opcode_list_1.Bytecblock,
        bytec: opcode_list_1.Bytec,
        intcblock: opcode_list_1.Intcblock,
        intc: opcode_list_1.Intc,
        "%": opcode_list_1.Mod,
        "|": opcode_list_1.BitwiseOr,
        "&": opcode_list_1.BitwiseAnd,
        "^": opcode_list_1.BitwiseXor,
        "~": opcode_list_1.BitwiseNot,
        store: opcode_list_1.Store,
        load: opcode_list_1.Load,
        // crypto opcodes
        sha256: opcode_list_1.Sha256,
        sha512_256: opcode_list_1.Sha512_256,
        keccak256: opcode_list_1.Keccak256,
        ed25519verify: opcode_list_1.Ed25519verify,
        "<": opcode_list_1.LessThan,
        ">": opcode_list_1.GreaterThan,
        "<=": opcode_list_1.LessThanEqualTo,
        ">=": opcode_list_1.GreaterThanEqualTo,
        "&&": opcode_list_1.And,
        "||": opcode_list_1.Or,
        "==": opcode_list_1.EqualTo,
        "!=": opcode_list_1.NotEqualTo,
        "!": opcode_list_1.Not,
        itob: opcode_list_1.Itob,
        btoi: opcode_list_1.Btoi,
        mulw: opcode_list_1.Mulw,
        pop: opcode_list_1.Pop,
        dup: opcode_list_1.Dup,
        // Pseudo-Ops
        addr: opcode_list_1.Addr,
        int: opcode_list_1.Int,
        byte: opcode_list_1.Byte,
        // Branch Opcodes
        bnz: opcode_list_1.BranchIfNotZero,
        // Transaction Opcodes
        txn: opcode_list_1.Txn,
        gtxn: opcode_list_1.Gtxn,
        global: opcode_list_1.Global
    }
};
// teal v2 opcodes
opCodeMap[2] = {
    ...opCodeMap[1],
    addw: opcode_list_1.Addw,
    // txn ops
    txna: opcode_list_1.Txna,
    gtxna: opcode_list_1.Gtxna,
    // branch opcodes in v2
    b: opcode_list_1.Branch,
    bz: opcode_list_1.BranchIfZero,
    return: opcode_list_1.Return,
    dup2: opcode_list_1.Dup2,
    concat: opcode_list_1.Concat,
    substring: opcode_list_1.Substring,
    substring3: opcode_list_1.Substring3,
    // Stateful Opcodes
    app_opted_in: opcode_list_1.AppOptedIn,
    app_local_get: opcode_list_1.AppLocalGet,
    app_local_get_ex: opcode_list_1.AppLocalGetEx,
    app_global_get: opcode_list_1.AppGlobalGet,
    app_global_get_ex: opcode_list_1.AppGlobalGetEx,
    app_local_put: opcode_list_1.AppLocalPut,
    app_global_put: opcode_list_1.AppGlobalPut,
    app_local_del: opcode_list_1.AppLocalDel,
    app_global_del: opcode_list_1.AppGlobalDel,
    balance: opcode_list_1.Balance,
    asset_holding_get: opcode_list_1.GetAssetHolding,
    asset_params_get: opcode_list_1.GetAssetDef
};
/**
 * TEALv3 opcodes: https://developer.algorand.org/articles/introducing-teal-version-3/
 */
opCodeMap[3] = {
    ...opCodeMap[2],
    assert: opcode_list_1.Assert,
    swap: opcode_list_1.Swap,
    // optimized opcodes for pushing uint64s and byte slices to the stack
    pushint: opcode_list_1.PushInt,
    pushbytes: opcode_list_1.PushBytes,
    // bit & byte opcodes
    getbit: opcode_list_1.GetBit,
    setbit: opcode_list_1.SetBit,
    getbyte: opcode_list_1.GetByte,
    setbyte: opcode_list_1.SetByte,
    dig: opcode_list_1.Dig,
    select: opcode_list_1.Select,
    // txn ops in tealv3
    gtxns: opcode_list_1.Gtxns,
    gtxnsa: opcode_list_1.Gtxnsa,
    // stateful op (mode = application)
    min_balance: opcode_list_1.MinBalance
};
/**
 * TEALv4 opcodes: https://developer.algorand.org/articles/introducing-algorand-virtual-machine-avm-09-release/
 */
opCodeMap[4] = {
    ...opCodeMap[3],
    gload: opcode_list_1.Gload,
    gloads: opcode_list_1.Gloads,
    callsub: opcode_list_1.Callsub,
    retsub: opcode_list_1.Retsub,
    b: opcode_list_1.Branchv4,
    bnz: opcode_list_1.BranchIfNotZerov4,
    bz: opcode_list_1.BranchIfZerov4,
    // byteslice arithmetic ops
    'b+': opcode_list_1.ByteAdd,
    'b-': opcode_list_1.ByteSub,
    'b*': opcode_list_1.ByteMul,
    'b/': opcode_list_1.ByteDiv,
    'b%': opcode_list_1.ByteMod,
    'b<': opcode_list_1.ByteLessThan,
    'b>': opcode_list_1.ByteGreatorThan,
    'b<=': opcode_list_1.ByteLessThanEqualTo,
    'b>=': opcode_list_1.ByteGreaterThanEqualTo,
    'b==': opcode_list_1.ByteEqualTo,
    'b!=': opcode_list_1.ByteNotEqualTo,
    'b|': opcode_list_1.ByteBitwiseOr,
    'b&': opcode_list_1.ByteBitwiseAnd,
    'b^': opcode_list_1.ByteBitwiseXor,
    'b~': opcode_list_1.ByteBitwiseInvert,
    bzero: opcode_list_1.ByteZero,
    divmodw: opcode_list_1.DivModw,
    exp: opcode_list_1.Exp,
    expw: opcode_list_1.Expw,
    shl: opcode_list_1.Shl,
    shr: opcode_list_1.Shr,
    sqrt: opcode_list_1.Sqrt,
    bitlen: opcode_list_1.BitLen,
    // Knowable creatable asset
    gaid: opcode_list_1.Gaid,
    gaids: opcode_list_1.Gaids
};
/**
 * TEALv5 opcodes
 */
opCodeMap[5] = {
    ...opCodeMap[4],
    cover: opcode_list_1.Cover,
    uncover: opcode_list_1.Uncover,
    loads: opcode_list_1.Loads,
    stores: opcode_list_1.Stores,
    // ECDSA
    ecdsa_verify: opcode_list_1.EcdsaVerify,
    ecdsa_pk_decompress: opcode_list_1.EcdsaPkDecompress,
    ecdsa_pk_recover: opcode_list_1.EcdsaPkRecover,
    // Extract opcodes
    extract: opcode_list_1.Extract,
    extract3: opcode_list_1.Extract3,
    extract_uint16: opcode_list_1.ExtractUint16,
    extract_uint32: opcode_list_1.ExtractUint32,
    extract_uint64: opcode_list_1.ExtractUint64,
    // Inner Transaction Ops
    itxn_begin: opcode_list_1.ITxnBegin,
    itxn_field: opcode_list_1.ITxnField,
    itxn_submit: opcode_list_1.ITxnSubmit,
    itxn: opcode_list_1.ITxn,
    itxna: opcode_list_1.ITxna,
    // gtxn, other ops
    txnas: opcode_list_1.Txnas,
    gtxnas: opcode_list_1.Gtxnas,
    gtxnsas: opcode_list_1.Gtxnsas,
    args: opcode_list_1.Args,
    log: opcode_list_1.Log,
    app_params_get: opcode_list_1.AppParamsGet
};
opCodeMap[6] = {
    ...opCodeMap[5]
};
// list of opcodes that require one extra parameter than others: `interpreter`.
const interpreterReqList = new Set([
    "#pragma", "arg", "bytecblock", "bytec", "intcblock", "intc", "store",
    "load", "b", "bz", "bnz", "return", "txn", "gtxn", "txna", "gtxna", "global",
    "balance", "asset_holding_get", "asset_params_get", "app_opted_in",
    "app_local_get", "app_local_get_ex", "app_global_get", "app_global_get_ex",
    "app_local_put", "app_global_put", "app_local_del", "app_global_del",
    "gtxns", "gtxnsa", "min_balance", "gload", "gloads", "callsub", "retsub",
    "gaid", "gaids", "loads", "stores", "itxn_begin", "itxn_field", "itxn_submit",
    "itxn", "itxna", "txnas", "gtxnas", "gtxnsas", "args", "log", 'app_params_get'
]);
/**
 * Description: Read line and split it into words
 * - ignore comments, keep only part that is relevant to interpreter
 * @param line : Line read from TEAL file
 */
/* eslint-disable sonarjs/cognitive-complexity */
function wordsFromLine(line) {
    // Trim whitespace from both sides of a string
    line = line.trim();
    const words = [];
    let i = 0;
    let start = i;
    let inString = false;
    let inBase64 = false;
    while (i < line.length) {
        // check if not space
        if (line[i] !== ' ') {
            switch (line[i]) {
                // check for string literal
                case '"':
                    if (!inString) {
                        if ((i === 0) || (i > 0 && line[i - 1] === ' ')) {
                            inString = true;
                        }
                    }
                    else {
                        // if not escape symbol
                        if (line[i - 1] !== '\\') {
                            inString = false;
                        }
                    }
                    break;
                // is a comment?
                case '/':
                    if (i < line.length - 1 && line[i + 1] === '/' && !inBase64 && !inString) {
                        // if a comment without whitespace
                        if (start !== i) {
                            words.push(line.substr(start, i - start));
                        }
                        return words;
                    }
                    break;
                // is base64( seq?
                case '(': {
                    const prefix = line.substr(start, i - start);
                    if (prefix === "base64" || prefix === "b64") {
                        inBase64 = true;
                    }
                    break;
                }
                // is ) as base64( completion
                case ')':
                    if (inBase64) {
                        inBase64 = false;
                    }
                    break;
                default:
                    break;
            }
            i++;
            continue;
        }
        if (!inString) {
            const value = line.substr(start, i - start);
            words.push(value);
            if (value === "base64" || value === "b64") {
                inBase64 = true;
            }
            else if (inBase64) {
                inBase64 = false;
            }
        }
        i++;
        if (!inString) {
            while (i < line.length && line[i] === ' ') {
                i++;
            }
            start = i;
        }
    }
    // add rest of the string if any
    if (start < line.length) {
        words.push(line.substr(start, i - start));
    }
    return words;
}
exports.wordsFromLine = wordsFromLine;
/**
 * Description: Returns Opcode object for given field
 * NOTE: we are also calculating the gas cost associated with each opcode,
 * and throwing error if the total gas of TEAL code exceeds the max gas cost for
 * respective execution modes
 * @param words : words extracted from line
 * @param counter: line number in TEAL file
 * @param interpreter: interpreter object
 */
function opcodeFromSentence(words, counter, interpreter) {
    let opCode = words[0];
    const tealVersion = interpreter.tealVersion;
    // arg
    if (opCode.startsWith("arg_")) {
        (0, parsing_1.assertLen)(words.length, 1, counter);
        words = [];
        words.push("arg_");
        words.push(opCode.slice(4));
        opCode = "arg";
    }
    // intc
    if (opCode.startsWith("intc_")) {
        (0, parsing_1.assertLen)(words.length, 1, counter);
        words = [];
        words.push("intc_");
        words.push(opCode.slice(5));
        opCode = "intc";
    }
    // bytec
    if (opCode.startsWith("bytec_")) {
        (0, parsing_1.assertLen)(words.length, 1, counter);
        words = [];
        words.push("bytec_");
        words.push(opCode.slice(6));
        opCode = "bytec";
    }
    words.shift();
    // Handle Label
    if (opCode.endsWith(':')) {
        (0, parsing_1.assertLen)(words.length, 0, counter);
        if (opCodeMap[tealVersion][opCode.slice(0, opCode.length - 1)] !== undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_LABEL, { line: counter }); // eg. `int:` is invalid label as `int` is an opcode
        }
        interpreter.lineToCost[counter] = 0;
        return new opcode_list_1.Label([opCode], counter);
    }
    if (opCodeMap[tealVersion][opCode] === undefined) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_OPCODE, { opcode: opCode, version: tealVersion, line: counter });
    }
    // store cost for opcodes at each line in `interpreter.lineToCost`
    if (opCode === '#pragma') {
        interpreter.lineToCost[counter] = 0;
    }
    else {
        interpreter.lineToCost[counter] = constants_1.OpGasCost[tealVersion][opCode] ?? 1;
    }
    interpreter.gas += interpreter.lineToCost[counter]; // total "static" cost
    if (interpreterReqList.has(opCode)) {
        return new opCodeMap[tealVersion][opCode](words, counter, interpreter);
    }
    return new opCodeMap[tealVersion][opCode](words, counter);
}
exports.opcodeFromSentence = opcodeFromSentence;
/**
 * verify max cost of TEAL code is within consensus parameters
 * @param gas total cost consumed by the TEAL code (can be dynamic or static)
 * @param mode Execution mode - Signature (stateless) OR Application (stateful)
 * @param maxPooledApplCost Since AVM 1.0, opcode cost for APPLICATION mode can be pooled accross
 * multiple transactions. If passed, gas is evaluated against maxPooledApplCost
 */
function assertMaxCost(gas, mode, maxPooledApplCost) {
    if (mode === types_1.ExecutionMode.SIGNATURE) {
        // check max cost (for stateless)
        if (gas > constants_1.LogicSigMaxCost) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_COST_EXCEEDED, {
                cost: gas,
                maxcost: constants_1.LogicSigMaxCost,
                mode: 'Stateless'
            });
        }
    }
    else {
        if (gas > (maxPooledApplCost ?? constants_1.MaxAppProgramCost)) {
            // check max cost (for stateful)
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_COST_EXCEEDED, {
                cost: gas,
                maxcost: maxPooledApplCost ?? constants_1.MaxAppProgramCost,
                mode: 'Stateful'
            });
        }
    }
}
exports.assertMaxCost = assertMaxCost;
// verify max length of TEAL code is within consensus parameters
function _assertMaxLen(len, mode) {
    if (mode === types_1.ExecutionMode.SIGNATURE) {
        // check max program cost (for stateless)
        if (len > constants_1.LogicSigMaxSize) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_LEN_EXCEEDED, {
                length: len,
                maxlen: constants_1.LogicSigMaxSize,
                mode: 'Stateless'
            });
        }
    }
    else {
        if (len > constants_1.MaxAppProgramLen) {
            // check max program length (for stateful)
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_LEN_EXCEEDED, {
                length: len,
                maxlen: constants_1.MaxAppProgramLen,
                mode: 'Stateful'
            });
        }
    }
}
/**
 * Description: Returns a list of Opcodes object after reading text from given TEAL file
 * @param program : TEAL code as string
 * @param mode : execution mode of TEAL code (Stateless or Application)
 * @param interpreter: interpreter object
 */
function parser(program, mode, interpreter) {
    const opCodeList = [];
    let counter = 0;
    const lines = program.split('\n');
    for (const line of lines) {
        counter++;
        // If line is blank or is comment, continue.
        if (line.length === 0 || line.startsWith("//")) {
            continue;
        }
        // Trim whitespace from line and extract words from line
        const words = wordsFromLine(line);
        if (words.length !== 0) {
            opCodeList.push(opcodeFromSentence(words, counter, interpreter));
        }
    }
    // for versions <= 3, cost is calculated & evaluated statically
    if (interpreter.tealVersion <= 3) {
        assertMaxCost(interpreter.gas, mode);
    }
    // TODO: check if we can calculate length in: https://www.pivotaltracker.com/story/show/176623588
    // assertMaxLen(interpreter.length, mode);
    return opCodeList;
}
exports.parser = parser;
//# sourceMappingURL=parser.js.map