"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = void 0;
/* eslint sonarjs/no-duplicate-string: 0 */
/* eslint sonarjs/no-small-switch: 0 */
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const account_1 = require("./account");
const ctx_1 = require("./ctx");
const errors_list_1 = require("./errors/errors-list");
const runtime_errors_1 = require("./errors/runtime-errors");
const index_1 = require("./index");
const constants_1 = require("./lib/constants");
const parsing_1 = require("./lib/parsing");
const logicsig_1 = require("./logicsig");
const tx_1 = require("./mock/tx");
const types_1 = require("./types");
class Runtime {
    constructor(accounts) {
        // runtime store
        this.store = {
            accounts: new Map(),
            accountNameAddress: new Map(),
            globalApps: new Map(),
            assetDefs: new Map(),
            assetNameInfo: new Map(),
            appNameInfo: new Map(),
            appCounter: constants_1.ALGORAND_MAX_TX_ARRAY_LEN,
            assetCounter: constants_1.ALGORAND_MAX_TX_ARRAY_LEN,
            txReceipts: new Map() // receipt of each transaction, i.e map of {txID: txReceipt}
        };
        // intialize accounts (should be done during runtime initialization)
        this.initializeAccounts(accounts);
        // load asa yaml files
        this.loadedAssetsDefs = (0, index_1.loadASAFile)(this.store.accountNameAddress);
        // context for interpreter
        this.ctx = new ctx_1.Ctx((0, lodash_clonedeep_1.default)(this.store), {}, [], [], this);
        this.round = 2;
        this.timestamp = 1;
    }
    /**
     * Returns transaction receipt for a particular transaction
     * @param txID transaction ID
     */
    getTxReceipt(txID) {
        return this.store.txReceipts.get(txID);
    }
    /**
     * asserts if account is defined.
     * @param a account
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAccountDefined(address, a, line) {
        const lineNumber = line ?? 'unknown';
        if (a === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST, { address: address, line: lineNumber });
        }
        return a;
    }
    /**
     * asserts if account address is defined
     * @param addr account address
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAddressDefined(addr, line) {
        const lineNumber = line ?? 'unknown';
        if (addr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST, { address: addr, line: lineNumber });
        }
        return addr;
    }
    /**
     * asserts if application exists in state
     * @param app application
     * @param appID application index
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAppDefined(appID, app, line) {
        const lineNumber = line ?? 'unknown';
        if (app === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, { appID: appID, line: lineNumber });
        }
        return app;
    }
    /**
     * asserts if asset exists in state
     * @param assetId asset index
     * @param assetDef asset definitions
     * @param line line number
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAssetDefined(assetId, assetDef, line) {
        const lineNumber = line ?? 'unknown';
        if (assetDef === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASSET_NOT_FOUND, { assetId: assetId, line: lineNumber });
        }
        return assetDef;
    }
    /**
     * Validate first and last rounds of transaction using current round
     * @param gtxns transactions
     */
    validateTxRound(gtxns) {
        // https://developer.algorand.org/docs/features/transactions/#current-round
        for (const txn of gtxns) {
            if (Number(txn.fv) >= this.round || txn.lv <= this.round) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_ROUND, { first: txn.fv, last: txn.lv, round: this.round });
            }
        }
    }
    /**
     * set current round with timestamp for a block
     * @param r current round
     * @param timestamp block's timestamp
     */
    setRoundAndTimestamp(r, timestamp) {
        this.round = r;
        this.timestamp = timestamp;
    }
    /**
     * Return current round
     */
    getRound() {
        return this.round;
    }
    /**
     * Return current timestamp
     */
    getTimestamp() {
        return this.timestamp;
    }
    /**
     * Fetches app from `this.store`
     * @param appID Application Index
     */
    getApp(appID) {
        if (!this.store.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, { appID: appID, line: 'unknown' });
        }
        const accAddress = this.assertAddressDefined(this.store.globalApps.get(appID));
        const account = this.assertAccountDefined(accAddress, this.store.accounts.get(accAddress));
        return this.assertAppDefined(appID, account.getApp(appID));
    }
    /**
     * Fetches account from `this.store`
     * @param address account address
     */
    getAccount(address) {
        const account = this.store.accounts.get(address);
        return this.assertAccountDefined(address, account);
    }
    /**
     * Fetches global state value for key present in creator's global state
     * for given appID, returns undefined otherwise
     * @param appID: current application id
     * @param key: key to fetch value of from local state
     */
    getGlobalState(appID, key) {
        if (!this.store.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, { appID: appID, line: 'unknown' });
        }
        const accAddress = this.assertAddressDefined(this.store.globalApps.get(appID));
        const account = this.assertAccountDefined(accAddress, this.store.accounts.get(accAddress));
        return account.getGlobalState(appID, key);
    }
    /**
     * Fetches local state for account address and application index
     * @param appID application index
     * @param accountAddr address for which local state needs to be retrieved
     * @param key: key to fetch value of from local state
     */
    getLocalState(appID, accountAddr, key) {
        accountAddr = this.assertAddressDefined(accountAddr);
        const account = this.assertAccountDefined(accountAddr, this.store.accounts.get(accountAddr));
        return account.getLocalState(appID, key);
    }
    /**
     * Returns asset creator account or throws error is it doesn't exist
     * @param Asset Index
     */
    getAssetAccount(assetId) {
        const addr = this.store.assetDefs.get(assetId);
        if (addr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASSET_NOT_FOUND, { assetId: assetId });
        }
        return this.assertAccountDefined(addr, this.store.accounts.get(addr));
    }
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId) {
        const creatorAcc = this.getAssetAccount(assetId);
        const assetDef = creatorAcc.getAssetDef(assetId);
        return this.assertAssetDefined(assetId, assetDef);
    }
    /**
     * Queries asset id by asset name from global state.
     * Returns undefined if asset is not found.
     * @param name Asset name
     */
    getAssetInfoFromName(name) {
        return this.store.assetNameInfo.get(name);
    }
    /**
     * Queries app id by app name from global state.
     * Returns undefined if app is not found.
     * https://www.pivotaltracker.com/story/show/180142720
     * @param approval
     * @param clear
     */
    getAppInfoFromName(approval, clear) {
        return this.store.appNameInfo.get(approval + "-" + clear);
    }
    /**
     * Setup initial accounts as {address: SDKAccount}. This should be called only when initializing Runtime.
     * @param accounts: array of account info's
     */
    initializeAccounts(accounts) {
        for (const acc of accounts) {
            if (acc.account.name)
                this.store.accountNameAddress.set(acc.account.name, acc.account.addr);
            this.store.accounts.set(acc.address, acc);
            for (const appID of acc.createdApps.keys()) {
                this.store.globalApps.set(appID, acc.address);
            }
            for (const assetId of acc.createdAssets.keys()) {
                this.store.assetDefs.set(assetId, acc.address);
            }
        }
        // add fee sink (fees + rewards collected are accumulated in this account)
        const feeSink = new account_1.AccountStore(constants_1.ALGORAND_ACCOUNT_MIN_BALANCE, new account_1.RuntimeAccount({ addr: constants_1.ZERO_ADDRESS_STR, sk: new Uint8Array(0) }));
        this.store.accounts.set(feeSink.address, feeSink);
    }
    /**
     * Creates new transaction object (tx, gtxs) from given txnParams
     * @param txnParams : Transaction parameters for current txn or txn Group
     * @returns: [current transaction, transaction group]
     */
    createTxnContext(txnParams) {
        // if txnParams is array, then user is requesting for a group txn
        if (Array.isArray(txnParams)) {
            if (txnParams.length > 16) {
                throw new Error("Maximum size of an atomic transfer group is 16");
            }
            const txns = [];
            for (const txnParam of txnParams) { // create encoded_obj for each txn in group
                const mockParams = (0, tx_1.mockSuggestedParams)(txnParam.payFlags, this.round);
                const tx = web_1.tx.mkTransaction(txnParam, mockParams);
                // convert to encoded obj for compatibility
                const encodedTxnObj = tx.get_obj_for_encoding();
                encodedTxnObj.txID = tx.txID();
                txns.push(encodedTxnObj);
            }
            return [txns[0], txns]; // by default current txn is the first txn (hence txns[0])
        }
        else {
            // if not array, then create a single transaction
            const mockParams = (0, tx_1.mockSuggestedParams)(txnParams.payFlags, this.round);
            const tx = web_1.tx.mkTransaction(txnParams, mockParams);
            const encodedTxnObj = tx.get_obj_for_encoding();
            encodedTxnObj.txID = tx.txID();
            return [encodedTxnObj, [encodedTxnObj]];
        }
    }
    // creates new asset creation transaction object.
    mkAssetCreateTx(name, flags, asaDef) {
        // this funtion is called only for validation of parameters passed
        const txn = algosdk_1.default.makeAssetCreateTxnWithSuggestedParams(flags.creator.addr, web_1.tx.encodeNote(flags.note, flags.noteb64), asaDef.total, Number(asaDef.decimals), asaDef.defaultFrozen ? asaDef.defaultFrozen : false, asaDef.manager !== "" ? asaDef.manager : undefined, asaDef.reserve !== "" ? asaDef.reserve : undefined, asaDef.freeze !== "" ? asaDef.freeze : undefined, asaDef.clawback !== "" ? asaDef.clawback : undefined, asaDef.unitName, name, asaDef.url, typeof asaDef.metadataHash !== "undefined" && typeof asaDef.metadataHash !== 'string'
            ? Buffer.from(asaDef.metadataHash).toString('base64')
            : asaDef.metadataHash, (0, tx_1.mockSuggestedParams)(flags, this.round));
        if (this.ctx.tx === undefined || this.ctx.tx.type !== constants_1.TransactionTypeEnum.ASSET_CONFIG) { // could already be defined (if used as a txGroup in this.executeTx())
            const encTx = { ...txn.get_obj_for_encoding(), txID: txn.txID() };
            this.ctx.tx = encTx;
            this.ctx.gtxs = [encTx];
        }
    }
    /**
     * Create Asset in Runtime using asa.yaml
     * @deprecated `deployASA` should be used instead
     * @param name ASA name
     * @param flags ASA Deployment Flags
     */
    addAsset(asa, flags) {
        return this.deployASA(asa, flags);
    }
    /**
     * Deploy Asset in Runtime using asa.yaml
     * @param name ASA name
     * @param flags ASA Deployment Flags
     */
    deployASA(asa, flags) {
        const txReceipt = this.ctx.deployASA(asa, flags.creator.addr, flags);
        this.store = this.ctx.state;
        this.optInToASAMultiple(this.store.assetCounter, this.loadedAssetsDefs[asa].optInAccNames);
        return txReceipt;
    }
    /**
     * Create Asset in Runtime without using asa.yaml
     * @deprecated `deployASADef` should be used instead
     * @param name ASA name
     * @param flags ASA Deployment Flags
     */
    addASADef(asa, asaDef, flags) {
        return this.deployASADef(asa, asaDef, flags);
    }
    /**
     * Deploy Asset in Runtime without using asa.yaml
     * @param name ASA name
     * @param flags ASA Deployment Flags
     */
    deployASADef(asa, asaDef, flags) {
        const txReceipt = this.ctx.deployASADef(asa, asaDef, flags.creator.addr, flags);
        this.store = this.ctx.state;
        this.optInToASAMultiple(this.store.assetCounter, asaDef.optInAccNames);
        return txReceipt;
    }
    /**
     * Opt-In to all accounts given in asa.yaml to a specific asset.
     * @param name Asset name
     * @param assetID Asset Index
     */
    optInToASAMultiple(assetID, accounts) {
        if (accounts === undefined) {
            return;
        }
        for (const accName of accounts) {
            const address = this.store.accountNameAddress.get(accName);
            if (address) {
                this.optIntoASA(assetID, address, {});
            }
        }
    }
    /**
     * Asset Opt-In for account in Runtime
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optIntoASA(assetIndex, address, flags) {
        const txReceipt = this.ctx.optIntoASA(assetIndex, address, flags);
        this.store = this.ctx.state;
        return txReceipt;
    }
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex, address) {
        const account = this.assertAccountDefined(address, this.store.accounts.get(address));
        const assetHolding = account.getAssetHolding(assetIndex);
        if (assetHolding === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.ASA_NOT_OPTIN, {
                assetId: assetIndex,
                address: address
            });
        }
        return assetHolding;
    }
    // creates new application transaction object and update context
    addCtxAppCreateTxn(flags, payFlags) {
        const txn = algosdk_1.default.makeApplicationCreateTxn(flags.sender.addr, (0, tx_1.mockSuggestedParams)(payFlags, this.round), algosdk_1.default.OnApplicationComplete.NoOpOC, new Uint8Array(32), // mock approval program
        new Uint8Array(32), // mock clear progam
        flags.localInts, flags.localBytes, flags.globalInts, flags.globalBytes, web_1.parsing.parseAppArgs(flags.appArgs), flags.accounts, flags.foreignApps, flags.foreignAssets, flags.note, flags.lease, payFlags.rekeyTo);
        const encTx = { ...txn.get_obj_for_encoding(), txID: txn.txID() };
        this.ctx.tx = encTx;
        this.ctx.gtxs = [encTx];
    }
    /**
     * create new application and returns application id
     * @deprecated `deployApp` should be used instead.
     * @param approvalProgram application approval program
     * @param clearProgram application clear program
     * @param flags SSCDeployment flags
     * @param payFlags Transaction parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     * NOTE - approval and clear program must be the TEAL code as string (not compiled code)
     */
    addApp(approvalProgram, clearProgram, flags, payFlags, debugStack) {
        this.addCtxAppCreateTxn(flags, payFlags);
        this.ctx.debugStack = debugStack;
        const txReceipt = this.ctx.deployApp(flags.sender.addr, flags, approvalProgram, clearProgram, 0);
        this.store = this.ctx.state;
        return txReceipt;
    }
    /**
     * deploy a new application and returns application id
     * @param approvalProgram application approval program (TEAL code or program filename)
     * @param clearProgram application clear program (TEAL code or program filename)
     * @param flags SSCDeployment flags
     * @param payFlags Transaction parameters
     * @param scTmplParams Smart Contract template parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    deployApp(approvalProgram, clearProgram, flags, payFlags, scTmplParams, debugStack) {
        this.addCtxAppCreateTxn(flags, payFlags);
        this.ctx.debugStack = debugStack;
        const txReceipt = this.ctx.deployApp(flags.sender.addr, flags, approvalProgram, clearProgram, 0, scTmplParams);
        this.store = this.ctx.state;
        return txReceipt;
    }
    // creates new OptIn transaction object and update context
    addCtxOptInTx(senderAddr, appID, payFlags, flags) {
        const txn = algosdk_1.default.makeApplicationOptInTxn(senderAddr, (0, tx_1.mockSuggestedParams)(payFlags, this.round), appID, web_1.parsing.parseAppArgs(flags.appArgs), flags.accounts, flags.foreignApps, flags.foreignAssets, flags.note, flags.lease, payFlags.rekeyTo);
        const encTx = { ...txn.get_obj_for_encoding(), txID: txn.txID() };
        this.ctx.tx = encTx;
        this.ctx.gtxs = [encTx];
    }
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address
     * @param appID Application Id
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param payFlags Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    optInToApp(accountAddr, appID, flags, payFlags, debugStack) {
        this.addCtxOptInTx(accountAddr, appID, payFlags, flags);
        this.ctx.debugStack = debugStack;
        const txReceipt = this.ctx.optInToApp(accountAddr, appID, 0);
        this.store = this.ctx.state;
        return txReceipt;
    }
    // creates new Update transaction object and update context
    addCtxAppUpdateTx(senderAddr, appID, payFlags, flags) {
        const txn = algosdk_1.default.makeApplicationUpdateTxn(senderAddr, (0, tx_1.mockSuggestedParams)(payFlags, this.round), appID, new Uint8Array(32), // mock approval program
        new Uint8Array(32), // mock clear progam
        web_1.parsing.parseAppArgs(flags.appArgs), flags.accounts, flags.foreignApps, flags.foreignAssets, flags.note, flags.lease, payFlags.rekeyTo);
        const encTx = { ...txn.get_obj_for_encoding(), txID: txn.txID() };
        this.ctx.tx = encTx;
        this.ctx.gtxs = [encTx];
    }
    /**
     * Update application
     * @param senderAddr sender address
     * @param appID application Id
     * @param approvalProgram new approval program (TEAL code or program filename)
     * @param clearProgram new clear program (TEAL code or program filename)
     * @param payFlags Transaction parameters
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    updateApp(senderAddr, appID, approvalProgram, clearProgram, payFlags, flags, scTmplParams, debugStack) {
        this.addCtxAppUpdateTx(senderAddr, appID, payFlags, flags);
        this.ctx.debugStack = debugStack;
        const txReceipt = this.ctx.updateApp(appID, approvalProgram, clearProgram, 0, scTmplParams);
        // If successful, Update programs and state
        this.store = this.ctx.state;
        return txReceipt;
    }
    // verify 'amt' microalgos can be withdrawn from account
    assertMinBalance(amt, address) {
        const account = this.getAccount(address);
        if ((account.amount - amt) < account.minBalance) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_BALANCE, {
                amount: amt,
                address: address
            });
        }
    }
    /**
     * Validate signature for Algorand account on transaction params.
     * Include check spending account when creating a transaction from Algorand account
     * Throw RuntimeError if signature is invalid.
     * @param txParam transaction parameters.
     */
    validateAccountSignature(txParam) {
        const fromAccountAddr = web_1.tx.getFromAddress(txParam);
        const from = this.getAccount(fromAccountAddr);
        const signerAccount = txParam.fromAccount;
        if (signerAccount) {
            // if spend account of fromAccountAddr different with signerAccount
            // then throw error.
            if (from.getSpendAddress() !== signerAccount.addr) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_AUTH_ACCOUNT, {
                    spend: from.getSpendAddress(),
                    signer: signerAccount.addr
                });
            }
        }
        else {
            // throw error if your don't provide account `signature`.
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_SECRET_KEY);
        }
    }
    /**
     * Loads logic signature for contract mode, creates a new runtime account
     * associated with lsig
     * @param fileName ASC filename
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @param logs only show logs on console when set as true. By default this value is true
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    loadLogic(fileName, scTmplParams, logs = true) {
        const program = (0, index_1.getProgram)(fileName, scTmplParams, logs);
        return this.createLsigAccount(program, []); // args can be set during executeTx
    }
    /**
     * Creates a new account with logic signature and smart contract arguments
     * in the runtime store. The arguments are used when we send a transaction with this
     * account and verify it.
     * @param program TEAL code
     * @param args arguments passed
     * @returns logic signature with arguments.
     */
    createLsigAccount(program, args) {
        if (program === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_PROGRAM);
        }
        const lsig = new logicsig_1.LogicSigAccount(program, args);
        // create new lsig account in runtime
        const acc = new account_1.AccountStore(0, { addr: lsig.address(), sk: new Uint8Array(0) });
        this.store.accounts.set(acc.address, acc);
        return lsig;
    }
    /**
     * Transfers `amount` of microAlgos from `from` address to `to` address
     * @param from From account
     * @param to to address
     * @param amount amount of algo in microalgos
     */
    fundLsig(from, to, amount) {
        const fundParam = {
            type: web_1.types.TransactionType.TransferAlgo,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: from,
            toAccountAddr: to,
            amountMicroAlgos: amount,
            payFlags: { totalFee: 1000 }
        };
        return this.executeTx(fundParam);
    }
    /**
     * validate logic signature and teal logic
     * @param txnParam Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    validateLsigAndRun(txnParam, debugStack) {
        // check if transaction is signed by logic signature,
        // if yes verify signature and run logic
        if (txnParam.sign === web_1.types.SignType.LogicSignature && txnParam.lsig) {
            this.ctx.args = txnParam.args ?? txnParam.lsig.lsig.args;
            // signature validation
            const fromAccountAddr = web_1.tx.getFromAddress(txnParam);
            const lsigAccountAddr = txnParam.lsig.address();
            const signerAddr = (txnParam.lsig.isDelegated()) ? fromAccountAddr : lsigAccountAddr;
            const result = txnParam.lsig.lsig.verify((0, algosdk_1.decodeAddress)(signerAddr).publicKey);
            if (!result) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.LOGIC_SIGNATURE_VALIDATION_FAILED, { address: signerAddr });
            }
            // verify spend account
            const spendAddr = this.getAccount(fromAccountAddr).getSpendAddress();
            if (spendAddr !== signerAddr) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_AUTH_ACCOUNT, { spend: spendAddr, signer: signerAddr });
            }
            // logic validation
            const program = (0, parsing_1.convertToString)(txnParam.lsig.lsig.logic);
            if (program === "") {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_PROGRAM);
            }
            this.run(program, types_1.ExecutionMode.SIGNATURE, 0, debugStack);
            return this.ctx.state.txReceipts.get(this.ctx.tx.txID);
        }
        else {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.LOGIC_SIGNATURE_NOT_FOUND);
        }
    }
    /**
     * This function executes a transaction based on a smart
     * contract logic and updates state afterwards
     * @param txnParams : Transaction parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    executeTx(txnParams, debugStack) {
        const txnParameters = Array.isArray(txnParams) ? txnParams : [txnParams];
        for (const txn of txnParameters) {
            switch (txn.type) {
                case web_1.types.TransactionType.DeployASA: {
                    if (txn.asaDef === undefined)
                        txn.asaDef = this.loadedAssetsDefs[txn.asaName];
                    break;
                }
                case web_1.types.TransactionType.DeployApp: {
                    txn.approvalProg = new Uint8Array(32); // mock approval program
                    txn.clearProg = new Uint8Array(32); // mock clear program
                    break;
                }
            }
        }
        const [tx, gtxs] = this.createTxnContext(txnParameters); // get current txn and txn group (as encoded obj)
        // validate first and last rounds
        this.validateTxRound(gtxs);
        // initialize context before each execution
        // Prepare shared space at each execution of transaction/s.
        // state is a deep copy of store
        this.ctx = new ctx_1.Ctx((0, lodash_clonedeep_1.default)(this.store), tx, gtxs, [], this, debugStack);
        // Run TEAL program associated with each transaction and
        // then execute the transaction without interacting with store.
        const txReceipts = this.ctx.processTransactions(txnParameters);
        // update store only if all the transactions are passed
        this.store = this.ctx.state;
        // return transaction receipt(s)
        return Array.isArray(txnParams) ? txReceipts : txReceipts[0];
    }
    /**
     * This function executes TEAL code line by line
     * @param program : teal code as string
     * @param executionMode : execution Mode (Stateless or Stateful)
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     * NOTE: Application mode is only supported in TEALv > 1
     */
    run(program, executionMode, indexInGroup, debugStack) {
        const interpreter = new index_1.Interpreter();
        // set new tx receipt
        this.ctx.state.txReceipts.set(this.ctx.tx.txID, {
            txn: this.ctx.tx,
            txID: this.ctx.tx.txID
        });
        // reset pooled opcode cost for single tx, this is to handle singular functions
        // which don't "initialize" a new ctx (eg. deployApp)
        if (this.ctx.gtxs.length === 1) {
            this.ctx.pooledApplCost = 0;
        }
        interpreter.execute(program, executionMode, this, debugStack);
        if (executionMode === types_1.ExecutionMode.APPLICATION) {
            this.ctx.sharedScratchSpace.set(indexInGroup, interpreter.scratch);
        }
        return this.ctx.state.txReceipts.get(this.ctx.tx.txID);
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=runtime.js.map