"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogicSigAccount = exports.LogicSig = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const murmurhash = __importStar(require("murmurhash"));
const tweet = __importStar(require("tweetnacl-ts"));
const errors_list_1 = require("./errors/errors-list");
const runtime_errors_1 = require("./errors/runtime-errors");
const compare_1 = require("./lib/compare");
const parsing_1 = require("./lib/parsing");
/**
 * Note: We cannot use algosdk LogicSig class here,
 * because algosdk.makeLogicSig() takes compiled bytes as a argument
 * and currently we don't calculate compiled bytes from TEAL program.
 * We are using raw TEAL code as program.(by converting string into bytes)
 */
class LogicSig {
    constructor(program, programArgs) {
        this.tag = Buffer.from("Program");
        this.logic = web_1.parsing.stringToBytes(program);
        const seedBytes = web_1.parsing.uint64ToBigEndian(murmurhash.v3(program));
        const extendedSeed = new Uint8Array(Number(seedBytes.length) + Number(24));
        extendedSeed.set(seedBytes);
        const pair = tweet.sign_keyPair_fromSeed(extendedSeed);
        this.lsigAddress = (0, algosdk_1.encodeAddress)(pair.publicKey);
        this.tag = Buffer.from('Program');
        if (programArgs &&
            (!Array.isArray(programArgs) ||
                !programArgs.every((arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {
            throw new TypeError('Invalid arguments');
        }
        let args;
        if (programArgs != null) {
            args = programArgs.map((arg) => new Uint8Array(arg));
        }
        else
            args = [];
        this.args = args;
    }
    /**
     * Creates signature (if no msig provided) or multi signature otherwise
     * @param secretKey sender's secret key
     * @param msig multisignature if it exists
     */
    sign(secretKey, msig) {
        if (msig === undefined) {
            this.sig = this.signProgram(secretKey);
        }
        else {
            const subsigs = msig.addrs.map(addr => {
                return {
                    pk: (0, algosdk_1.decodeAddress)(addr).publicKey,
                    s: new Uint8Array(0)
                };
            });
            this.msig = {
                v: msig.version,
                thr: msig.threshold,
                subsig: subsigs
            };
            const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
            this.msig.subsig[index].s = sig;
        }
    }
    /**
     * Sign Multisignature
     * @param secretKey Secret key to sign with
     * @param msig Multisignature
     */
    singleSignMultisig(secretKey, msig) {
        let index = -1;
        const accountPk = tweet.sign_keyPair_fromSecretKey(secretKey).publicKey;
        for (let i = 0; i < msig.subsig.length; i++) {
            const pk = msig.subsig[i].pk;
            if ((0, compare_1.compareArray)(pk, accountPk)) {
                index = i;
                break;
            }
        }
        if (index === -1) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_SECRET_KEY, { secretkey: secretKey });
        }
        const sig = this.signProgram(secretKey);
        return [sig, index];
    }
    /**
     * Appends a signature to multi signature
     * @param {Uint8Array} secretKey Secret key to sign with
     */
    appendToMultisig(secretKey) {
        if (this.msig === undefined) {
            throw new Error("no multisig present");
        }
        const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
        this.msig.subsig[index].s = sig;
    }
    /**
     * Performs signature verification
     * @param accAddr Sender's account address
     */
    verify(accPk) {
        const accAddr = (0, algosdk_1.encodeAddress)(accPk);
        if (!this.sig && !this.msig) {
            if (accAddr === this.lsigAddress)
                return true;
            return false;
        }
        if (this.sig) {
            return (0, algosdk_1.verifyBytes)(this.logic, this.sig, accAddr);
        }
        if (this.msig) {
            return this.verifyMultisig(this.msig, accAddr);
        }
        return false;
    }
    /**
     * Verify multi-signature
     * @param msig Msig
     * @param accAddr Sender's account address
     */
    verifyMultisig(msig, accAddr) {
        const version = msig.v;
        const threshold = msig.thr;
        const subsigs = msig.subsig;
        const addrs = subsigs.map((subsig) => (0, algosdk_1.encodeAddress)(subsig.pk));
        if (msig.subsig.length < threshold) {
            return false;
        }
        let multiSigaddr;
        try {
            const mparams = {
                version: version,
                threshold: threshold,
                addrs: addrs
            };
            multiSigaddr = (0, algosdk_1.multisigAddress)(mparams);
        }
        catch (e) {
            return false;
        }
        if (accAddr !== multiSigaddr) {
            return false;
        }
        let counter = 0;
        for (const subsig of subsigs) {
            if (!(0, compare_1.compareArray)(subsig.s, new Uint8Array(0))) {
                counter += 1;
            }
        }
        if (counter < threshold) {
            return false;
        }
        let verifiedCounter = 0;
        for (const subsig of subsigs) {
            const subsigAddr = (0, algosdk_1.encodeAddress)(subsig.pk);
            if (!(0, compare_1.compareArray)(subsig.s, new Uint8Array(0)) &&
                (0, algosdk_1.verifyBytes)(this.logic, subsig.s, subsigAddr)) {
                verifiedCounter += 1;
            }
        }
        if (verifiedCounter < threshold) {
            return false;
        }
        return true;
    }
    /**
     * Returns signed logic
     * @param secretKey: account's secret key
     */
    signProgram(secretKey) {
        return (0, algosdk_1.signBytes)(this.logic, secretKey);
    }
    /**
     * Returns logic signature address
     */
    address() {
        return this.lsigAddress;
    }
    /**
     * Returns program associated with logic signature
     */
    program() {
        return (0, parsing_1.convertToString)(this.logic);
    }
    /**
     * Note: following functions are dummy functions
     * they are used only to match type with algosdk LogicSig
     * there is a possibility that we may use them in future.
     */
    toByte() {
        return this.logic;
    }
    fromByte(val) {
        return new LogicSig("DUMMY", []);
    }
    get_obj_for_encoding() {
        return {
            l: this.logic,
            arg: this.args,
            sig: this.sig,
            msig: this.msig
        };
    }
    static from_obj_for_encoding(lsig) {
        return new LogicSig("DUMMY", []);
    }
}
exports.LogicSig = LogicSig;
class LogicSigAccount {
    /**
     * Create a new LogicSigAccount. By default this will create an escrow
     * LogicSig account. Call `sign` or `signMultisig` on the newly created
     * LogicSigAccount to make it a delegated account.
     *
     * @param program - program in TEAL file
     * @param args - An optional array of arguments for the program.
     */
    constructor(program, programArgs) {
        this.lsig = new LogicSig(program, programArgs);
        this.sigkey = undefined;
    }
    /**
     * Note: following functions are dummy functions
     * they are used only to match type with algosdk LogicSigAccount
     * there is a possibility that we may use them in future.
     */
    // eslint-disable-next-line camelcase
    get_obj_for_encoding() {
        return {
            lsig: this.lsig.get_obj_for_encoding(),
            sigkey: this.sigkey
        };
    }
    // eslint-disable-next-line camelcase
    static from_obj_for_encoding(encoded) {
        const lsigAccount = new LogicSigAccount("DUMMY", encoded.lsig.arg);
        lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
        lsigAccount.sigkey = encoded.sigkey;
        return lsigAccount;
    }
    toByte() {
        return this.lsig.toByte();
    }
    static fromByte(encoded) {
        return new LogicSigAccount("DUMMY", []);
    }
    /**
     * Check if this LogicSigAccount has been delegated to another account with a
     * signature.
     *
     * Note this function only checks for the presence of a delegation signature.
     * To verify the delegation signature, use `verify`.
     */
    isDelegated() {
        return !!(this.lsig.sig ?? this.lsig.msig);
    }
    /**
     * Verifies this LogicSig's program and signatures.
     * @returns true if and only if the LogicSig program and signatures are valid.
     */
    verify() {
        const addr = this.address();
        return this.lsig.verify((0, algosdk_1.decodeAddress)(addr).publicKey);
    }
    /**
     * Get the address of this LogicSigAccount.
     *
     * If the LogicSig is delegated to another account, this will return the
     * address of that account.
     *
     * If the LogicSig is not delegated to another account, this will return an
     *  escrow address that is the hash of the LogicSig's program code.
     */
    address() {
        if (this.lsig.sig && this.lsig.msig) {
            throw new Error('LogicSig has too many signatures. At most one of sig or msig may be present');
        }
        if (this.lsig.sig) {
            if (!this.sigkey) {
                throw new Error('Signing key for delegated account is missing');
            }
            return (0, algosdk_1.encodeAddress)(this.sigkey);
        }
        return this.lsig.address();
    }
    /**
     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
     * has the authority to sign transactions on behalf of another account, called
     * the delegating account. Use this function if the delegating account is a
     * multisig account.
     *
     * @param msig - The multisig delegating account
     * @param secretKey - The secret key of one of the members of the delegating
     *   multisig account. Use `appendToMultisig` to add additional signatures
     *   from other members.
     */
    signMultisig(msig, secretKey) {
        this.lsig.sign(secretKey, msig);
    }
    /**
     * Adds an additional signature from a member of the delegating multisig
     * account.
     *
     * @param secretKey - The secret key of one of the members of the delegating
     *   multisig account.
     */
    appendToMultisig(secretKey) {
        this.lsig.appendToMultisig(secretKey);
    }
    /**
     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
     * has the authority to sign transactions on behalf of another account, called
     * the delegating account. If the delegating account is a multisig account,
     * use `signMultisig` instead.
     *
     * @param secretKey - The secret key of the delegating account.
     */
    sign(secretKey) {
        this.lsig.sign(secretKey);
        this.sigkey = tweet.sign_keyPair_fromSecretKey(secretKey).publicKey;
    }
}
exports.LogicSigAccount = LogicSigAccount;
//# sourceMappingURL=logicsig.js.map