"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Op = void 0;
/* eslint sonarjs/no-identical-functions: 0 */
const algosdk_1 = require("algosdk");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
class Op {
    /**
     * assert stack length is atleast minLen
     * @param stack TEAL stack
     * @param minLen length to check from
     * @param line line number in TEAL file
     */
    assertMinStackLen(stack, minLen, line) {
        if (stack.length() < minLen) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ASSERT_STACK_LENGTH, { line: line });
        }
    }
    /**
     * asserts number is less than or equal to value(MAX_UINT64, MAX_UINT128)
     * @param num number to check
     * @param line line number in TEAL file
     * @param value max value
     */
    checkOverflow(num, line, value) {
        switch (value) {
            case constants_1.MAX_UINT64: {
                if (num > constants_1.MAX_UINT64) {
                    throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UINT64_OVERFLOW, { line: line });
                }
                break;
            }
            case constants_1.MAX_UINT128: {
                if (num > constants_1.MAX_UINT128) {
                    throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UINT128_OVERFLOW, { line: line });
                }
                break;
            }
        }
    }
    /**
     * asserts number is greater than MIN_UINT64 (0n)
     * @param num number to check
     * @param line line number in TEAL file
     */
    checkUnderflow(num, line) {
        if (num < constants_1.MIN_UINT64) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UINT64_UNDERFLOW, { line: line });
        }
    }
    /**
     * asserts if index exist in given array
     * @param idx index number
     * @param arr array to check from
     * @param line line number in TEAL file
     */
    checkIndexBound(idx, arr, line) {
        if (!(idx >= 0 && idx < arr.length)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INDEX_OUT_OF_BOUND, { line: line });
        }
    }
    /**
     * asserts if array length is less than equal to MAX_UINT8 (255) and not equal to 0
     * @param arr array
     * @param line line number in TEAL file
     */
    assertArrLength(arr, line) {
        if (!arr.length || arr.length > constants_1.MAX_UINT8 + 1) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ASSERT_ARR_LENGTH, { line: line });
        }
    }
    /**
     * asserts if given variable type is bigint
     * @param a variable
     * @param line line number in TEAL file
     */
    assertBigInt(a, line) {
        if (typeof a === "undefined" || typeof a !== "bigint") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: "uint64",
                actual: typeof a,
                line: line
            });
        }
        return a;
    }
    assertUInt8(a, line) {
        if (typeof a === "undefined" || typeof a !== "bigint") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: "uint64",
                actual: typeof a,
                line: line
            });
        }
        if (a >= 2 << 7) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: "uint8 {0..255}",
                actual: a,
                line: line
            });
        }
        return Number(a);
    }
    /**
     * asserts if given variable type is bytes
     * @param b variable
     * @param line line number in TEAL file
     * @param maxlen maximum allowed length of bytes
     */
    assertBytes(b, line, maxlen) {
        if (typeof b === 'undefined' || !(b instanceof Uint8Array)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: "byte[]",
                actual: typeof b,
                line: line
            });
        }
        if (maxlen !== undefined && b.length > maxlen) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.BYTES_LEN_EXCEEDED, {
                len: b.length,
                expected: maxlen,
                line: line
            });
        }
        return b;
    }
    /**
     * asserts if given variable type is address
     * @param a - value to assert (should in bytes)
     * @param line - line number in TEAL file
     */
    assertAlgorandAddress(a, line) {
        const bytes = this.assertBytes(a, line);
        const addr = (0, algosdk_1.encodeAddress)(bytes);
        if (!(0, algosdk_1.isValidAddress)(addr)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_ADDR, { addr: a, line: line });
        }
        return bytes;
    }
    /**
     * asserts if given bigint is an 8 bit unsigned integer
     * @param a  value to assert (in bigint)
     * @param line line number in TEAL file
     */
    assertUint8(a, line) {
        if (a < constants_1.MIN_UINT8 || a > constants_1.MAX_UINT8) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_UINT8, { line: line });
        }
        return a;
    }
    /**
     * asserts if given index lies in 64 bit unsigned integer
     * @param index Index
     * @param line line number in TEAL file
     */
    assert64BitIndex(index, line) {
        if (index > constants_1.MAX_UINT6) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SET_BIT_INDEX_ERROR, { index: index, line: line });
        }
    }
    /**
     * asserts if given index lies in bytes array
     * @param index Index
     * @param array bytes array
     * @param line line number in TEAL file
     */
    assertBytesIndex(index, array, line) {
        if (index >= array.length) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SET_BIT_INDEX_BYTES_ERROR, { index: index, line: line });
        }
    }
    /**
     * Returns substring from given string (if it exists)
     * @param byteString given string as bytes
     * @param start starting index
     * @param end ending index
     * @param line line number in TEAL file
     */
    subString(byteString, start, end, line) {
        if (end < start) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SUBSTRING_END_BEFORE_START, { line: line });
        }
        if (start > byteString.length || end > byteString.length) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SUBSTRING_RANGE_BEYOND, { line: line });
        }
        return byteString.slice(Number(start), Number(end));
    }
    /**
     * asserts if known transaction field is passed
     * @param str transaction field
     * @param tealVersion version of TEAL
     * @param line line number in TEAL file
     */
    assertTxFieldDefined(str, tealVersion, line) {
        if (constants_1.TxnFields[tealVersion][str] === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_TRANSACTION_FIELD, { field: str, version: tealVersion, line: line });
        }
    }
    /**
     * asserts if known transaction field of type array is passed
     * @param str transaction field
     * @param tealVersion version of TEAL
     * @param line line number in TEAL file
     */
    assertTxArrFieldDefined(str, tealVersion, line) {
        if (!constants_1.TxArrFields[tealVersion].has(str)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_OP_ARG, { opcode: str, version: tealVersion, line: line });
        }
    }
    /**
     * asserts if known itxn field is passed
     * @param str itxn field
     * @param tealVersion version of TEAL
     * @param line line number in TEAL file
     */
    assertITxFieldDefined(str, tealVersion, line) {
        if (constants_1.TxnFields[tealVersion][str] === undefined && constants_1.ITxnFields[tealVersion][str] === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_TRANSACTION_FIELD, { field: str, version: tealVersion, line: line });
        }
    }
    /**
     * asserts if known itxn field of type array is passed
     * @param str itxn field
     * @param tealVersion version of TEAL
     * @param line line number in TEAL file
     */
    assertITxArrFieldDefined(str, tealVersion, line) {
        if (!constants_1.TxArrFields[tealVersion].has(str) && !constants_1.ITxArrFields[tealVersion].has(str)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_OP_ARG, { opcode: str, version: tealVersion, line: line });
        }
    }
    /**
     * asserts if known global field is passed
     * @param str global field
     * @param tealVersion version of TEAL
     * @param line line number in TEAL file
     */
    assertGlobalDefined(str, tealVersion, line) {
        if (constants_1.GlobalFields[tealVersion][str] === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_GLOBAL_FIELD, { field: str, version: tealVersion, line: line });
        }
    }
    /**
     * Push 1n if boolean is true else push 0n. Returns TEAL stack
     * @param stack TEAL stack
     * @param ok boolean
     */
    pushBooleanCheck(stack, ok) {
        if (ok) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
        return stack;
    }
    /**
     * Returns range of bytes from A starting at S up to but not including S+L,
     * If S or S+L is larger than the array length, throw error
     * @param array Uint8array
     * @param start starting point in array
     * @param length length of substring
     */
    opExtractImpl(array, start, length) {
        const end = start + length;
        if (start > array.length) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.EXTRACT_RANGE_ERROR, { given: start, length: array.length });
        }
        if (end > array.length) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.EXTRACT_RANGE_ERROR, { given: end, length: array.length });
        }
        return array.slice(start, end);
    }
}
exports.Op = Op;
//# sourceMappingURL=opcode.js.map