"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchIfZero = exports.Branchv4 = exports.Branch = exports.Label = exports.Gtxna = exports.Txna = exports.Gtxn = exports.Txn = exports.Substring3 = exports.Substring = exports.Concat = exports.Dup2 = exports.Dup = exports.Pop = exports.Mulw = exports.Addw = exports.Btoi = exports.Itob = exports.Not = exports.NotEqualTo = exports.EqualTo = exports.Or = exports.And = exports.GreaterThanEqualTo = exports.LessThanEqualTo = exports.GreaterThan = exports.LessThan = exports.Ed25519verify = exports.Keccak256 = exports.Sha512_256 = exports.Sha256 = exports.Err = exports.Load = exports.Store = exports.BitwiseNot = exports.BitwiseXor = exports.BitwiseAnd = exports.BitwiseOr = exports.Mod = exports.Intc = exports.Intcblock = exports.Bytec = exports.Bytecblock = exports.Arg = exports.Mul = exports.Div = exports.Sub = exports.Add = exports.Len = exports.Pragma = void 0;
exports.ByteBitwiseOr = exports.ByteNotEqualTo = exports.ByteEqualTo = exports.ByteLessThanEqualTo = exports.ByteGreaterThanEqualTo = exports.ByteLessThan = exports.ByteGreatorThan = exports.ByteMod = exports.ByteDiv = exports.ByteMul = exports.ByteSub = exports.ByteAdd = exports.ByteOp = exports.Retsub = exports.Callsub = exports.Gloads = exports.Gload = exports.MinBalance = exports.Gtxnsa = exports.Gtxns = exports.Select = exports.Dig = exports.GetByte = exports.SetByte = exports.GetBit = exports.SetBit = exports.Swap = exports.PushBytes = exports.PushInt = exports.Assert = exports.Addr = exports.Byte = exports.Int = exports.GetAssetDef = exports.GetAssetHolding = exports.Balance = exports.AppGlobalDel = exports.AppLocalDel = exports.AppGlobalPut = exports.AppLocalPut = exports.AppGlobalGetEx = exports.AppGlobalGet = exports.AppLocalGetEx = exports.AppLocalGet = exports.AppOptedIn = exports.Global = exports.Return = exports.BranchIfNotZerov4 = exports.BranchIfNotZero = exports.BranchIfZerov4 = void 0;
exports.AppParamsGet = exports.BitLen = exports.Log = exports.Args = exports.Gtxnsas = exports.Gtxnas = exports.Txnas = exports.ITxna = exports.ITxn = exports.ITxnSubmit = exports.ITxnField = exports.ITxnBegin = exports.Stores = exports.Loads = exports.Uncover = exports.Cover = exports.EcdsaPkRecover = exports.EcdsaPkDecompress = exports.EcdsaVerify = exports.ExtractUint64 = exports.ExtractUint32 = exports.ExtractUint16 = exports.Extract3 = exports.Extract = exports.Gaids = exports.Gaid = exports.Sqrt = exports.Shr = exports.Shl = exports.Expw = exports.Exp = exports.DivModw = exports.ByteZero = exports.ByteBitwiseInvert = exports.ByteBitwiseXor = exports.ByteBitwiseAnd = void 0;
/* eslint sonarjs/no-identical-functions: 0 */
/* eslint sonarjs/no-duplicate-string: 0 */
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const elliptic_1 = require("elliptic");
const js_sha256_1 = require("js-sha256");
const js_sha512_1 = require("js-sha512");
const sha3_1 = require("sha3");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const compare_1 = require("../lib/compare");
const constants_1 = require("../lib/constants");
const itxn_1 = require("../lib/itxn");
const parsing_1 = require("../lib/parsing");
const stack_1 = require("../lib/stack");
const txn_1 = require("../lib/txn");
const types_1 = require("../types");
const opcode_1 = require("./opcode");
// Opcodes reference link: https://developer.algorand.org/docs/reference/teal/opcodes/
// Store TEAL version
// push to stack [...stack]
class Pragma extends opcode_1.Op {
    /**
     * Store Pragma version
     * @param args Expected arguments: ["version", version number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, line);
        if (this.line > 1) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.PRAGMA_NOT_AT_FIRST_LINE, { line: line });
        }
        if (args[0] === "version" && Number(args[1]) <= constants_1.MaxTEALVersion) {
            this.version = Number(args[1]);
            interpreter.tealVersion = this.version;
        }
        else {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.PRAGMA_VERSION_ERROR, {
                expected: 'till #4',
                got: args.join(' '),
                line: line
            });
        }
    }
    // Returns Pragma version
    getVersion() {
        return this.version;
    }
    execute(stack) { }
}
exports.Pragma = Pragma;
// pops string([]byte) from stack and pushes it's length to stack
// push to stack [...stack, bigint]
class Len extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBytes(stack.pop(), this.line);
        stack.push(BigInt(last.length));
    }
}
exports.Len = Len;
// pops two unit64 from stack(last, prev) and pushes their sum(last + prev) to stack
// panics on overflow (result > max_unit64)
// push to stack [...stack, bigint]
class Add extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        const result = prev + last;
        this.checkOverflow(result, this.line, constants_1.MAX_UINT64);
        stack.push(result);
    }
}
exports.Add = Add;
// pops two unit64 from stack(last, prev) and pushes their diff(last - prev) to stack
// panics on underflow (result < 0)
// push to stack [...stack, bigint]
class Sub extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        const result = prev - last;
        this.checkUnderflow(result, this.line);
        stack.push(result);
    }
}
exports.Sub = Sub;
// pops two unit64 from stack(last, prev) and pushes their division(last / prev) to stack
// panics if prev == 0
// push to stack [...stack, bigint]
class Div extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (last === 0n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ZERO_DIV, { line: this.line });
        }
        stack.push(prev / last);
    }
}
exports.Div = Div;
// pops two unit64 from stack(last, prev) and pushes their mult(last * prev) to stack
// panics on overflow (result > max_unit64)
// push to stack [...stack, bigint]
class Mul extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        const result = prev * last;
        this.checkOverflow(result, this.line, constants_1.MAX_UINT64);
        stack.push(result);
    }
}
exports.Mul = Mul;
// pushes argument[N] from argument array to stack
// push to stack [...stack, bytes]
class Arg extends opcode_1.Op {
    /**
     * Gets the argument value from interpreter.args array.
     * store the value in _arg variable
     * @param args Expected arguments: [argument number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        (0, parsing_1.assertOnlyDigits)(args[0], this.line);
        this.index = Number(args[0]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.checkIndexBound(this.index, this.interpreter.runtime.ctx.args, this.line);
        const argN = this.assertBytes(this.interpreter.runtime.ctx.args?.[this.index], this.line);
        stack.push(argN);
    }
}
exports.Arg = Arg;
// load block of byte-array constants
// push to stack [...stack]
class Bytecblock extends opcode_1.Op {
    /**
     * Store blocks of bytes in bytecblock
     * @param args Expected arguments: [bytecblock] // Ex: ["value1" "value2"]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        const bytecblock = [];
        for (const val of args) {
            bytecblock.push(web_1.parsing.stringToBytes(val));
        }
        this.interpreter = interpreter;
        this.bytecblock = bytecblock;
    }
    execute(stack) {
        this.assertArrLength(this.bytecblock, this.line);
        this.interpreter.bytecblock = this.bytecblock;
    }
}
exports.Bytecblock = Bytecblock;
// push bytes constant from bytecblock to stack by index
// push to stack [...stack, bytes]
class Bytec extends opcode_1.Op {
    /**
     * Sets index according to arguments passed
     * @param args Expected arguments: [byteblock index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.index = Number(args[0]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.checkIndexBound(this.index, this.interpreter.bytecblock, this.line);
        const bytec = this.assertBytes(this.interpreter.bytecblock[this.index], this.line);
        stack.push(bytec);
    }
}
exports.Bytec = Bytec;
// load block of uint64 constants
// push to stack [...stack]
class Intcblock extends opcode_1.Op {
    /**
     * Stores block of integer in intcblock
     * @param args Expected arguments: [integer block] // Ex: [100 200]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        const intcblock = [];
        for (const val of args) {
            (0, parsing_1.assertOnlyDigits)(val, this.line);
            intcblock.push(BigInt(val));
        }
        this.interpreter = interpreter;
        this.intcblock = intcblock;
    }
    execute(stack) {
        this.assertArrLength(this.intcblock, this.line);
        this.interpreter.intcblock = this.intcblock;
    }
}
exports.Intcblock = Intcblock;
// push value from uint64 intcblock to stack by index
// push to stack [...stack, bigint]
class Intc extends opcode_1.Op {
    /**
     * Sets index according to arguments passed
     * @param args Expected arguments: [intcblock index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.index = Number(args[0]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.checkIndexBound(this.index, this.interpreter.intcblock, this.line);
        const intc = this.assertBigInt(this.interpreter.intcblock[this.index], this.line);
        stack.push(intc);
    }
}
exports.Intc = Intc;
// pops two unit64 from stack(last, prev) and pushes their modulo(last % prev) to stack
// Panic if B == 0.
// push to stack [...stack, bigint]
class Mod extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (last === 0n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ZERO_DIV, { line: this.line });
        }
        stack.push(prev % last);
    }
}
exports.Mod = Mod;
// pops two unit64 from stack(last, prev) and pushes their bitwise-or(last | prev) to stack
// push to stack [...stack, bigint]
class BitwiseOr extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        stack.push(prev | last);
    }
}
exports.BitwiseOr = BitwiseOr;
// pops two unit64 from stack(last, prev) and pushes their bitwise-and(last & prev) to stack
// push to stack[...stack, bigint]
class BitwiseAnd extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        stack.push(prev & last);
    }
}
exports.BitwiseAnd = BitwiseAnd;
// pops two unit64 from stack(last, prev) and pushes their bitwise-xor(last ^ prev) to stack
// push to stack [...stack, bigint]
class BitwiseXor extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        stack.push(prev ^ last);
    }
}
exports.BitwiseXor = BitwiseXor;
// pop unit64 from stack and push it's bitwise-invert(~last) to stack
// push to stack [...stack, bigint]
class BitwiseNot extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        stack.push(~last);
    }
}
exports.BitwiseNot = BitwiseNot;
// pop last value from the stack and store to scratch space
// push to stack [...stack]
class Store extends opcode_1.Op {
    /**
     * Stores index number according to arguments passed
     * @param args Expected arguments: [index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, this.line);
        (0, parsing_1.assertOnlyDigits)(args[0], this.line);
        this.index = Number(args[0]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.checkIndexBound(this.index, this.interpreter.scratch, this.line);
        this.assertMinStackLen(stack, 1, this.line);
        const top = stack.pop();
        this.interpreter.scratch[this.index] = top;
    }
}
exports.Store = Store;
// copy ith value from scratch space to the stack
// push to stack [...stack, bigint/bytes]
class Load extends opcode_1.Op {
    /**
     * Stores index number according to arguments passed.
     * @param args Expected arguments: [index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, this.line);
        (0, parsing_1.assertOnlyDigits)(args[0], this.line);
        this.index = Number(args[0]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.checkIndexBound(this.index, this.interpreter.scratch, this.line);
        stack.push(this.interpreter.scratch[this.index]);
    }
}
exports.Load = Load;
// err opcode : Error. Panic immediately.
// push to stack [...stack]
class Err extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.TEAL_ENCOUNTERED_ERR, { line: this.line });
    }
}
exports.Err = Err;
// SHA256 hash of value X, yields [32]byte
// push to stack [...stack, bytes]
class Sha256 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const hash = js_sha256_1.sha256.create();
        const val = this.assertBytes(stack.pop(), this.line);
        hash.update(val);
        const hashedOutput = Buffer.from(hash.hex(), 'hex');
        const arrByte = Uint8Array.from(hashedOutput);
        stack.push(arrByte);
    }
}
exports.Sha256 = Sha256;
// SHA512_256 hash of value X, yields [32]byte
// push to stack [...stack, bytes]
class Sha512_256 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const hash = js_sha512_1.sha512_256.create();
        const val = this.assertBytes(stack.pop(), this.line);
        hash.update(val);
        const hashedOutput = Buffer.from(hash.hex(), 'hex');
        const arrByte = Uint8Array.from(hashedOutput);
        stack.push(arrByte);
    }
}
exports.Sha512_256 = Sha512_256;
// Keccak256 hash of value X, yields [32]byte
// https://github.com/phusion/node-sha3#example-2
// push to stack [...stack, bytes]
class Keccak256 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBytes(stack.pop(), this.line);
        const hash = new sha3_1.Keccak(256);
        hash.update((0, parsing_1.convertToString)(top));
        const arrByte = Uint8Array.from(hash.digest());
        stack.push(arrByte);
    }
}
exports.Keccak256 = Keccak256;
// for (data A, signature B, pubkey C) verify the signature of
// ("ProgData" || program_hash || data) against the pubkey => {0 or 1}
// push to stack [...stack, bigint]
class Ed25519verify extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const pubkey = this.assertBytes(stack.pop(), this.line);
        const signature = this.assertBytes(stack.pop(), this.line);
        const data = this.assertBytes(stack.pop(), this.line);
        const addr = (0, algosdk_1.encodeAddress)(pubkey);
        const isValid = (0, algosdk_1.verifyBytes)(data, signature, addr);
        if (isValid) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.Ed25519verify = Ed25519verify;
// If A < B pushes '1' else '0'
// push to stack [...stack, bigint]
class LessThan extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (prev < last) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.LessThan = LessThan;
// If A > B pushes '1' else '0'
// push to stack [...stack, bigint]
class GreaterThan extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (prev > last) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.GreaterThan = GreaterThan;
// If A <= B pushes '1' else '0'
// push to stack [...stack, bigint]
class LessThanEqualTo extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (prev <= last) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.LessThanEqualTo = LessThanEqualTo;
// If A >= B pushes '1' else '0'
// push to stack [...stack, bigint]
class GreaterThanEqualTo extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (prev >= last) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.GreaterThanEqualTo = GreaterThanEqualTo;
// If A && B is true pushes '1' else '0'
// push to stack [...stack, bigint]
class And extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (last && prev) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.And = And;
// If A || B is true pushes '1' else '0'
// push to stack [...stack, bigint]
class Or extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        const prev = this.assertBigInt(stack.pop(), this.line);
        if (prev || last) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.Or = Or;
// If A == B pushes '1' else '0'
// push to stack [...stack, bigint]
class EqualTo extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = stack.pop();
        const prev = stack.pop();
        if (typeof last !== typeof prev) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: typeof prev,
                actual: typeof last,
                line: this.line
            });
        }
        if (typeof last === "bigint") {
            stack = this.pushBooleanCheck(stack, (last === prev));
        }
        else {
            stack = this.pushBooleanCheck(stack, (0, compare_1.compareArray)(this.assertBytes(last, this.line), this.assertBytes(prev, this.line)));
        }
    }
}
exports.EqualTo = EqualTo;
// If A != B pushes '1' else '0'
// push to stack [...stack, bigint]
class NotEqualTo extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const last = stack.pop();
        const prev = stack.pop();
        if (typeof last !== typeof prev) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_TYPE, {
                expected: typeof prev,
                actual: typeof last,
                line: this.line
            });
        }
        if (typeof last === "bigint") {
            stack = this.pushBooleanCheck(stack, last !== prev);
        }
        else {
            stack = this.pushBooleanCheck(stack, !(0, compare_1.compareArray)(this.assertBytes(last, this.line), this.assertBytes(prev, this.line)));
        }
    }
}
exports.NotEqualTo = NotEqualTo;
// X == 0 yields 1; else 0
// push to stack [...stack, bigint]
class Not extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        if (last === 0n) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.Not = Not;
// converts uint64 X to big endian bytes
// push to stack [...stack, big endian bytes]
class Itob extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const uint64 = this.assertBigInt(stack.pop(), this.line);
        stack.push((0, algosdk_1.encodeUint64)(uint64));
    }
}
exports.Itob = Itob;
// converts bytes X as big endian to uint64
// btoi panics if the input is longer than 8 bytes.
// push to stack [...stack, bigint]
class Btoi extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const bytes = this.assertBytes(stack.pop(), this.line);
        const uint64 = (0, algosdk_1.decodeUint64)(bytes, types_1.DecodingMode.BIGINT);
        stack.push(uint64);
    }
}
exports.Btoi = Btoi;
// A plus B out to 128-bit long result as sum (top) and carry-bit uint64 values on the stack
// push to stack [...stack, bigint]
class Addw extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const valueA = this.assertBigInt(stack.pop(), this.line);
        const valueB = this.assertBigInt(stack.pop(), this.line);
        let valueC = valueA + valueB;
        if (valueC > constants_1.MAX_UINT64) {
            valueC -= constants_1.MAX_UINT64;
            stack.push(1n);
            stack.push(valueC - 1n);
        }
        else {
            stack.push(0n);
            stack.push(valueC);
        }
    }
}
exports.Addw = Addw;
// A times B out to 128-bit long result as low (top) and high uint64 values on the stack
// push to stack [...stack, bigint]
class Mulw extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const valueA = this.assertBigInt(stack.pop(), this.line);
        const valueB = this.assertBigInt(stack.pop(), this.line);
        const result = valueA * valueB;
        const low = result & constants_1.MAX_UINT64;
        this.checkOverflow(low, this.line, constants_1.MAX_UINT64);
        const high = result >> BigInt('64');
        this.checkOverflow(high, this.line, constants_1.MAX_UINT64);
        stack.push(high);
        stack.push(low);
    }
}
exports.Mulw = Mulw;
// Pop one element from stack
// [...stack] // pop value.
class Pop extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        stack.pop();
    }
}
exports.Pop = Pop;
// duplicate last value on stack
// push to stack [...stack, duplicate value]
class Dup extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const lastValue = stack.pop();
        stack.push(lastValue);
        stack.push(lastValue);
    }
}
exports.Dup = Dup;
// duplicate two last values on stack: A, B -> A, B, A, B
// push to stack [...stack, B, A, B, A]
class Dup2 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const lastValueA = stack.pop();
        const lastValueB = stack.pop();
        stack.push(lastValueB);
        stack.push(lastValueA);
        stack.push(lastValueB);
        stack.push(lastValueA);
    }
}
exports.Dup2 = Dup2;
// pop two byte strings A and B and join them, push the result
// concat panics if the result would be greater than 4096 bytes.
// push to stack [...stack, string]
class Concat extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const valueA = this.assertBytes(stack.pop(), this.line);
        const valueB = this.assertBytes(stack.pop(), this.line);
        if (valueA.length + valueB.length > constants_1.MAX_CONCAT_SIZE) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.CONCAT_ERROR, { line: this.line });
        }
        const c = new Uint8Array(valueB.length + valueA.length);
        c.set(valueB);
        c.set(valueA, valueB.length);
        stack.push(c);
    }
}
exports.Concat = Concat;
// pop last byte string X. For immediate values in 0..255 M and N:
// extract last range of bytes from it starting at M up to but not including N,
// push the substring result. If N < M, or either is larger than the string length,
// the program fails
// push to stack [...stack, substring]
class Substring extends opcode_1.Op {
    /**
     * Stores values of `start` and `end` according to arguments passed.
     * @param args Expected arguments: [start index number, end index number]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, line);
        (0, parsing_1.assertOnlyDigits)(args[0], line);
        (0, parsing_1.assertOnlyDigits)(args[1], line);
        this.start = BigInt(args[0]);
        this.end = BigInt(args[1]);
    }
    ;
    execute(stack) {
        const end = this.assertUint8(this.end, this.line);
        const start = this.assertUint8(this.start, this.line);
        const byteString = this.assertBytes(stack.pop(), this.line);
        const subString = this.subString(byteString, start, end, this.line);
        stack.push(subString);
    }
}
exports.Substring = Substring;
// pop a byte-array A and two integers B and C.
// Extract a range of bytes from A starting at B up to but not including C,
// push the substring result. If C < B, or either is larger than the array length,
// the program fails
// push to stack [...stack, substring]
class Substring3 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        const end = this.assertBigInt(stack.pop(), this.line);
        const start = this.assertBigInt(stack.pop(), this.line);
        const byteString = this.assertBytes(stack.pop(), this.line);
        const subString = this.subString(byteString, start, end, this.line);
        stack.push(subString);
    }
}
exports.Substring3 = Substring3;
// push field from current transaction to stack
// push to stack [...stack, transaction field]
class Txn extends opcode_1.Op {
    /**
     * Set transaction field according to arguments passed
     * @param args Expected arguments: [transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.idx = undefined;
        this.assertTxFieldDefined(args[0], interpreter.tealVersion, line);
        if (constants_1.TxArrFields[interpreter.tealVersion].has(args[0])) { // eg. txn Accounts 1
            (0, parsing_1.assertLen)(args.length, 2, line);
            (0, parsing_1.assertOnlyDigits)(args[1], line);
            this.idx = Number(args[1]);
        }
        else {
            (0, parsing_1.assertLen)(args.length, 1, line);
        }
        this.assertTxFieldDefined(args[0], interpreter.tealVersion, line);
        this.field = args[0]; // field
        this.interpreter = interpreter;
    }
    execute(stack) {
        let result;
        if (this.idx !== undefined) { // if field is an array use txAppArg (with "Accounts"/"ApplicationArgs"/'Assets'..)
            result = (0, txn_1.txAppArg)(this.field, this.interpreter.runtime.ctx.tx, this.idx, this, this.interpreter.tealVersion, this.line);
        }
        else {
            result = (0, txn_1.txnSpecbyField)(this.field, this.interpreter.runtime.ctx.tx, this.interpreter.runtime.ctx.gtxs, this.interpreter.tealVersion);
        }
        stack.push(result);
    }
}
exports.Txn = Txn;
// push field to the stack from a transaction in the current transaction group
// If this transaction is i in the group, gtxn i field is equivalent to txn field.
// push to stack [...stack, transaction field]
class Gtxn extends opcode_1.Op {
    /**
     * Sets `field`, `txIdx` values according to arguments passed.
     * @param args Expected arguments: [transaction group index, transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.txFieldIdx = undefined;
        if (constants_1.TxArrFields[interpreter.tealVersion].has(args[1])) {
            (0, parsing_1.assertLen)(args.length, 3, line); // eg. gtxn 0 Accounts 1
            (0, parsing_1.assertOnlyDigits)(args[2], line);
            this.txFieldIdx = Number(args[2]);
        }
        else {
            (0, parsing_1.assertLen)(args.length, 2, line);
        }
        (0, parsing_1.assertOnlyDigits)(args[0], line);
        this.assertTxFieldDefined(args[1], interpreter.tealVersion, line);
        this.txIdx = Number(args[0]); // transaction group index
        this.field = args[1]; // field
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.assertUint8(BigInt(this.txIdx), this.line);
        this.checkIndexBound(this.txIdx, this.interpreter.runtime.ctx.gtxs, this.line);
        let result;
        if (this.txFieldIdx !== undefined) {
            const tx = this.interpreter.runtime.ctx.gtxs[this.txIdx]; // current tx
            result = (0, txn_1.txAppArg)(this.field, tx, this.txFieldIdx, this, this.interpreter.tealVersion, this.line);
        }
        else {
            result = (0, txn_1.txnSpecbyField)(this.field, this.interpreter.runtime.ctx.gtxs[this.txIdx], this.interpreter.runtime.ctx.gtxs, this.interpreter.tealVersion);
        }
        stack.push(result);
    }
}
exports.Gtxn = Gtxn;
/**
 * push value of an array field from current transaction to stack
 * push to stack [...stack, value of an array field ]
 * NOTE: a) for arg="Accounts" index 0 means sender's address, and index 1 means first address
 * from accounts array (eg. txna Accounts 1: will push 1st address from Accounts[] to stack)
 * b) for arg="ApplicationArgs" index 0 means first argument for application array (normal indexing)
 */
class Txna extends opcode_1.Op {
    /**
     * Sets `field` and `idx` values according to arguments passed.
     * @param args Expected arguments: [transaction field, transaction field array index]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, line);
        (0, parsing_1.assertOnlyDigits)(args[1], line);
        this.assertTxArrFieldDefined(args[0], interpreter.tealVersion, line);
        this.field = args[0]; // field
        this.idx = Number(args[1]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        const result = (0, txn_1.txAppArg)(this.field, this.interpreter.runtime.ctx.tx, this.idx, this, this.interpreter.tealVersion, this.line);
        stack.push(result);
    }
}
exports.Txna = Txna;
/**
 * push value of a field to the stack from a transaction in the current transaction group
 * push to stack [...stack, value of field]
 * NOTE: for arg="Accounts" index 0 means sender's address, and index 1 means first address from accounts
 * array (eg. gtxna 0 Accounts 1: will push 1st address from Accounts[](from the 1st tx in group) to stack)
 * b) for arg="ApplicationArgs" index 0 means first argument for application array (normal indexing)
 */
class Gtxna extends opcode_1.Op {
    /**
     * Sets `field`(Transaction Field), `idx`(Array Index) and
     * `txIdx`(Transaction Group Index) values according to arguments passed.
     * @param args Expected arguments:
     * [transaction group index, transaction field, transaction field array index]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 3, line);
        (0, parsing_1.assertOnlyDigits)(args[0], line);
        (0, parsing_1.assertOnlyDigits)(args[2], line);
        this.assertTxArrFieldDefined(args[1], interpreter.tealVersion, line);
        this.txIdx = Number(args[0]); // transaction group index
        this.field = args[1]; // field
        this.idx = Number(args[2]); // transaction field array index
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertUint8(BigInt(this.txIdx), this.line);
        this.checkIndexBound(this.txIdx, this.interpreter.runtime.ctx.gtxs, this.line);
        const tx = this.interpreter.runtime.ctx.gtxs[this.txIdx];
        const result = (0, txn_1.txAppArg)(this.field, tx, this.idx, this, this.interpreter.tealVersion, this.line);
        stack.push(result);
    }
}
exports.Gtxna = Gtxna;
// represents branch name of a new branch
// push to stack [...stack]
class Label extends opcode_1.Op {
    /**
     * Sets `label` according to arguments passed.
     * @param args Expected arguments: [label]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.label = args[0].split(':')[0];
        this.line = line;
    }
    ;
    execute(stack) { }
}
exports.Label = Label;
// branch unconditionally to label - Tealv <= 3
// push to stack [...stack]
class Branch extends opcode_1.Op {
    /**
     * Sets `label` according to arguments passed.
     * @param args Expected arguments: [label of branch]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.label = args[0];
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.interpreter.jumpForward(this.label, this.line);
    }
}
exports.Branch = Branch;
// branch unconditionally to label - TEALv4
// can also jump backward
// push to stack [...stack]
class Branchv4 extends Branch {
    execute(stack) {
        this.interpreter.jumpToLabel(this.label, this.line);
    }
}
exports.Branchv4 = Branchv4;
// branch conditionally if top of stack is zero - Teal version <= 3
// push to stack [...stack]
class BranchIfZero extends opcode_1.Op {
    /**
     * Sets `label` according to arguments passed.
     * @param args Expected arguments: [label of branch]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.label = args[0];
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        if (last === 0n) {
            this.interpreter.jumpForward(this.label, this.line);
        }
    }
}
exports.BranchIfZero = BranchIfZero;
// branch conditionally if top of stack is zero - Tealv4
// can jump forward also
// push to stack [...stack]
class BranchIfZerov4 extends BranchIfZero {
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        if (last === 0n) {
            this.interpreter.jumpToLabel(this.label, this.line);
        }
    }
}
exports.BranchIfZerov4 = BranchIfZerov4;
// branch conditionally if top of stack is non zero
// push to stack [...stack]
class BranchIfNotZero extends opcode_1.Op {
    /**
     * Sets `label` according to arguments passed.
     * @param args Expected arguments: [label of branch]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.label = args[0];
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        if (last !== 0n) {
            this.interpreter.jumpForward(this.label, this.line);
        }
    }
}
exports.BranchIfNotZero = BranchIfNotZero;
// branch conditionally if top of stack is non zero - Tealv4
// can jump forward as well
// push to stack [...stack]
class BranchIfNotZerov4 extends BranchIfNotZero {
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = this.assertBigInt(stack.pop(), this.line);
        if (last !== 0n) {
            this.interpreter.jumpToLabel(this.label, this.line);
        }
    }
}
exports.BranchIfNotZerov4 = BranchIfNotZerov4;
// use last value on stack as success value; end
// push to stack [...stack, last]
class Return extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const last = stack.pop();
        while (stack.length()) {
            stack.pop();
        }
        stack.push(last); // use last value as success
        this.interpreter.instructionIndex = this.interpreter.instructions.length; // end execution
    }
}
exports.Return = Return;
// push field from current transaction to stack
class Global extends opcode_1.Op {
    /**
     * Stores global field to query as string
     * @param args Expected arguments: [field] // Ex: ["GroupSize"]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.assertGlobalDefined(args[0], interpreter.tealVersion, line);
        this.field = args[0]; // global field
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        let result;
        switch (this.field) {
            case 'GroupSize': {
                result = this.interpreter.runtime.ctx.gtxs.length;
                break;
            }
            case 'CurrentApplicationID': {
                result = this.interpreter.runtime.ctx.tx.apid;
                this.interpreter.runtime.assertAppDefined(result, this.interpreter.getApp(result, this.line), this.line);
                break;
            }
            case 'Round': {
                result = this.interpreter.runtime.getRound();
                break;
            }
            case 'LatestTimestamp': {
                result = this.interpreter.runtime.getTimestamp();
                break;
            }
            case 'CreatorAddress': {
                const appID = this.interpreter.runtime.ctx.tx.apid;
                const app = this.interpreter.getApp(appID, this.line);
                result = (0, algosdk_1.decodeAddress)(app.creator).publicKey;
                break;
            }
            case 'GroupID': {
                result = Uint8Array.from(this.interpreter.runtime.ctx.tx.grp ?? constants_1.ZERO_ADDRESS);
                break;
            }
            case 'CurrentApplicationAddress': {
                const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
                result = (0, algosdk_1.decodeAddress)((0, algosdk_1.getApplicationAddress)(appID)).publicKey;
                break;
            }
            default: {
                result = constants_1.GlobalFields[this.interpreter.tealVersion][this.field];
            }
        }
        if (typeof result === 'number') {
            stack.push(BigInt(result));
        }
        else {
            stack.push(result);
        }
    }
}
exports.Global = Global;
// check if account specified by Txn.Accounts[A] opted in for the application B => {0 or 1}
// params: account index, application id (top of the stack on opcode entry).
// push to stack [...stack, 1] if opted in
// push to stack[...stack, 0] 0 otherwise
class AppOptedIn extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const appRef = this.assertBigInt(stack.pop(), this.line);
        const accountRef = stack.pop(); // index to tx.accounts[] OR an address directly
        const account = this.interpreter.getAccount(accountRef, this.line);
        const localState = account.appsLocalState;
        const appID = this.interpreter.getAppIDByReference(Number(appRef), false, this.line, this);
        const isOptedIn = localState.get(appID);
        if (isOptedIn) {
            stack.push(1n);
        }
        else {
            stack.push(0n);
        }
    }
}
exports.AppOptedIn = AppOptedIn;
// read from account specified by Txn.Accounts[A] from local state of the current application key B => value
// push to stack [...stack, bigint/bytes] If key exist
// push to stack [...stack, 0] otherwise
class AppLocalGet extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        const accountRef = stack.pop();
        const account = this.interpreter.getAccount(accountRef, this.line);
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        const val = account.getLocalState(appID, key);
        if (val) {
            stack.push(val);
        }
        else {
            stack.push(0n); // The value is zero if the key does not exist.
        }
    }
}
exports.AppLocalGet = AppLocalGet;
// read from application local state at Txn.Accounts[A] => app B => key C from local state.
// push to stack [...stack, value, 1] (Note: value is 0 if key does not exist)
class AppLocalGetEx extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        const appRef = this.assertBigInt(stack.pop(), this.line);
        const accountRef = stack.pop();
        const appID = this.interpreter.getAppIDByReference(Number(appRef), false, this.line, this);
        const account = this.interpreter.getAccount(accountRef, this.line);
        const val = account.getLocalState(appID, key);
        if (val) {
            stack.push(val);
            stack.push(1n);
        }
        else {
            stack.push(0n); // The value is zero if the key does not exist.
            stack.push(0n); // did_exist_flag
        }
    }
}
exports.AppLocalGetEx = AppLocalGetEx;
// read key A from global state of a current application => value
// push to stack[...stack, 0] if key doesn't exist
// otherwise push to stack [...stack, value]
class AppGlobalGet extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        const val = this.interpreter.getGlobalState(appID, key, this.line);
        if (val) {
            stack.push(val);
        }
        else {
            stack.push(0n); // The value is zero if the key does not exist.
        }
    }
}
exports.AppGlobalGet = AppGlobalGet;
// read from application Txn.ForeignApps[A] global state key B pushes to the stack
// push to stack [...stack, value, 1] (Note: value is 0 if key does not exist)
// A is specified as an account index in the ForeignApps field of the ApplicationCall transaction,
// zero index means this app
class AppGlobalGetEx extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        // appRef could be index to foreign apps array,
        // or since v4 an application id that appears in Txn.ForeignApps
        const appRef = this.assertBigInt(stack.pop(), this.line);
        const appID = this.interpreter.getAppIDByReference(Number(appRef), true, this.line, this);
        const val = this.interpreter.getGlobalState(appID, key, this.line);
        if (val) {
            stack.push(val);
            stack.push(1n);
        }
        else {
            stack.push(0n); // The value is zero if the key does not exist.
            stack.push(0n); // did_exist_flag
        }
    }
}
exports.AppGlobalGetEx = AppGlobalGetEx;
// write to account specified by Txn.Accounts[A] to local state of a current application key B with value C
// pops from stack [...stack, value, key]
// pushes nothing to stack, updates the app user local storage
class AppLocalPut extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const value = stack.pop();
        const key = this.assertBytes(stack.pop(), this.line);
        const accountRef = stack.pop();
        const account = this.interpreter.getAccount(accountRef, this.line);
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        // get updated local state for account
        const localState = account.setLocalState(appID, key, value, this.line);
        const acc = this.interpreter.runtime.assertAccountDefined(account.address, this.interpreter.runtime.ctx.state.accounts.get(account.address), this.line);
        acc.appsLocalState.set(appID, localState);
    }
}
exports.AppLocalPut = AppLocalPut;
// write key A and value B to global state of the current application
// push to stack [...stack]
class AppGlobalPut extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const value = stack.pop();
        const key = this.assertBytes(stack.pop(), this.line);
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0; // if undefined use 0 as default
        this.interpreter.setGlobalState(appID, key, value, this.line);
    }
}
exports.AppGlobalPut = AppGlobalPut;
// delete from account specified by Txn.Accounts[A] local state key B of the current application
// push to stack [...stack]
class AppLocalDel extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        const accountRef = stack.pop();
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        const account = this.interpreter.getAccount(accountRef, this.line);
        const localState = account.appsLocalState.get(appID);
        if (localState) {
            localState["key-value"].delete(key.toString()); // delete from local state
            let acc = this.interpreter.runtime.ctx.state.accounts.get(account.address);
            acc = this.interpreter.runtime.assertAccountDefined(account.address, acc, this.line);
            acc.appsLocalState.set(appID, localState);
        }
    }
}
exports.AppLocalDel = AppLocalDel;
// delete key A from a global state of the current application
// push to stack [...stack]
class AppGlobalDel extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const key = this.assertBytes(stack.pop(), this.line);
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        const app = this.interpreter.getApp(appID, this.line);
        if (app) {
            const globalState = app["global-state"];
            globalState.delete(key.toString());
        }
    }
}
exports.AppGlobalDel = AppGlobalDel;
// get balance for the requested account specified
// by Txn.Accounts[A] in microalgos. A is specified as an account
// index in the Accounts field of the ApplicationCall transaction,
// zero index means the sender
// push to stack [...stack, bigint]
class Balance extends opcode_1.Op {
    /**
     * Asserts if arguments length is zero
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter Interpreter Object
     */
    constructor(args, line, interpreter) {
        super();
        this.interpreter = interpreter;
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const accountRef = stack.pop();
        const acc = this.interpreter.getAccount(accountRef, this.line);
        stack.push(BigInt(acc.balance()));
    }
}
exports.Balance = Balance;
// For Account A, Asset B (txn.accounts[A]) pushes to the
// push to stack [...stack, value(bigint/bytes), 1]
// NOTE: if account has no B holding then value = 0, did_exist = 0,
class GetAssetHolding extends opcode_1.Op {
    /**
     * Sets field according to arguments passed.
     * @param args Expected arguments: [Asset Holding field]
     * // Note: Asset holding field will be string
     * For ex: `AssetBalance` is correct `0` is not.
     * @param line line number in TEAL file
     * @param interpreter Interpreter Object
     */
    constructor(args, line, interpreter) {
        super();
        this.interpreter = interpreter;
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.field = args[0];
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const assetRef = this.assertBigInt(stack.pop(), this.line);
        const accountRef = stack.pop();
        const account = this.interpreter.getAccount(accountRef, this.line);
        const assetID = this.interpreter.getAssetIDByReference(Number(assetRef), false, this.line, this);
        const assetInfo = account.assets.get(assetID);
        if (assetInfo === undefined) {
            stack.push(0n);
            stack.push(0n);
            return;
        }
        let value;
        switch (this.field) {
            case "AssetBalance":
                value = BigInt(assetInfo.amount);
                break;
            case "AssetFrozen":
                value = assetInfo["is-frozen"] ? 1n : 0n;
                break;
            default:
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_FIELD_TYPE, { line: this.line });
        }
        stack.push(value);
        stack.push(1n);
    }
}
exports.GetAssetHolding = GetAssetHolding;
// get Asset Params Info for given account
// For Index in ForeignAssets array
// push to stack [...stack, value(bigint/bytes), did_exist]
// NOTE: if asset doesn't exist, then did_exist = 0, value = 0
class GetAssetDef extends opcode_1.Op {
    /**
     * Sets transaction field according to arguments passed
     * @param args Expected arguments: [Asset Params field]
     * // Note: Asset Params field will be string
     * For ex: `AssetTotal` is correct `0` is not.
     * @param line line number in TEAL file
     * @param interpreter Interpreter Object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.interpreter = interpreter;
        (0, parsing_1.assertLen)(args.length, 1, line);
        if (constants_1.AssetParamMap[interpreter.tealVersion][args[0]] === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_ASSET_FIELD, {
                field: args[0],
                line: line,
                tealV: interpreter.tealVersion
            });
        }
        this.field = args[0];
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const assetRef = this.assertBigInt(stack.pop(), this.line);
        const assetID = this.interpreter.getAssetIDByReference(Number(assetRef), true, this.line, this);
        const AssetDefinition = this.interpreter.getAssetDef(assetID);
        let def;
        if (AssetDefinition === undefined) {
            stack.push(0n);
            stack.push(0n);
        }
        else {
            let value;
            const s = constants_1.AssetParamMap[this.interpreter.tealVersion][this.field];
            switch (this.field) {
                case "AssetTotal":
                    value = BigInt(AssetDefinition.total);
                    break;
                case "AssetDecimals":
                    value = BigInt(AssetDefinition.decimals);
                    break;
                case "AssetDefaultFrozen":
                    value = AssetDefinition.defaultFrozen ? 1n : 0n;
                    break;
                default:
                    def = AssetDefinition[s];
                    if ((0, algosdk_1.isValidAddress)(def)) {
                        value = (0, algosdk_1.decodeAddress)(def).publicKey;
                    }
                    else {
                        value = web_1.parsing.stringToBytes(def);
                    }
                    break;
            }
            stack.push(value);
            stack.push(1n);
        }
    }
}
exports.GetAssetDef = GetAssetDef;
/** Pseudo-Ops **/
// push integer to stack
// push to stack [...stack, integer value]
class Int extends opcode_1.Op {
    /**
     * Sets uint64 variable according to arguments passed.
     * @param args Expected arguments: [number]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        let uint64;
        const intConst = types_1.TxOnComplete[args[0]] ||
            types_1.TxnType[args[0]];
        // check if string is keyof TxOnComplete or TxnType
        if (intConst !== undefined) {
            uint64 = BigInt(intConst);
        }
        else {
            const val = (0, parsing_1.assertNumber)(args[0], line);
            uint64 = BigInt(val);
        }
        this.checkOverflow(uint64, line, constants_1.MAX_UINT64);
        this.uint64 = uint64;
    }
    execute(stack) {
        stack.push(this.uint64);
    }
}
exports.Int = Int;
// push bytes to stack
// push to stack [...stack, converted data]
class Byte extends opcode_1.Op {
    /**
     * Sets `str` and  `encoding` values according to arguments passed.
     * @param args Expected arguments: [data string]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        [this.str, this.encoding] = (0, parsing_1.getEncoding)(args, line);
    }
    execute(stack) {
        const buffer = (0, parsing_1.convertToBuffer)(this.str, this.encoding);
        stack.push(new Uint8Array(buffer));
    }
}
exports.Byte = Byte;
// decodes algorand address to bytes and pushes to stack
// push to stack [...stack, address]
class Addr extends opcode_1.Op {
    /**
     * Sets `addr` value according to arguments passed.
     * @param args Expected arguments: [Address]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        if (!(0, algosdk_1.isValidAddress)(args[0])) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.INVALID_ADDR, { addr: args[0], line: line });
        }
        this.addr = args[0];
        this.line = line;
    }
    ;
    execute(stack) {
        const addr = (0, algosdk_1.decodeAddress)(this.addr);
        stack.push(addr.publicKey);
    }
}
exports.Addr = Addr;
/* TEALv3 Ops */
// immediately fail unless value top is a non-zero number
// pops from stack: [...stack, uint64]
class Assert extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        if (top === 0n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.TEAL_ENCOUNTERED_ERR, { line: this.line });
        }
    }
}
exports.Assert = Assert;
// push immediate UINT to the stack as an integer
// push to stack: [...stack, uint64]
class PushInt extends opcode_1.Op {
    /**
     * Sets uint64 variable according to arguments passed.
     * @param args Expected arguments: [number]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        (0, parsing_1.assertOnlyDigits)(args[0], line);
        this.checkOverflow(BigInt(args[0]), line, constants_1.MAX_UINT64);
        this.uint64 = BigInt(args[0]);
    }
    execute(stack) {
        stack.push(this.uint64);
    }
}
exports.PushInt = PushInt;
// push bytes to stack
// push to stack [...stack, converted data]
class PushBytes extends opcode_1.Op {
    /**
     * Sets `str` and  `encoding` values according to arguments passed.
     * @param args Expected arguments: [data string]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        [this.str, this.encoding] = (0, parsing_1.getEncoding)(args, line);
        if (this.encoding !== types_1.EncodingType.UTF8) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKOWN_DECODE_TYPE, { val: args[0], line: line });
        }
    }
    execute(stack) {
        const buffer = (0, parsing_1.convertToBuffer)(this.str, this.encoding);
        stack.push(new Uint8Array(buffer));
    }
}
exports.PushBytes = PushBytes;
// swaps two last values on stack: A, B -> B, A (A,B = any)
// pops from stack: [...stack, A, B]
// pushes to stack: [...stack, B, A]
class Swap extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const a = stack.pop();
        const b = stack.pop();
        stack.push(a);
        stack.push(b);
    }
}
exports.Swap = Swap;
/**
 * bit indexing begins with low-order bits in integers.
 * Setting bit 4 to 1 on the integer 0 yields 16 (int 0x0010, or 2^4).
 * Indexing begins in the first bytes of a byte-string
 * (as seen in getbyte and substring). Setting bits 0 through 11 to 1
 * in a 4 byte-array of 0s yields byte 0xfff00000
 * Pops from stack: [ ... stack, {any A}, {uint64 B}, {uint64 C} ]
 * Pushes to stack: [ ...stack, uint64 ]
 * pop a target A, index B, and bit C. Set the Bth bit of A to C, and push the result
 */
class SetBit extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const bit = this.assertBigInt(stack.pop(), this.line);
        const index = this.assertBigInt(stack.pop(), this.line);
        const target = stack.pop();
        if (bit > 1n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SET_BIT_VALUE_ERROR, { line: this.line });
        }
        if (typeof target === "bigint") {
            this.assert64BitIndex(index, this.line);
            const binaryStr = target.toString(2);
            const binaryArr = [...(binaryStr.padStart(64, "0"))];
            const size = binaryArr.length;
            binaryArr[size - Number(index) - 1] = (bit === 0n ? "0" : "1");
            stack.push((0, parsing_1.parseBinaryStrToBigInt)(binaryArr));
        }
        else {
            const byteIndex = Math.floor(Number(index) / 8);
            this.assertBytesIndex(byteIndex, target, this.line);
            const targetBit = Number(index) % 8;
            // 8th bit in a bytes array will be highest order bit in second element
            // that's why mask is reversed
            const mask = 1 << (7 - targetBit);
            if (bit === 1n) {
                // set bit
                target[byteIndex] |= mask;
            }
            else {
                // clear bit
                const mask = ~(1 << ((7 - targetBit)));
                target[byteIndex] &= mask;
            }
            stack.push(target);
        }
    }
}
exports.SetBit = SetBit;
/**
 * pop a target A (integer or byte-array), and index B. Push the Bth bit of A.
 * Pops from stack: [ ... stack, {any A}, {uint64 B}]
 * Pushes to stack: [ ...stack, uint64]
 */
class GetBit extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const index = this.assertBigInt(stack.pop(), this.line);
        const target = stack.pop();
        if (typeof target === "bigint") {
            this.assert64BitIndex(index, this.line);
            const binaryStr = target.toString(2);
            const size = binaryStr.length;
            stack.push(BigInt(binaryStr[size - Number(index) - 1]));
        }
        else {
            const byteIndex = Math.floor(Number(index) / 8);
            this.assertBytesIndex(byteIndex, target, this.line);
            const targetBit = Number(index) % 8;
            const binary = target[byteIndex].toString(2);
            const str = binary.padStart(8, "0");
            stack.push(BigInt(str[targetBit]));
        }
    }
}
exports.GetBit = GetBit;
/**
 * pop a byte-array A, integer B, and
 * small integer C (between 0..255). Set the Bth byte of A to C, and push the result
 * Pops from stack: [ ...stack, {[]byte A}, {uint64 B}, {uint64 C}]
 * Pushes to stack: [ ...stack, []byte]
 */
class SetByte extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const smallInteger = this.assertBigInt(stack.pop(), this.line);
        const index = this.assertBigInt(stack.pop(), this.line);
        const target = this.assertBytes(stack.pop(), this.line);
        this.assertUint8(smallInteger, this.line);
        this.assertBytesIndex(Number(index), target, this.line);
        target[Number(index)] = Number(smallInteger);
        stack.push(target);
    }
}
exports.SetByte = SetByte;
/**
 * pop a byte-array A and integer B. Extract the Bth byte of A and push it as an integer
 * Pops from stack: [ ...stack, {[]byte A}, {uint64 B} ]
 * Pushes to stack: [ ...stack, uint64 ]
 */
class GetByte extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const index = this.assertBigInt(stack.pop(), this.line);
        const target = this.assertBytes(stack.pop(), this.line);
        this.assertBytesIndex(Number(index), target, this.line);
        stack.push(BigInt(target[Number(index)]));
    }
}
exports.GetByte = GetByte;
// push the Nth value (0 indexed) from the top of the stack.
// pops from stack: [...stack]
// pushes to stack: [...stack, any (nth slot from top of stack)]
// NOTE: dig 0 is same as dup
class Dig extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [ depth ] // slot to duplicate
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        (0, parsing_1.assertOnlyDigits)(args[0], line);
        this.assertUint8(BigInt(args[0]), line);
        this.depth = Number(args[0]);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, this.depth + 1, this.line);
        const tempStack = new stack_1.Stack(this.depth + 1); // depth = 2 means 3rd slot from top of stack
        let target;
        for (let i = 0; i <= this.depth; ++i) {
            target = stack.pop();
            tempStack.push(target);
        }
        while (tempStack.length()) {
            stack.push(tempStack.pop());
        }
        stack.push(target);
    }
}
exports.Dig = Dig;
// selects one of two values based on top-of-stack: A, B, C -> (if C != 0 then B else A)
// pops from stack: [...stack, {any A}, {any B}, {uint64 C}]
// pushes to stack: [...stack, any (A or B)]
class Select extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const toCheck = this.assertBigInt(stack.pop(), this.line);
        const notZeroSelection = stack.pop();
        const isZeroSelection = stack.pop();
        if (toCheck !== 0n) {
            stack.push(notZeroSelection);
        }
        else {
            stack.push(isZeroSelection);
        }
    }
}
exports.Select = Select;
/**
 * push field F of the Ath transaction (A = top of stack) in the current group
 * pops from stack: [...stack, uint64]
 * pushes to stack: [...stack, transaction field]
 * NOTE: "gtxns field" is equivalent to "gtxn _i_ field" (where _i_ is the index
 * of transaction in group, fetched from stack).
 * gtxns exists so that i can be calculated, often based on the index of the current transaction.
 */
class Gtxns extends Gtxn {
    /**
     * Sets `field`, `txIdx` values according to arguments passed.
     * @param args Expected arguments: [transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // NOTE: 100 is a mock value (max no of txns in group can be 16 atmost).
        // In gtxns & gtxnsa opcodes, index is fetched from top of stack.
        super(["100", ...args], line, interpreter);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        this.assertUint8(top, this.line);
        this.txIdx = Number(top);
        super.execute(stack);
    }
}
exports.Gtxns = Gtxns;
/**
 * push Ith value of the array field F from the Ath (A = top of stack) transaction in the current group
 * pops from stack: [...stack, uint64]
 * push to stack [...stack, value of field]
 */
class Gtxnsa extends Gtxna {
    /**
     * Sets `field`(Transaction Field), `idx`(Array Index) values according to arguments passed.
     * @param args Expected arguments: [transaction field(F), transaction field array index(I)]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // NOTE: 100 is a mock value (max no of txns in group can be 16 atmost).
        // In gtxns & gtxnsa opcodes, index is fetched from top of stack.
        super(["100", ...args], line, interpreter);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        this.assertUint8(top, this.line);
        this.txIdx = Number(top);
        super.execute(stack);
    }
}
exports.Gtxnsa = Gtxnsa;
/**
 * get minimum required balance for the requested account specified by Txn.Accounts[A] in microalgos.
 * NOTE: A = 0 represents tx.sender account. Required balance is affected by ASA and App usage. When creating
 * or opting into an app, the minimum balance grows before the app code runs, therefore the increase
 * is visible there. When deleting or closing out, the minimum balance decreases after the app executes.
 * pops from stack: [...stack, uint64(account index)]
 * push to stack [...stack, uint64(min balance in microalgos)]
 */
class MinBalance extends opcode_1.Op {
    /**
     * Asserts if arguments length is zero
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter Interpreter Object
     */
    constructor(args, line, interpreter) {
        super();
        this.interpreter = interpreter;
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const accountRef = stack.pop();
        const acc = this.interpreter.getAccount(accountRef, this.line);
        stack.push(BigInt(acc.minBalance));
    }
}
exports.MinBalance = MinBalance;
/** TEALv4 Ops **/
// push Ith scratch space index of the Tth transaction in the current group
// push to stack [...stack, bigint/bytes]
// Pops nothing
// Args expected: [{uint8 transaction group index}(T),
// {uint8 position in scratch space to load from}(I)]
class Gload extends opcode_1.Op {
    /**
     * Stores scratch space index and transaction index number according to arguments passed.
     * @param args Expected arguments: [index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, this.line);
        (0, parsing_1.assertOnlyDigits)(args[0], this.line);
        (0, parsing_1.assertOnlyDigits)(args[1], this.line);
        this.txIndex = Number(args[0]);
        this.scratchIndex = Number(args[1]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        const scratch = this.interpreter.runtime.ctx.sharedScratchSpace.get(this.txIndex);
        if (scratch === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.SCRATCH_EXIST_ERROR, { index: this.txIndex, line: this.line });
        }
        this.checkIndexBound(this.scratchIndex, scratch, this.line);
        stack.push(scratch[this.scratchIndex]);
    }
}
exports.Gload = Gload;
// push Ith scratch space index of the Tth transaction in the current group
// push to stack [...stack, bigint/bytes]
// Pops uint64(T)
// Args expected: [{uint8 position in scratch space to load from}(I)]
class Gloads extends Gload {
    /**
     * Stores scratch space index number according to argument passed.
     * @param args Expected arguments: [index number]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // "11" is mock value, will be updated when poping from stack in execute
        super(["11", ...args], line, interpreter);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        this.txIndex = Number(this.assertBigInt(stack.pop(), this.line));
        super.execute(stack);
    }
}
exports.Gloads = Gloads;
/**
 * Provide subroutine functionality. When callsub is called, the current location in
 * the program is saved and immediately jumps to the label passed to the opcode.
 * Pops: None
 * Pushes: None
 * The call stack is separate from the data stack. Only callsub and retsub manipulate it.
 * Pops: None
 * Pushes: Pushes current instruction index in call stack
 */
class Callsub extends opcode_1.Op {
    /**
     * Sets `label` according to arguments passed.
     * @param args Expected arguments: [label of branch]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.label = args[0];
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        // the current location in the program is saved
        this.interpreter.callStack.push(this.interpreter.instructionIndex);
        // immediately jumps to the label passed to the opcode.
        this.interpreter.jumpToLabel(this.label, this.line);
    }
}
exports.Callsub = Callsub;
/**
 * When the retsub opcode is called, the AVM will resume
 * execution at the previous saved point.
 * Pops: None
 * Pushes: None
 * The call stack is separate from the data stack. Only callsub and retsub manipulate it.
 * Pops: index from call stack
 * Pushes: None
 */
class Retsub extends opcode_1.Op {
    /**
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        (0, parsing_1.assertLen)(args.length, 0, line);
        this.interpreter = interpreter;
        this.line = line;
    }
    execute(stack) {
        // get current location from saved point
        // jump to saved instruction opcode
        if (this.interpreter.callStack.length() === 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.CALL_STACK_EMPTY, { line: this.line });
        }
        this.interpreter.instructionIndex = this.interpreter.callStack.pop();
    }
}
exports.Retsub = Retsub;
// generic op to execute byteslice arithmetic
// `b+`, `b-`, `b*`, `b/`, `b%`, `b<`, `b>`, `b<=`,
// `b>=`, `b==`, `b!=`, `b\`, `b&`, `b^`, `b~`, `bzero`
class ByteOp extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack, op) {
        this.assertMinStackLen(stack, 2, this.line);
        const byteB = this.assertBytes(stack.pop(), this.line, constants_1.MAX_INPUT_BYTE_LEN);
        const byteA = this.assertBytes(stack.pop(), this.line, constants_1.MAX_INPUT_BYTE_LEN);
        const bigIntB = (0, parsing_1.bigEndianBytesToBigInt)(byteB);
        const bigIntA = (0, parsing_1.bigEndianBytesToBigInt)(byteA);
        let r;
        switch (op) {
            case 0 /* Add */: {
                r = bigIntA + bigIntB;
                break;
            }
            case 1 /* Sub */: {
                r = bigIntA - bigIntB;
                this.checkUnderflow(r, this.line);
                break;
            }
            case 2 /* Mul */: {
                // NOTE: 12n * 0n == 0n, but in bytesclice arithmatic, this is equivalent to
                // empty bytes (eg. byte "A" * byte "" === byte "")
                r = bigIntA * bigIntB;
                break;
            }
            case 3 /* Div */: {
                if (bigIntB === 0n) {
                    throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ZERO_DIV, { line: this.line });
                }
                r = bigIntA / bigIntB;
                break;
            }
            case 4 /* Mod */: {
                if (bigIntB === 0n) {
                    throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ZERO_DIV, { line: this.line });
                }
                r = bigIntA % bigIntB;
                break;
            }
            case 5 /* LessThan */: {
                r = bigIntA < bigIntB;
                break;
            }
            case 6 /* GreaterThan */: {
                r = bigIntA > bigIntB;
                break;
            }
            case 7 /* LessThanEqualTo */: {
                r = bigIntA <= bigIntB;
                break;
            }
            case 8 /* GreaterThanEqualTo */: {
                r = bigIntA >= bigIntB;
                break;
            }
            case 9 /* EqualTo */: {
                r = bigIntA === bigIntB;
                break;
            }
            case 10 /* NotEqualTo */: {
                r = bigIntA !== bigIntB;
                break;
            }
            case 11 /* BitwiseOr */: {
                r = bigIntA | bigIntB;
                break;
            }
            case 12 /* BitwiseAnd */: {
                r = bigIntA & bigIntB;
                break;
            }
            case 13 /* BitwiseXor */: {
                r = bigIntA ^ bigIntB;
                break;
            }
            default: {
                throw new Error('Operation not supported');
            }
        }
        if (typeof r === 'boolean') {
            stack.push(BigInt(r)); // 0 or 1
        }
        else {
            const resultAsBytes = r === 0n ? new Uint8Array([]) : (0, parsing_1.bigintToBigEndianBytes)(r);
            if (op === 11 /* BitwiseOr */ || op === 12 /* BitwiseAnd */ || op === 13 /* BitwiseXor */) {
                // for bitwise ops, zero's are "left" padded upto length.max(byteB, byteA)
                // https://developer.algorand.org/docs/reference/teal/specification/#arithmetic-logic-and-cryptographic-operations
                const maxSize = Math.max(byteA.length, byteB.length);
                const paddedZeroArr = new Uint8Array(Math.max(0, maxSize - resultAsBytes.length)).fill(0);
                const mergedArr = new Uint8Array(maxSize);
                mergedArr.set(paddedZeroArr);
                mergedArr.set(resultAsBytes, paddedZeroArr.length);
                stack.push(this.assertBytes(mergedArr, this.line, constants_1.MAX_OUTPUT_BYTE_LEN));
            }
            else {
                stack.push(this.assertBytes(resultAsBytes, this.line, constants_1.MAX_OUTPUT_BYTE_LEN));
            }
        }
    }
}
exports.ByteOp = ByteOp;
// A plus B, where A and B are byte-arrays interpreted as big-endian unsigned integers
// panics on overflow (result > max_uint1024 i.e 128 byte num)
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, []byte]
class ByteAdd extends ByteOp {
    execute(stack) {
        super.execute(stack, 0 /* Add */);
    }
}
exports.ByteAdd = ByteAdd;
// A minus B, where A and B are byte-arrays interpreted as big-endian unsigned integers.
// Panic on underflow.
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, []byte]
class ByteSub extends ByteOp {
    execute(stack) {
        super.execute(stack, 1 /* Sub */);
    }
}
exports.ByteSub = ByteSub;
// A times B, where A and B are byte-arrays interpreted as big-endian unsigned integers.
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, []byte]
class ByteMul extends ByteOp {
    execute(stack) {
        super.execute(stack, 2 /* Mul */);
    }
}
exports.ByteMul = ByteMul;
// A divided by B, where A and B are byte-arrays interpreted as big-endian unsigned integers.
// Panic if B is zero.
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, []byte]
class ByteDiv extends ByteOp {
    execute(stack) {
        super.execute(stack, 3 /* Div */);
    }
}
exports.ByteDiv = ByteDiv;
// A modulo B, where A and B are byte-arrays interpreted as big-endian unsigned integers.
// Panic if B is zero.
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, []byte]
class ByteMod extends ByteOp {
    execute(stack) {
        super.execute(stack, 4 /* Mod */);
    }
}
exports.ByteMod = ByteMod;
// A is greater than B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteGreatorThan extends ByteOp {
    execute(stack) {
        super.execute(stack, 6 /* GreaterThan */);
    }
}
exports.ByteGreatorThan = ByteGreatorThan;
// A is less than B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteLessThan extends ByteOp {
    execute(stack) {
        super.execute(stack, 5 /* LessThan */);
    }
}
exports.ByteLessThan = ByteLessThan;
// A is greater than or equal to B, where A and B are byte-arrays interpreted
// as big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteGreaterThanEqualTo extends ByteOp {
    execute(stack) {
        super.execute(stack, 8 /* GreaterThanEqualTo */);
    }
}
exports.ByteGreaterThanEqualTo = ByteGreaterThanEqualTo;
// A is less than or equal to B, where A and B are byte-arrays interpreted as
// big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteLessThanEqualTo extends ByteOp {
    execute(stack) {
        super.execute(stack, 7 /* LessThanEqualTo */);
    }
}
exports.ByteLessThanEqualTo = ByteLessThanEqualTo;
// A is equals to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteEqualTo extends ByteOp {
    execute(stack) {
        super.execute(stack, 9 /* EqualTo */);
    }
}
exports.ByteEqualTo = ByteEqualTo;
// A is not equal to B, where A and B are byte-arrays interpreted as big-endian unsigned integers => { 0 or 1}
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteNotEqualTo extends ByteOp {
    execute(stack) {
        super.execute(stack, 10 /* NotEqualTo */);
    }
}
exports.ByteNotEqualTo = ByteNotEqualTo;
// A bitwise-or B, where A and B are byte-arrays, zero-left extended to the greater of their lengths
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteBitwiseOr extends ByteOp {
    execute(stack) {
        super.execute(stack, 11 /* BitwiseOr */);
    }
}
exports.ByteBitwiseOr = ByteBitwiseOr;
// A bitwise-and B, where A and B are byte-arrays, zero-left extended to the greater of their lengths
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteBitwiseAnd extends ByteOp {
    execute(stack) {
        super.execute(stack, 12 /* BitwiseAnd */);
    }
}
exports.ByteBitwiseAnd = ByteBitwiseAnd;
// A bitwise-xor B, where A and B are byte-arrays, zero-left extended to the greater of their lengths
// Pops: ... stack, {[]byte A}, {[]byte B}
// push to stack [...stack, uint64]
class ByteBitwiseXor extends ByteOp {
    execute(stack) {
        super.execute(stack, 13 /* BitwiseXor */);
    }
}
exports.ByteBitwiseXor = ByteBitwiseXor;
// X (bytes array) with all bits inverted
// Pops: ... stack, []byte
// push to stack [...stack, byte[]]
class ByteBitwiseInvert extends ByteOp {
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const byteA = this.assertBytes(stack.pop(), this.line, constants_1.MAX_INPUT_BYTE_LEN);
        stack.push(byteA.map(b => (255 - b)));
    }
}
exports.ByteBitwiseInvert = ByteBitwiseInvert;
// push a byte-array of length X, containing all zero bytes
// Pops: ... stack, uint64
// push to stack [...stack, byte[]]
class ByteZero extends ByteOp {
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const len = this.assertBigInt(stack.pop(), this.line);
        const result = new Uint8Array(Number(len)).fill(0);
        stack.push(this.assertBytes(result, this.line, 4096));
    }
}
exports.ByteZero = ByteZero;
/**
 * Pop four uint64 values. The deepest two are interpreted
 * as a uint128 dividend (deepest value is high word),
 * the top two are interpreted as a uint128 divisor.
 * Four uint64 values are pushed to the stack.
 * The deepest two are the quotient (deeper value
 * is the high uint64). The top two are the remainder, low bits on top.
 * Pops: ... stack, {uint64 A}, {uint64 B}, {uint64 C}, {uint64 D}
 * Pushes: ... stack, uint64, uint64, uint64, uint64
 */
class DivModw extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        // Go-algorand implementation: https://github.com/algorand/go-algorand/blob/8f743a98827372bfd8928de3e0b70390ff34f407/data/transactions/logic/eval.go#L927
        const firstLow = this.assertBigInt(stack.pop(), this.line);
        const firstHigh = this.assertBigInt(stack.pop(), this.line);
        let divisor = firstHigh << BigInt('64');
        divisor = divisor + firstLow;
        const secondLow = this.assertBigInt(stack.pop(), this.line);
        const secondHigh = this.assertBigInt(stack.pop(), this.line);
        let dividend = secondHigh << BigInt('64');
        dividend = dividend + secondLow;
        const quotient = dividend / divisor;
        let low = quotient & constants_1.MAX_UINT64;
        this.checkOverflow(low, this.line, constants_1.MAX_UINT64);
        let high = quotient >> BigInt('64');
        this.checkOverflow(high, this.line, constants_1.MAX_UINT64);
        stack.push(high);
        stack.push(low);
        const remainder = dividend % divisor;
        low = remainder & constants_1.MAX_UINT64;
        this.checkOverflow(low, this.line, constants_1.MAX_UINT64);
        high = remainder >> BigInt('64');
        this.checkOverflow(high, this.line, constants_1.MAX_UINT64);
        stack.push(high);
        stack.push(low);
    }
}
exports.DivModw = DivModw;
// A raised to the Bth power. Panic if A == B == 0 and on overflow
// Pops: ... stack, {uint64 A}, {uint64 B}
// Pushes: uint64
class Exp extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        const b = this.assertBigInt(stack.pop(), this.line);
        const a = this.assertBigInt(stack.pop(), this.line);
        if (a === 0n && b === 0n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.EXP_ERROR, { line: this.line });
        }
        const res = a ** b;
        this.checkOverflow(res, this.line, constants_1.MAX_UINT64);
        stack.push(res);
    }
}
exports.Exp = Exp;
// A raised to the Bth power as a 128-bit long result as
// low (top) and high uint64 values on the stack.
// Panic if A == B == 0 or if the results exceeds 2^128-1
// Pops: ... stack, {uint64 A}, {uint64 B}
// Pushes: ... stack, uint64, uint64
class Expw extends Exp {
    execute(stack) {
        const b = this.assertBigInt(stack.pop(), this.line);
        const a = this.assertBigInt(stack.pop(), this.line);
        if (a === 0n && b === 0n) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.EXP_ERROR, { line: this.line });
        }
        const res = a ** b;
        this.checkOverflow(res, this.line, constants_1.MAX_UINT128);
        const low = res & constants_1.MAX_UINT64;
        this.checkOverflow(low, this.line, constants_1.MAX_UINT64);
        const high = res >> BigInt('64');
        this.checkOverflow(high, this.line, constants_1.MAX_UINT64);
        stack.push(high);
        stack.push(low);
    }
}
exports.Expw = Expw;
// Left shift (A times 2^B, modulo 2^64)
// Pops: ... stack, {uint64 A}, {uint64 B}
// Pushes: uint64
class Shl extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        const b = this.assertBigInt(stack.pop(), this.line);
        const a = this.assertBigInt(stack.pop(), this.line);
        const res = (a << b) % (2n ** 64n);
        stack.push(res);
    }
}
exports.Shl = Shl;
// Right shift (A divided by 2^B)
// Pops: ... stack, {uint64 A}, {uint64 B}
// Pushes: uint64
class Shr extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        const b = this.assertBigInt(stack.pop(), this.line);
        const a = this.assertBigInt(stack.pop(), this.line);
        const res = a >> b;
        stack.push(res);
    }
}
exports.Shr = Shr;
// The largest integer B such that B^2 <= X
// Pops: ... stack, uint64
// Pushes: uint64
class Sqrt extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        // https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
        const value = this.assertBigInt(stack.pop(), this.line);
        if (value < 2n) {
            stack.push(value);
            return;
        }
        if (value < 16n) {
            stack.push(BigInt(Math.floor(Math.sqrt(Number(value)))));
            return;
        }
        let x1;
        if (value < (1n << 52n)) {
            x1 = BigInt(Math.floor(Math.sqrt(Number(value)))) - 3n;
        }
        else {
            x1 = (1n << 52n) - 2n;
        }
        let x0 = -1n;
        while ((x0 !== x1 && x0 !== (x1 - 1n))) {
            x0 = x1;
            x1 = ((value / x0) + x0) >> 1n;
        }
        stack.push(x0);
    }
}
exports.Sqrt = Sqrt;
// Pops: None
// Pushes: uint64
// push the ID of the asset or application created in the Tth transaction of the current group
// gaid fails unless the requested transaction created an asset or application and T < GroupIndex.
class Gaid extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.interpreter = interpreter;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.txIndex = Number(args[0]);
    }
    ;
    execute(stack) {
        const knowableID = this.interpreter.runtime.ctx.knowableID.get(this.txIndex);
        if (knowableID === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.GROUP_INDEX_EXIST_ERROR, { index: this.txIndex, line: this.line });
        }
        stack.push(BigInt(knowableID));
    }
}
exports.Gaid = Gaid;
// Pops: ... stack, uint64
// Pushes: uint64
// push the ID of the asset or application created in the Xth transaction of the current group
// gaid fails unless the requested transaction created an asset or application and X < GroupIndex.
class Gaids extends Gaid {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // "11" is mock value, will be updated when poping from stack in execute
        super(["11", ...args], line, interpreter);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        this.txIndex = Number(this.assertBigInt(stack.pop(), this.line));
        super.execute(stack);
    }
}
exports.Gaids = Gaids;
// Pops: ... stack, []byte
// Pushes: []byte
// pop a byte-array A. Op code parameters:
// * S: number in 0..255, start index
// * L: number in 0..255, length
//  extracts a range of bytes from A starting at S up to but not including S+L,
// push the substring result. If L is 0, then extract to the end of the string.
// If S or S+L is larger than the array length, the program fails
class Extract extends opcode_1.Op {
    /**
     * Asserts 2 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, line);
        this.start = Number(args[0]);
        this.length = Number(args[1]);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const array = this.assertBytes(stack.pop(), this.line);
        // if length is 0, take bytes from start index to the end
        if (this.length === 0) {
            this.length = array.length - this.start;
        }
        stack.push(this.opExtractImpl(array, this.start, this.length));
    }
}
exports.Extract = Extract;
// Pops: ... stack, {[]byte A}, {uint64 S}, {uint64 L}
// Pushes: []byte
// pop a byte-array A and two integers S and L (both in 0..255).
// Extract a range of bytes from A starting at S up to but not including S+L,
// push the substring result. If S+L is larger than the array length, the program fails
class Extract3 extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 3, this.line);
        const length = this.assertUInt8(stack.pop(), this.line);
        const start = this.assertUInt8(stack.pop(), this.line);
        const array = this.assertBytes(stack.pop(), this.line);
        stack.push(this.opExtractImpl(array, start, length));
    }
}
exports.Extract3 = Extract3;
// Pops: ... stack, {[]byte A}, {uint64 S}
// Pushes: uint64
// Op code parameters:
// * N: number in {2,4,8}, length
// Base class to implement the extract_uint16, extract_uint32 and extract_uint64 op codes
// for N equal 2, 4, 8 respectively.
// pop a byte-array A and integer S (in 0..255). Extracts a range of bytes
// from A starting at S up to but not including B+N,
// convert bytes as big endian and push the uint(N*8) result.
// If B+N is larger than the array length, the program fails
class ExtractUintN extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.extractBytes = 2;
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
        // this.extractBytes = 2;
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const start = this.assertUInt8(stack.pop(), this.line);
        const array = this.assertBytes(stack.pop(), this.line);
        const sliced = this.opExtractImpl(array, start, this.extractBytes); // extract n bytes
        stack.push((0, parsing_1.bigEndianBytesToBigInt)(sliced));
    }
}
// Pops: ... stack, {[]byte A}, {uint64 B}
// Pushes: uint64
// pop a byte-array A and integer B. Extract a range of bytes
// from A starting at B up to but not including B+2,
// convert bytes as big endian and push the uint64 result.
// If B+2 is larger than the array length, the program fails
class ExtractUint16 extends ExtractUintN {
    constructor() {
        super(...arguments);
        this.extractBytes = 2;
    }
    execute(stack) {
        super.execute(stack);
    }
}
exports.ExtractUint16 = ExtractUint16;
// Pops: ... stack, {[]byte A}, {uint64 B}
// Pushes: uint64
// pop a byte-array A and integer B. Extract a range of bytes
// from A starting at B up to but not including B+4, convert
// bytes as big endian and push the uint64 result.
// If B+4 is larger than the array length, the program fails
class ExtractUint32 extends ExtractUintN {
    constructor() {
        super(...arguments);
        this.extractBytes = 4;
    }
    execute(stack) {
        super.execute(stack);
    }
}
exports.ExtractUint32 = ExtractUint32;
// Pops: ... stack, {[]byte A}, {uint64 B}
// Pushes: uint64
// pop a byte-array A and integer B. Extract a range of bytes from
// A starting at B up to but not including B+8, convert bytes as
// big endian and push the uint64 result. If B+8 is larger than
// the array length, the program fails
class ExtractUint64 extends ExtractUintN {
    constructor() {
        super(...arguments);
        this.extractBytes = 8;
    }
    execute(stack) {
        super.execute(stack);
    }
}
exports.ExtractUint64 = ExtractUint64;
// Pops: ... stack, {[]byte A}, {[]byte B}, {[]byte C}, {[]byte D}, {[]byte E}
// Pushes: uint64
// for (data A, signature B, C and pubkey D, E) verify the signature of the
// data against the pubkey => {0 or 1}
class EcdsaVerify extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.curveIndex = Number(args[0]);
    }
    ;
    /**
     * The 32 byte Y-component of a public key is the last element on the stack,
     * preceded by X-component of a pubkey, preceded by S and R components of a
     * signature, preceded by the data that is fifth element on the stack.
     * All values are big-endian encoded. The signed data must be 32 bytes long,
     * and signatures in lower-S form are only accepted.
     */
    execute(stack) {
        this.assertMinStackLen(stack, 5, this.line);
        const pubkeyE = this.assertBytes(stack.pop(), this.line);
        const pubkeyD = this.assertBytes(stack.pop(), this.line);
        const signatureC = this.assertBytes(stack.pop(), this.line);
        const signatureB = this.assertBytes(stack.pop(), this.line);
        const data = this.assertBytes(stack.pop(), this.line);
        if (this.curveIndex !== 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.CURVE_NOT_SUPPORTED, { line: this.line, index: this.curveIndex });
        }
        const ec = new elliptic_1.ec('secp256k1');
        const pub = { x: Buffer.from(pubkeyD).toString('hex'), y: Buffer.from(pubkeyE).toString('hex') };
        const key = ec.keyFromPublic(pub);
        const signature = { r: signatureB, s: signatureC };
        this.pushBooleanCheck(stack, key.verify(data, signature));
    }
}
exports.EcdsaVerify = EcdsaVerify;
// Pops: ... stack, []byte
// Pushes: ... stack, []byte, []byte
// decompress pubkey A into components X, Y => [... stack, X, Y]
class EcdsaPkDecompress extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.curveIndex = Number(args[0]);
    }
    ;
    /**
     * The 33 byte public key in a compressed form to be decompressed into X and Y (top)
     * components. All values are big-endian encoded.
     */
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const pubkeyCompressed = this.assertBytes(stack.pop(), this.line);
        if (this.curveIndex !== 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.CURVE_NOT_SUPPORTED, { line: this.line, index: this.curveIndex });
        }
        const ec = new elliptic_1.ec('secp256k1');
        const publicKeyUncompressed = ec.keyFromPublic(pubkeyCompressed, 'hex').getPublic();
        const x = publicKeyUncompressed.getX();
        const y = publicKeyUncompressed.getY();
        stack.push(x.toBuffer());
        stack.push(y.toBuffer());
    }
}
exports.EcdsaPkDecompress = EcdsaPkDecompress;
// Pops: ... stack, {[]byte A}, {uint64 B}, {[]byte C}, {[]byte D}
// Pushes: ... stack, []byte, []byte
// for (data A, recovery id B, signature C, D) recover a public key => [... stack, X, Y]
class EcdsaPkRecover extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [txIndex]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.curveIndex = Number(args[0]);
    }
    ;
    /**
    * S (top) and R elements of a signature, recovery id and data (bottom) are
    * expected on the stack and used to deriver a public key. All values are
    * big-endian encoded. The signed data must be 32 bytes long.
    */
    execute(stack) {
        this.assertMinStackLen(stack, 4, this.line);
        const signatureD = this.assertBytes(stack.pop(), this.line);
        const signatureC = this.assertBytes(stack.pop(), this.line);
        const recoverId = this.assertBigInt(stack.pop(), this.line);
        const data = this.assertBytes(stack.pop(), this.line);
        if (this.curveIndex !== 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.CURVE_NOT_SUPPORTED, { line: this.line, index: this.curveIndex });
        }
        const ec = new elliptic_1.ec('secp256k1');
        const signature = { r: signatureC, s: signatureD };
        const pubKey = ec.recoverPubKey(data, signature, Number(recoverId));
        const x = pubKey.getX();
        const y = pubKey.getY();
        stack.push(x.toBuffer());
        stack.push(y.toBuffer());
    }
}
exports.EcdsaPkRecover = EcdsaPkRecover;
// Pops: ...stack, any
// Pushes: any
// remove top of stack, and place it deeper in the stack such that
// N elements are above it. Fails if stack depth <= N.
class Cover extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [N]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.nthInStack = Number(args[0]);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, this.nthInStack + 1, this.line);
        const top = stack.pop();
        const temp = [];
        for (let count = 1; count <= this.nthInStack; ++count) {
            temp.push(stack.pop());
        }
        stack.push(top);
        for (let i = this.nthInStack - 1; i >= 0; --i) {
            stack.push(temp[i]);
        }
    }
}
exports.Cover = Cover;
// Pops: ... stack, any
// Pushes: any
// remove the value at depth N in the stack and shift above items down
// so the Nth deep value is on top of the stack. Fails if stack depth <= N.
class Uncover extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [N]
     * @param line line number in TEAL file
     */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.nthInStack = Number(args[0]);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, this.nthInStack + 1, this.line);
        const temp = [];
        for (let count = 0; count < this.nthInStack; ++count) {
            temp.push(stack.pop());
        }
        const deepValue = stack.pop();
        for (let i = this.nthInStack - 1; i >= 0; --i) {
            stack.push(temp[i]);
        }
        stack.push(deepValue);
    }
}
exports.Uncover = Uncover;
// Pops: ... stack, uint64
// Pushes: any
// copy a value from the Xth scratch space to the stack.
// All scratch spaces are 0 at program start.
class Loads extends Load {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // "11" is mock value, will be updated when poping from stack in execute
        super(["11", ...args], line, interpreter);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        this.index = Number(this.assertBigInt(stack.pop(), this.line));
        super.execute(stack);
    }
}
exports.Loads = Loads;
// Pops: ... stack, {uint64 A}, {any B}
// Pushes: None
// pop indexes A and B. store B to the Ath scratch space
class Stores extends opcode_1.Op {
    /**
     * Stores index number according to arguments passed
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, this.line);
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const value = stack.pop();
        const index = this.assertBigInt(stack.pop(), this.line);
        this.checkIndexBound(Number(index), this.interpreter.scratch, this.line);
        this.interpreter.scratch[Number(index)] = value;
    }
}
exports.Stores = Stores;
// Pops: None
// Pushes: None
// Begin preparation of a new inner transaction
class ITxnBegin extends opcode_1.Op {
    /**
     * Stores index number according to arguments passed
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, this.line);
        this.interpreter = interpreter;
    }
    execute(stack) {
        if (typeof this.interpreter.subTxn !== "undefined") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_BEGIN_WITHOUT_ITXN_SUBMIT, { line: this.line });
        }
        if (this.interpreter.innerTxns.length >= constants_1.MAX_INNER_TRANSACTIONS) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.MAX_INNER_TRANSACTIONS_EXCEEDED, {
                line: this.line,
                len: this.interpreter.innerTxns.length + 1,
                max: constants_1.MAX_INNER_TRANSACTIONS
            });
        }
        // get app, assert it exists
        const appID = this.interpreter.runtime.ctx.tx.apid ?? 0;
        this.interpreter.runtime.assertAppDefined(appID, this.interpreter.getApp(appID, this.line), this.line);
        // get application's account
        const address = (0, algosdk_1.getApplicationAddress)(appID);
        const applicationAccount = this.interpreter.runtime.assertAccountDefined(address, this.interpreter.runtime.ctx.state.accounts.get(address), this.line);
        // calculate feeCredit(extra fee) accross all txns
        let totalFee = 0;
        for (const t of this.interpreter.runtime.ctx.gtxs) {
            totalFee += (t.fee ?? 0);
        }
        ;
        for (const t of this.interpreter.innerTxns) {
            totalFee += (t.fee ?? 0);
        }
        const totalTxCnt = this.interpreter.runtime.ctx.gtxs.length + this.interpreter.innerTxns.length;
        const feeCredit = (totalFee - (algosdk_1.ALGORAND_MIN_TX_FEE * totalTxCnt));
        let txFee;
        if (feeCredit >= algosdk_1.ALGORAND_MIN_TX_FEE) {
            txFee = 0; // we have enough fee in pool
        }
        else {
            const diff = feeCredit - algosdk_1.ALGORAND_MIN_TX_FEE;
            txFee = (diff >= 0) ? diff : algosdk_1.ALGORAND_MIN_TX_FEE;
        }
        const txnParams = {
            // set sender, fee, fv, lv
            snd: Buffer.from(algosdk_1.default.decodeAddress(applicationAccount.address).publicKey),
            fee: txFee,
            fv: this.interpreter.runtime.ctx.tx.fv,
            lv: this.interpreter.runtime.ctx.tx.lv,
            // to avoid type hack
            gen: this.interpreter.runtime.ctx.tx.gen,
            gh: this.interpreter.runtime.ctx.tx.gh,
            txID: "",
            type: ""
        };
        this.interpreter.subTxn = txnParams;
    }
}
exports.ITxnBegin = ITxnBegin;
// Set field F of the current inner transaction to X(last value fetched from stack)
// itxn_field fails if X is of the wrong type for F, including a byte array
// of the wrong size for use as an address when F is an address field.
// itxn_field also fails if X is an account or asset that does not appear in txn.Accounts
// or txn.ForeignAssets of the top-level transaction.
// (Setting addresses in asset creation are exempted from this requirement.)
// pops from stack [...stack, any]
// push to stack [...stack, none]
class ITxnField extends opcode_1.Op {
    /**
     * Set transaction field according to arguments passed
     * @param args Expected arguments: [transaction field]
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.assertTxFieldDefined(args[0], interpreter.tealVersion, line);
        (0, parsing_1.assertLen)(args.length, 1, line);
        this.field = args[0]; // field
        this.interpreter = interpreter;
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const valToSet = stack.pop();
        if (typeof this.interpreter.subTxn === "undefined") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_FIELD_WITHOUT_ITXN_BEGIN, { line: this.line });
        }
        const updatedSubTx = (0, itxn_1.setInnerTxField)(this.interpreter.subTxn, this.field, valToSet, this, this.interpreter, this.line);
        this.interpreter.subTxn = updatedSubTx;
    }
}
exports.ITxnField = ITxnField;
// Pops: None
// Pushes: None
// Execute the current inner transaction.
class ITxnSubmit extends opcode_1.Op {
    /**
     * Stores index number according to arguments passed
     * @param args Expected arguments: []
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, this.line);
        this.interpreter = interpreter;
    }
    execute(stack) {
        if (typeof this.interpreter.subTxn === "undefined") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_SUBMIT_WITHOUT_ITXN_BEGIN, { line: this.line });
        }
        // calculate fee accross all txns
        let totalFee = 0;
        for (const t of this.interpreter.runtime.ctx.gtxs) {
            totalFee += (t.fee ?? 0);
        }
        ;
        for (const t of this.interpreter.innerTxns) {
            totalFee += (t.fee ?? 0);
        }
        totalFee += (this.interpreter.subTxn.fee ?? 0);
        const totalTxCnt = this.interpreter.runtime.ctx.gtxs.length + this.interpreter.innerTxns.length + 1;
        // fee too less accross pool
        const feeBal = (totalFee - (algosdk_1.ALGORAND_MIN_TX_FEE * totalTxCnt));
        if (feeBal < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.FEES_NOT_ENOUGH, {
                required: algosdk_1.ALGORAND_MIN_TX_FEE * totalTxCnt,
                collected: totalFee
            });
        }
        // get execution txn params (parsed from encoded sdk txn obj)
        const execParams = (0, itxn_1.parseEncodedTxnToExecParams)(this.interpreter.subTxn, this.interpreter, this.line);
        const baseCurrTx = this.interpreter.runtime.ctx.tx;
        const baseCurrTxGrp = this.interpreter.runtime.ctx.gtxs;
        // execute innner transaction
        this.interpreter.runtime.ctx.tx = this.interpreter.subTxn;
        this.interpreter.runtime.ctx.gtxs = [this.interpreter.subTxn];
        this.interpreter.runtime.ctx.isInnerTx = true;
        this.interpreter.runtime.ctx.processTransactions([execParams]);
        // update current txns to base (top-level) after innerTx execution
        this.interpreter.runtime.ctx.tx = baseCurrTx;
        this.interpreter.runtime.ctx.gtxs = baseCurrTxGrp;
        // save executed tx, reset current tx
        this.interpreter.runtime.ctx.isInnerTx = false;
        this.interpreter.innerTxns.push(this.interpreter.subTxn);
        this.interpreter.subTxn = undefined;
    }
}
exports.ITxnSubmit = ITxnSubmit;
// push field F of the last inner transaction to stack
// push to stack [...stack, transaction field]
class ITxn extends opcode_1.Op {
    /**
     * Set transaction field according to arguments passed
     * @param args Expected arguments: [transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.idx = undefined;
        this.assertITxFieldDefined(args[0], interpreter.tealVersion, line);
        if (constants_1.TxArrFields[interpreter.tealVersion].has(args[0])) { // eg. itxn Accounts 1
            (0, parsing_1.assertLen)(args.length, 2, line);
            (0, parsing_1.assertOnlyDigits)(args[1], line);
            this.idx = Number(args[1]);
        }
        else {
            (0, parsing_1.assertLen)(args.length, 1, line);
        }
        this.assertITxFieldDefined(args[0], interpreter.tealVersion, line);
        this.field = args[0]; // field
        this.interpreter = interpreter;
    }
    execute(stack) {
        if (this.interpreter.innerTxns.length === 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.NO_INNER_TRANSACTION_AVAILABLE, { version: this.interpreter.tealVersion, line: this.line });
        }
        let result;
        const tx = this.interpreter.innerTxns[this.interpreter.innerTxns.length - 1];
        switch (this.field) {
            case 'Logs': {
                // TODO handle this after log opcode is implemented
                // https://www.pivotaltracker.com/story/show/179855820
                result = 0n;
                break;
            }
            case 'NumLogs': {
                // TODO handle this after log opcode is implemented
                result = 0n;
                break;
            }
            case 'CreatedAssetID': {
                result = BigInt(this.interpreter.runtime.ctx.createdAssetID);
                break;
            }
            case 'CreatedApplicationID': {
                result = 0n; // can we create an app in inner-tx?
                break;
            }
            default: {
                // similarly as Txn Op
                if (this.idx !== undefined) { // if field is an array use txAppArg (with "Accounts"/"ApplicationArgs"/'Assets'..)
                    result = (0, txn_1.txAppArg)(this.field, tx, this.idx, this, this.interpreter.tealVersion, this.line);
                }
                else {
                    result = (0, txn_1.txnSpecbyField)(this.field, tx, [tx], this.interpreter.tealVersion);
                }
                break;
            }
        }
        stack.push(result);
    }
}
exports.ITxn = ITxn;
class ITxna extends opcode_1.Op {
    /**
     * Sets `field` and `idx` values according to arguments passed.
     * @param args Expected arguments: [transaction field, transaction field array index]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 2, line);
        (0, parsing_1.assertOnlyDigits)(args[1], line);
        this.assertITxArrFieldDefined(args[0], interpreter.tealVersion, line);
        this.field = args[0]; // field
        this.idx = Number(args[1]);
        this.interpreter = interpreter;
    }
    execute(stack) {
        if (this.interpreter.innerTxns.length === 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.NO_INNER_TRANSACTION_AVAILABLE, { version: this.interpreter.tealVersion, line: this.line });
        }
        const tx = this.interpreter.innerTxns[this.interpreter.innerTxns.length - 1];
        const result = (0, txn_1.txAppArg)(this.field, tx, this.idx, this, this.interpreter.tealVersion, this.line);
        stack.push(result);
    }
}
exports.ITxna = ITxna;
/**
 * txnas F:
 * push Xth value of the array field F of the current transaction
 * pops from stack: [...stack, uint64]
 * pushes to stack: [...stack, transaction field]
 */
class Txnas extends Txna {
    /**
     * Sets `field`, `txIdx` values according to arguments passed.
     * @param args Expected arguments: [transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // NOTE: 100 is a mock value.
        // In txnas & gtxnas opcodes, index is fetched from top of stack.
        // eg. [ int 1; txnas Accounts; ], [ txna Accounts 1].
        super([...args, "100"], line, interpreter);
        (0, parsing_1.assertLen)(args.length, 1, line);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        this.idx = Number(top);
        super.execute(stack);
    }
}
exports.Txnas = Txnas;
/**
 * gtxnas T F:
 * push Xth value of the array field F from the Tth transaction in the current group
 * pops from stack: [...stack, uint64]
 * push to stack [...stack, value of field]
 */
class Gtxnas extends Gtxna {
    /**
     * Sets `field`(Transaction Field) and
     * `txIdx`(Transaction Group Index) values according to arguments passed.
     * @param args Expected arguments: [transaction group index, transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // NOTE: 100 is a mock value.
        // In txnas & gtxnas opcodes, index is fetched from top of stack.
        // eg. [ int 1; gtxnas 0 Accounts; ], [ gtxna 0 Accounts 1].
        super([...args, "100"], line, interpreter);
        (0, parsing_1.assertLen)(args.length, 2, line);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        this.idx = Number(top);
        super.execute(stack);
    }
}
exports.Gtxnas = Gtxnas;
/**
 * gtxnsas F:
 * pop an index A and an index B. push Bth value of the array
 * field F from the Ath transaction in the current group
 * pops from stack: [...stack, {uint64 A}, {uint64 B}]
 * push to stack [...stack, value of field]
 */
class Gtxnsas extends Gtxna {
    /**
     * Sets `field`(Transaction Field)
     * @param args Expected arguments: [transaction field]
     * // Note: Transaction field is expected as string instead of number.
     * For ex: `Fee` is expected and `0` is not expected.
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        // NOTE: 100 is a mock value.
        // In gtxnsas opcode, {tx-index, index of array field} is fetched from top of stack.
        // eg. [ int 0; int 1; gtxnsas Accounts; ], [ gtxna 0 Accounts 1].
        super(["100", args[0], "100"], line, interpreter);
        (0, parsing_1.assertLen)(args.length, 1, line);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 2, this.line);
        const arrFieldIdx = this.assertBigInt(stack.pop(), this.line);
        const txIdxInGrp = this.assertBigInt(stack.pop(), this.line);
        this.idx = Number(arrFieldIdx);
        this.txIdx = Number(txIdxInGrp);
        super.execute(stack);
    }
}
exports.Gtxnsas = Gtxnsas;
// pushes Arg[N] from LogicSig argument array to stack
// Pops: ... stack, uint64
// push to stack [...stack, bytes]
class Args extends Arg {
    /**
     * Gets the argument value from interpreter.args array.
     * store the value in _arg variable
     * @param args Expected arguments: none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super([...args, "100"], line, interpreter);
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const top = this.assertBigInt(stack.pop(), this.line);
        this.index = Number(top);
        super.execute(stack);
    }
}
exports.Args = Args;
// Write bytes to log state of the current application
// pops to stack [...stack, bytes]
// Pushes: None
class Log extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.interpreter = interpreter;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const logByte = this.assertBytes(stack.pop(), this.line);
        const txID = this.interpreter.runtime.ctx.tx.txID;
        const txReceipt = this.interpreter.runtime.ctx.state.txReceipts.get(txID);
        if (txReceipt.logs === undefined) {
            txReceipt.logs = [];
        }
        // max no. of logs exceeded
        if (txReceipt.logs.length === constants_1.ALGORAND_MAX_LOGS_COUNT) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.LOGS_COUNT_EXCEEDED_THRESHOLD, {
                maxLogs: constants_1.ALGORAND_MAX_LOGS_COUNT,
                line: this.line
            });
        }
        // max "length" of logs exceeded
        const length = txReceipt.logs.join("").length + logByte.length;
        if (length > constants_1.ALGORAND_MAX_LOGS_LENGTH) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.LOGS_LENGTH_EXCEEDED_THRESHOLD, {
                maxLength: constants_1.ALGORAND_MAX_LOGS_LENGTH,
                origLength: length,
                line: this.line
            });
        }
        txReceipt.logs.push((0, parsing_1.convertToString)(logByte));
    }
}
exports.Log = Log;
// bitlen interprets arrays as big-endian integers, unlike setbit/getbit
// stack = [..., any]
// push to stack = [..., bitlen]
class BitLen extends opcode_1.Op {
    /**
     * Asserts 0 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
    */
    constructor(args, line) {
        super();
        this.line = line;
        (0, parsing_1.assertLen)(args.length, 0, line);
    }
    ;
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const value = stack.pop();
        let bitlen = 0;
        if (typeof value === "bigint") {
            bitlen = (value === 0n) ? 0 : value.toString(2).length;
        }
        else {
            // value is Uint8 => one element have 8 bits.
            // => bitlen = 8 * value.length - 1 + bitlen(first element)
            if (value.length > 0) {
                bitlen = (value.length - 1) * 8;
                bitlen += value[0].toString(2).length;
            }
        }
        stack.push(BigInt(bitlen));
    }
}
exports.BitLen = BitLen;
// get App Params Information
// push to stack [...stack, value(bigint/bytes), did_exist]
// NOTE: if app doesn't exist, then did_exist = 0, value = 0
class AppParamsGet extends opcode_1.Op {
    /**
     * Asserts 1 arguments are passed.
     * @param args Expected arguments: [] // none
     * @param line line number in TEAL file
     * @param interpreter interpreter object
     */
    constructor(args, line, interpreter) {
        super();
        this.line = line;
        this.interpreter = interpreter;
        (0, parsing_1.assertLen)(args.length, 1, line);
        if (!constants_1.AppParamDefined[interpreter.tealVersion].has(args[0])) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.UNKNOWN_APP_FIELD, {
                field: args[0],
                line: line,
                tealV: interpreter.tealVersion
            });
        }
        this.field = args[0];
    }
    execute(stack) {
        this.assertMinStackLen(stack, 1, this.line);
        const appID = this.assertBigInt(stack.pop(), this.line);
        if (this.interpreter.runtime.ctx.state.globalApps.has(Number(appID))) {
            let value = 0n;
            const appDef = this.interpreter.getApp(Number(appID), this.line);
            switch (this.field) {
                case "AppApprovalProgram":
                    value = web_1.parsing.stringToBytes(appDef["approval-program"]);
                    break;
                case "AppClearStateProgram":
                    value = web_1.parsing.stringToBytes(appDef["clear-state-program"]);
                    break;
                case "AppGlobalNumUint":
                    value = BigInt(appDef["global-state-schema"].numUint);
                    break;
                case "AppGlobalNumByteSlice":
                    value = BigInt(appDef["global-state-schema"].numByteSlice);
                    break;
                case "AppLocalNumUint":
                    value = BigInt(appDef["local-state-schema"].numUint);
                    break;
                case "AppLocalNumByteSlice":
                    value = BigInt(appDef["local-state-schema"].numByteSlice);
                    break;
                case "AppExtraProgramPages":
                    // only return default number extra program pages in runtime
                    // should fix it in future.
                    value = 1n;
                    break;
                case "AppCreator":
                    value = (0, algosdk_1.decodeAddress)(appDef.creator).publicKey;
                    break;
                case "AppAddress":
                    value = (0, algosdk_1.decodeAddress)((0, algosdk_1.getApplicationAddress)(appID)).publicKey;
            }
            ;
            stack.push(value);
            stack.push(1n);
        }
        else {
            stack.push(0n);
            stack.push(0n);
        }
    }
    ;
}
exports.AppParamsGet = AppParamsGet;
;
//# sourceMappingURL=opcode-list.js.map