"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WallectConnectSession = void 0;
const utils_1 = require("@json-rpc-tools/utils");
const client_1 = __importDefault(require("@walletconnect/client"));
const algorand_walletconnect_qrcode_modal_1 = __importDefault(require("algorand-walletconnect-qrcode-modal"));
const algosdk_1 = __importDefault(require("algosdk"));
const api_1 = require("./api");
const constants_1 = require("./constants");
const txn_1 = require("./txn");
const CONFIRMED_ROUND = "confirmed-round";
const LAST_ROUND = "last-round";
class WallectConnectSession {
    constructor(chain, connector) {
        this.algodClient = (0, api_1.clientForChain)(chain);
        if (connector) {
            this.connector = connector;
        }
        else {
            // create new session
            this.connector = new client_1.default({
                bridge: "https://bridge.walletconnect.org",
                qrcodeModal: algorand_walletconnect_qrcode_modal_1.default
            });
        }
        // if connection not already established, log message to create one
        if (!this.connector.connected) {
            console.warn(`Connection not established, please use "this.create()" to create new session`);
        }
        this.wcAccounts = this.connector.accounts;
    }
    /**
     * Create new session
     * @param force if true, kills an existing session and creates new one.
     * By default force is false
     */
    async create(force = false) {
        if (this.connector.connected) {
            if (force) {
                try {
                    await this.close();
                }
                catch (e) { }
                ;
            }
            else {
                console.warn(`A session is already active`);
                return;
            }
        }
        await this.connector.createSession();
    }
    /**
     * Close Connection
     */
    async close() {
        await this.connector.killSession();
    }
    /**
     * On connect subscription event
     * @param handler handler callback
     */
    onConnect(handler) {
        this.connector.on("connect", (err, payload) => {
            const { wcPeerId, wcPeerMeta, wcAccounts } = payload.params[0];
            this.wcAccounts = wcAccounts;
            handler(err, { wcPeerId, wcPeerMeta, wcAccounts });
        });
    }
    /**
     * onUpdate subscription event
     * @param handler handler callback
     */
    onUpdate(handler) {
        this.connector.on("session_update", (err, payload) => {
            const { wcAccounts } = payload.params[0];
            this.wcAccounts = wcAccounts;
            handler(err, { wcAccounts });
        });
    }
    /**
     * onDisconnect subscription event
     * @param handler handler callback
     */
    onDisconnect(handler) {
        this.connector.on("disconnect", (err, payload) => {
            const { message } = payload.params[0];
            handler(err, { message });
        });
    }
    /**
     * Sign a single transaction from a wallect connect session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @param message optional message with txn
     * @returns raw signed txn
     */
    async signTransaction(txn, message) {
        const txnInGroup = {
            txn,
            shouldSign: true
        };
        const response = await this.signTransactionGroup([txnInGroup], message);
        if (response[0] == null) {
            throw new Error("Transaction was returned unsigned");
        }
        return response[0];
    }
    /**
     * Sign a group of transaction(s) from a wallect connect session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @param message optional message with txn
     * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed
     * by wallet user (i.e signable by someone else).
     * TODO: handle case of multiple signers in group transaction
     */
    async signTransactionGroup(txns, message) {
        const walletTxns = txns.map(txn => {
            const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn.txn)).toString("base64");
            let signers;
            if (txn.shouldSign) {
                if (Array.isArray(txn.signers)) {
                    signers = txn.signers;
                }
                else if (txn.signers) {
                    signers = [txn.signers];
                }
                else {
                    signers = undefined;
                }
            }
            else {
                signers = [];
            }
            return {
                signers,
                txn: encodedTxn,
                message: txn.message,
                msig: txn.msig
            };
        });
        const requestParams = [walletTxns];
        console.log('requestParams ', requestParams);
        if (message) {
            requestParams.push({ message });
        }
        const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);
        const result = await this.connector.sendCustomRequest(request);
        return result.map(element => {
            return element ? new Uint8Array(Buffer.from(element, "base64")) : null;
        });
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    async sendAndWait(rawTxns) {
        const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
        return await this.waitForConfirmation(txInfo.txId);
    }
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const response = await this.algodClient.status().do();
        let lastround = response[LAST_ROUND];
        while (true) {
            const pendingInfo = await this.algodClient.pendingTransactionInformation(txId).do();
            if (pendingInfo["pool-error"]) {
                throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
            }
            if (pendingInfo[CONFIRMED_ROUND] !== null && pendingInfo[CONFIRMED_ROUND] > 0) {
                return pendingInfo;
            }
            lastround++;
            await this.algodClient.statusAfterBlock(lastround).do();
        }
    }
    ;
    /**
   * Execute single transaction or group of transactions (atomic transaction)
   * @param execParams transaction parameters or atomic transaction parameters
   */
    async executeTransaction(execParams) {
        let signedTxn;
        let txns = [];
        let confirmedTx;
        if (Array.isArray(execParams)) {
            if (execParams.length > 16) {
                throw new Error("Maximum size of an atomic transfer group is 16");
            }
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, await (0, api_1.mkTxParams)(this.algodClient, txn.payFlags)));
            }
            txns = algosdk_1.default.assignGroupID(txns);
            const toBeSignedTxns = txns.map((txn) => {
                return { txn: txn, shouldSign: true };
            });
            signedTxn = await this.signTransactionGroup(toBeSignedTxns);
            // remove null values from signed txns array
            // TODO: replace null values with "externally" signed txns, otherwise
            // signedtxns with nulls will always fail!
            signedTxn = signedTxn.filter(stxn => stxn);
            confirmedTx = await this.sendAndWait(signedTxn);
        }
        else {
            const txn = (0, txn_1.mkTransaction)(execParams, await (0, api_1.mkTxParams)(this.algodClient, execParams.payFlags));
            signedTxn = await this.signTransaction(txn);
            confirmedTx = await this.sendAndWait(signedTxn);
        }
        console.log('confirmedTx: ', confirmedTx);
        return confirmedTx;
    }
}
exports.WallectConnectSession = WallectConnectSession;
//# sourceMappingURL=wallectconnect-mode.js.map