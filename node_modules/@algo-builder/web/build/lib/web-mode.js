"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebMode = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const txn_1 = require("./txn");
const CONFIRMED_ROUND = "confirmed-round";
const LAST_ROUND = "last-round";
class WebMode {
    constructor(algoSigner, chainName) {
        this.algoSigner = algoSigner;
        this.chainName = chainName;
    }
    /**
     * wait for confirmation for transaction using transaction id
     * @param txId Transaction id
     */
    async waitForConfirmation(txId) {
        const response = await this.algoSigner.algod({
            ledger: this.chainName,
            path: '/v2/status'
        });
        console.log(response);
        let lastround = response[LAST_ROUND];
        while (true) {
            const pendingInfo = await this.algoSigner.algod({
                ledger: this.chainName,
                path: `/v2/transactions/pending/${txId}`
            });
            if (pendingInfo[CONFIRMED_ROUND] !== null &&
                pendingInfo[CONFIRMED_ROUND] > 0) {
                return pendingInfo;
            }
            lastround++;
            await this.algoSigner.algod({
                ledger: this.chainName,
                path: `/v2/status/wait-for-block-after/${lastround}` // eslint-disable-line @typescript-eslint/restrict-template-expressions
            });
        }
    }
    /**
     * Send transaction to network
     * @param signedTxn signed transaction
     */
    async sendTransaction(signedTxn) {
        return await this.algoSigner.send({
            ledger: this.chainName,
            tx: signedTxn.blob
        });
    }
    /**
     * Send group transaction to network
     * @param signedTxs signed transaction group
     */
    async sendGroupTransaction(signedTxs) {
        // The AlgoSigner.signTxn() response would look like '[{ txID, blob }, null]'
        // Convert first transaction to binary from the response
        const signedTxBinary = signedTxs.map((txn) => {
            return this.algoSigner.encoding.base64ToMsgpack(txn.blob);
        });
        // Merge transaction binaries into a single Uint8Array
        const flatNumberArray = signedTxBinary.reduce((acc, curr) => {
            acc.push(...curr);
            return acc;
        }, []);
        const combinedBinaryTxns = new Uint8Array(flatNumberArray);
        // Convert the combined array values back to base64
        const combinedBase64Txns = this.algoSigner.encoding.msgpackToBase64(combinedBinaryTxns);
        return await this.algoSigner.send({
            ledger: this.chainName,
            tx: combinedBase64Txns
        });
    }
    /**
     * Sign transaction using algosigner
     * @param txns Array of transactions in base64
     */
    async signTransaction(txns) {
        return await this.algoSigner.signTxn(txns);
    }
    /**
     * Returns suggested transaction parameters using algosigner
     * @param userParams Transaction parameters
     */
    async getSuggestedParams(userParams) {
        const txParams = await this.algoSigner.algod({
            ledger: this.chainName,
            path: '/v2/transactions/params'
        });
        const s = {
            fee: txParams.fee,
            genesisHash: txParams["genesis-hash"],
            genesisID: txParams["genesis-id"],
            firstRound: txParams[LAST_ROUND],
            lastRound: Number(txParams[LAST_ROUND]) + 1000,
            flatFee: false
        };
        s.flatFee = userParams.totalFee !== undefined;
        s.fee = userParams.totalFee || userParams.feePerByte || txParams["min-fee"]; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
        if (s.flatFee)
            s.fee = Math.max(Number(s.fee), Number(txParams["min-fee"]));
        s.firstRound = userParams.firstValid || s.firstRound; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
        s.lastRound = userParams.firstValid === undefined || userParams.validRounds === undefined // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
            ? s.lastRound
            : Number(userParams.firstValid) + Number(userParams.validRounds);
        return s;
    }
    /**
   * Execute single transaction or group of transactions (atomic transaction)
   * @param execParams transaction parameters or atomic transaction parameters
   */
    async executeTransaction(execParams) {
        let signedTxn;
        let txInfo;
        let txns = [];
        if (Array.isArray(execParams)) {
            if (execParams.length > 16) {
                throw new Error("Maximum size of an atomic transfer group is 16");
            }
            for (const [_, txn] of execParams.entries()) {
                txns.push(await (0, txn_1.mkTransaction)(txn, await this.getSuggestedParams(txn.payFlags)));
            }
            txns = algosdk_1.default.assignGroupID(txns);
            const binaryTxs = txns.map((txn) => {
                return txn.toByte();
            });
            const base64Txs = binaryTxs.map((txn) => {
                return this.algoSigner.encoding.msgpackToBase64(txn);
            });
            const toBeSignedTxns = base64Txs.map((txn) => {
                return { txn: txn };
            });
            signedTxn = await this.signTransaction(toBeSignedTxns);
            txInfo = await this.sendGroupTransaction(signedTxn);
        }
        else {
            const txn = await (0, txn_1.mkTransaction)(execParams, await this.getSuggestedParams(execParams.payFlags));
            const toBeSignedTxn = this.algoSigner.encoding.msgpackToBase64(txn.toByte());
            signedTxn = await this.signTransaction([{ txn: toBeSignedTxn }]);
            txInfo = await this.sendTransaction(signedTxn[0]);
        }
        if (txInfo && typeof txInfo.txId === "string") {
            return await this.waitForConfirmation(txInfo.txId);
        }
        throw new Error("Transaction Error");
    }
}
exports.WebMode = WebMode;
//# sourceMappingURL=web-mode.js.map