"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAppArgs = exports.addressToPk = exports.uint64ToBigEndian = exports.stringToBytes = void 0;
const algosdk_1 = require("algosdk");
const constants_1 = require("./constants");
// verify n is an unsigned 64 bit integer
function assertUint64(n) {
    if (n < constants_1.MIN_UINT64 || n > constants_1.MAX_UINT64) {
        throw new Error(`Invalid uint64 ${n}`);
    }
}
// parse string to Uint8Array
function stringToBytes(s) {
    return new Uint8Array(Buffer.from(s));
}
exports.stringToBytes = stringToBytes;
/**
 * Converts 64 bit unsigned integer to bytes in big endian.
 */
function uint64ToBigEndian(x) {
    assertUint64(BigInt(x));
    return (0, algosdk_1.encodeUint64)(x);
}
exports.uint64ToBigEndian = uint64ToBigEndian;
/**
 * Takes an Algorand address in string form and decodes it into a Uint8Array (as public key)
 * @param addr : algorand address
 */
function addressToPk(addr) {
    return (0, algosdk_1.decodeAddress)(addr).publicKey;
}
exports.addressToPk = addressToPk;
const throwFmtError = (appArg) => {
    throw new Error(`Format of arguments passed to stateful smart is invalid for ${appArg}`);
};
/**
 * Parses appArgs to bytes if arguments passed to App are similar to goal ('int:1', 'str:hello'..)
 * https://developer.algorand.org/docs/features/asc1/stateful/#passing-arguments-to-stateful-smart-contracts
 * eg. "int:1" => new Uint8Aarray([0, 0, 0, 0, 0, 0, 0, 1])
 * NOTE: parseAppArgs returns undefined to handle the case when application args passed to
 * stateful smart contract is undefined
 * @param appArgs : arguments to stateful smart contract
 */
function parseAppArgs(appArgs) {
    if (appArgs === undefined) {
        return undefined;
    }
    const args = [];
    for (const appArg of appArgs) {
        // if appArg already bytes, then we don't need to parse
        // just push to array and continue
        if (appArg instanceof Uint8Array) {
            args.push(appArg);
            continue;
        }
        // eg "int:1" => ['int', '1']
        const i = appArg.indexOf(':');
        const [type, value] = [appArg.slice(0, i), appArg.slice(i + 1)];
        // if given string is not invalid, throw error
        if (type === undefined || value === undefined) {
            throwFmtError(appArg);
        }
        // parse string to bytes according to type
        let arg;
        switch (type) {
            case 'int': {
                if (!constants_1.reDigit.test(value)) {
                    throwFmtError(appArg);
                } // verify only digits are present in string
                arg = uint64ToBigEndian(BigInt(value));
                break;
            }
            case 'str': {
                arg = stringToBytes(value);
                break;
            }
            case 'addr': {
                arg = addressToPk(value);
                break;
            }
            case 'b64': {
                arg = new Uint8Array(Buffer.from(value, 'base64'));
                break;
            }
            default: {
                throwFmtError(appArg);
            }
        }
        args.push(arg);
    }
    ;
    return args;
}
exports.parseAppArgs = parseAppArgs;
//# sourceMappingURL=parsing.js.map