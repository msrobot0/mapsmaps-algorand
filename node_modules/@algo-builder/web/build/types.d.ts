import { IClientMeta } from '@walletconnect/types';
import { Account as AccountSDK, LogicSigAccount, Transaction } from 'algosdk';
import * as z from 'zod';
import { WalletMultisigMetadata, WalletTransaction } from './algo-signer-types';
import type { ASADefSchema, ASADefsSchema } from "./types-input";
export declare type AccountAddress = string;
export interface AnyMap {
    [key: string]: any;
}
/**
 * After an asset has been created only the manager,
 * reserve, freeze and reserve accounts can be changed.
 * All other parameters are locked for the life of the asset.
 */
export interface AssetModFields {
    manager?: string;
    reserve?: string;
    freeze?: string;
    clawback?: string;
}
/**
 * Common transaction parameters (fees, note..) */
export interface TxParams {
    /**
     * feePerByte or totalFee is used to set the appropriate transaction fee parameter.
     * If both are set then totalFee takes precedence.
     * NOTE: SDK expects`fee: number` and boolean `flatFee`. But the API expects only one
     * on parameter: `fee`. Here, we define feePerByte and totalFee - both as numberic
     * parameters. We think that this is more explicit. */
    feePerByte?: number;
    totalFee?: number;
    flatFee?: boolean;
    firstValid?: number;
    validRounds?: number;
    lease?: Uint8Array;
    note?: string;
    noteb64?: string;
    closeRemainderTo?: AccountAddress;
    rekeyTo?: AccountAddress;
}
/**
 * Stateful Smart contract flags for specifying sender and schema */
export interface AppDeploymentFlags extends AppOptionalFlags {
    sender: AccountSDK;
    localInts: number;
    localBytes: number;
    globalInts: number;
    globalBytes: number;
    extraPages?: number;
}
/**
 * Stateful smart contract transaction optional parameters (accounts, args..). */
export interface AppOptionalFlags {
    /**
     * Transaction specific arguments accessed from
     * the application's approval-program and clear-state-program.
     */
    appArgs?: Array<Uint8Array | string>;
    /**
     * List of accounts in addition to the sender that may
     * be accessed from the application's approval-program and clear-state-program.
     */
    accounts?: string[];
    /**
     * Lists the applications in addition to the application-id
     * whose global states may be accessed by this
     * application's approval-program and clear-state-program. The access is read-only.
     */
    foreignApps?: number[];
    /**
     * Lists the assets whose AssetParams may be accessed by
     * this application's approval-program and clear-state-program.
     * The access is read-only.
     */
    foreignAssets?: number[];
    note?: Uint8Array;
    lease?: Uint8Array;
}
/**
 * Transaction execution parameters (on blockchain OR runtime) */
export declare type ExecParams = AlgoTransferParam | AssetTransferParam | AppCallsParam | ModifyAssetParam | FreezeAssetParam | RevokeAssetParam | DestroyAssetParam | DeployASAParam | DeployAppParam | OptInASAParam | UpdateAppParam;
export declare enum SignType {
    SecretKey = 0,
    LogicSignature = 1
}
export declare enum TransactionType {
    TransferAlgo = 0,
    TransferAsset = 1,
    ModifyAsset = 2,
    FreezeAsset = 3,
    RevokeAsset = 4,
    DestroyAsset = 5,
    CallApp = 6,
    ClearApp = 7,
    CloseApp = 8,
    DeleteApp = 9,
    DeployASA = 10,
    DeployApp = 11,
    OptInASA = 12,
    OptInToApp = 13,
    UpdateApp = 14
}
interface SignWithSk {
    sign: SignType.SecretKey;
    fromAccount: AccountSDK;
    /**
     * if passed then it will be used as the from account address, but tx will be signed
     * by fromAcount's sk. This is used if an account address is rekeyed to another account. */
    fromAccountAddr?: AccountAddress;
}
interface SignWithLsig {
    sign: SignType.LogicSignature;
    fromAccount?: AccountSDK;
    fromAccountAddr: AccountAddress;
    lsig: LogicSigAccount;
    /** stateless smart contract args */
    args?: Uint8Array[];
}
export declare type Sign = SignWithSk | SignWithLsig;
export declare type BasicParams = Sign & {
    payFlags: TxParams;
};
export declare type DeployASAParam = BasicParams & {
    type: TransactionType.DeployASA;
    asaName: string;
    asaDef?: ASADef;
    overrideAsaDef?: Partial<ASADef>;
};
export declare type DeployAppParam = BasicParams & AppOptionalFlags & {
    type: TransactionType.DeployApp;
    approvalProgram: string;
    clearProgram: string;
    localInts: number;
    localBytes: number;
    globalInts: number;
    globalBytes: number;
    extraPages?: number;
    approvalProg?: Uint8Array;
    clearProg?: Uint8Array;
    appName?: string;
};
export declare type UpdateAppParam = BasicParams & AppOptionalFlags & {
    type: TransactionType.UpdateApp;
    appID: number;
    newApprovalProgram: string;
    newClearProgram: string;
    approvalProg?: Uint8Array;
    clearProg?: Uint8Array;
    appName?: string;
};
export declare type AppCallsParam = BasicParams & AppOptionalFlags & {
    type: TransactionType.CallApp | TransactionType.ClearApp | TransactionType.CloseApp | TransactionType.DeleteApp | TransactionType.OptInToApp;
    appID: number;
};
export declare type OptInASAParam = BasicParams & {
    type: TransactionType.OptInASA;
    assetID: number | string;
};
export declare type ModifyAssetParam = BasicParams & {
    type: TransactionType.ModifyAsset;
    assetID: number | string;
    fields: AssetModFields;
};
export declare type FreezeAssetParam = BasicParams & {
    type: TransactionType.FreezeAsset;
    assetID: number | string;
    freezeTarget: AccountAddress;
    freezeState: boolean;
};
export declare type RevokeAssetParam = BasicParams & {
    type: TransactionType.RevokeAsset;
    /**
     * Revoked assets are sent to this address
     */
    recipient: AccountAddress;
    assetID: number | string;
    /** Revocation target is the account from which the clawback revokes asset. */
    revocationTarget: AccountAddress;
    amount: number | bigint;
};
export declare type DestroyAssetParam = BasicParams & {
    type: TransactionType.DestroyAsset;
    assetID: number | string;
};
export declare type AlgoTransferParam = BasicParams & {
    type: TransactionType.TransferAlgo;
    toAccountAddr: AccountAddress;
    amountMicroAlgos: number | bigint;
};
export declare type AssetTransferParam = BasicParams & {
    type: TransactionType.TransferAsset;
    toAccountAddr: AccountAddress;
    amount: number | bigint;
    assetID: number | string;
};
export interface TransactionAndSign {
    transaction: Transaction;
    sign: Sign;
}
export declare type ASADef = z.infer<typeof ASADefSchema>;
export declare type ASADefs = z.infer<typeof ASADefsSchema>;
export interface RequestError extends Error {
    response?: {
        statusCode: number;
        text: string;
        body: {
            message: string;
        };
        error?: Error;
    };
    error?: Error;
}
export interface FileError extends Error {
    errno: number;
}
export declare function isFileError(object: unknown): object is FileError;
export declare function isRequestError(object: unknown): object is RequestError;
export declare function isSDKTransaction(object: unknown): object is Transaction;
export declare function isSDKTransactionAndSign(object: unknown): object is TransactionAndSign;
export declare enum ChainType {
    MainNet = "MainNet",
    TestNet = "TestNet"
}
export interface SessionConnectResponse {
    wcPeerId: string;
    wcPeerMeta?: IClientMeta;
    wcAccounts: string[];
}
export interface SessionUpdateResponse {
    wcAccounts: string[];
}
export interface SessionDisconnectResponse {
    message?: string;
}
export interface SignTxnOpts {
    /**
       * Optional message explaining the reason of the group of
       * transactions.
       */
    message?: string;
}
export declare type SignTxnParams = [WalletTransaction[], SignTxnOpts?];
export interface TransactionInGroup {
    txn: Transaction;
    shouldSign?: boolean;
    signers?: string | string[];
    msig?: WalletMultisigMetadata;
    message?: string;
}
export {};
