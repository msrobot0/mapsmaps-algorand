"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_1 = require("@algo-builder/runtime");
const algosdk_1 = require("algosdk");
const path_1 = __importDefault(require("path"));
const config_env_1 = require("../internal/core/config/config-env");
const project_structure_1 = require("../internal/core/project-structure");
const files_1 = require("../lib/files");
const msig_1 = require("../lib/msig");
const gen_accounts_1 = require("./gen-accounts");
const task_names_1 = require("./task-names");
async function multiSignTx(taskArgs, runtimeEnv) {
    const signerAccount = runtimeEnv.network.config.accounts.find(acc => acc.name === taskArgs.account);
    if (signerAccount === undefined) {
        console.error(`No account with the name "${taskArgs.account}" exists in the config file.`);
        return;
    }
    let rawTxn = (0, files_1.loadEncodedTxFromFile)(taskArgs.file); // single tx OR tx group
    if (rawTxn === undefined) {
        console.error("Error loading transaction from the file.");
        return;
    }
    const groupIndex = Number(taskArgs.groupIndex) ?? 0;
    const decodedTx = (0, algosdk_1.decodeObj)(rawTxn);
    if (Array.isArray(decodedTx)) {
        rawTxn = decodedTx[groupIndex]; // set "this" tx for signing in case of txgroup
    }
    const sourceFilePath = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, taskArgs.file);
    let mparams;
    const { v, thr, addrs } = taskArgs;
    if (v && thr && addrs) {
        mparams = { version: Number(v), threshold: Number(thr), addrs: addrs.split(',') };
    }
    const signedTxn = (0, msig_1.signMultiSig)(signerAccount, rawTxn, mparams);
    const [name, ext] = taskArgs.file.split(".");
    const outFileName = taskArgs.out ?? (name + "_out." + ext);
    const outFilePath = path_1.default.join(path_1.default.dirname(sourceFilePath), outFileName);
    let outData;
    if (Array.isArray(decodedTx)) {
        decodedTx[groupIndex] = signedTxn.blob;
        outData = (0, algosdk_1.encodeObj)(decodedTx);
    }
    else {
        outData = signedTxn.blob;
    }
    await (0, gen_accounts_1.writeToFile)(outData, taskArgs.force, outFilePath);
}
function default_1() {
    (0, config_env_1.task)(task_names_1.TASK_SIGN_MULTISIG, "Signs a transaction object from a file using Multi Signature")
        .addParam("account", "Name of the account (present in `algob.config.js`) to be used for signing the transaction.")
        .addParam("file", "Name of the transaction file in assets directory")
        .addOptionalParam("out", "Name of the file to be used for resultant transaction file.\n\t\tIf not provided source transaction file's name will be appended by \"_out\"\n")
        .addOptionalParam("v", "Multisig version (required if creating a new signed multisig transaction)")
        .addOptionalParam("thr", "Multisig threshold (required if creating a new signed multisig transaction)")
        .addOptionalParam("addrs", "Comma separated addresses comprising of the multsig (addr1,addr2,..). Order is important. \n\t\t(required if creating a new signed multisig transaction)\n")
        .addOptionalParam("groupIndex", "Index of transaction (0 indexed) to sign if file has an encoded transaction group. Defaults to 0.")
        .addFlag("force", "Overwrite output transaction file if the file already exists.")
        .setAction((input, env) => multiSignTx(input, env));
}
exports.default = default_1;
//# sourceMappingURL=sign-multisig.js.map