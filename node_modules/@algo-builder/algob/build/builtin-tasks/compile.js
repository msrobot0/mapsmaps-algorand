"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = void 0;
const runtime_1 = require("@algo-builder/runtime");
const path_1 = __importDefault(require("path"));
const config_env_1 = require("../internal/core/config/config-env");
const project_structure_1 = require("../internal/core/project-structure");
const comparators_1 = require("../lib/comparators");
const compile_1 = require("../lib/compile");
const driver_1 = require("../lib/driver");
const task_names_1 = require("./task-names");
const ALGOBPY_DIR = 'algobpy';
function default_1() {
    (0, config_env_1.task)(task_names_1.TASK_COMPILE, "Compile all TEAL smart contracts")
        .addFlag("force", "recompile even if the source file didn't change")
        .setAction(compileTask);
}
exports.default = default_1;
function compileTask({ force }, env) {
    const op = new compile_1.CompileOp((0, driver_1.createClient)(env.network));
    return compile(force, op);
}
async function compile(force, op) {
    await (0, project_structure_1.assertDir)(project_structure_1.CACHE_DIR);
    const paths = (0, runtime_1.lsTreeWalk)(project_structure_1.ASSETS_DIR);
    for (const p of paths.sort(comparators_1.cmpStr)) {
        const f = path_1.default.basename(p);
        if ((!f.endsWith(compile_1.tealExt) && !f.endsWith(compile_1.pyExt)) || p.includes(ALGOBPY_DIR)) {
            continue;
        }
        await op.ensureCompiled(f, force);
    }
}
exports.compile = compile;
//# sourceMappingURL=compile.js.map