"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runMultipleScripts = exports.splitAfter = exports.filterNonExistent = void 0;
const web_1 = require("@algo-builder/web");
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_env_1 = require("../internal/core/config/config-env");
const deployer_cfg_1 = require("../internal/deployer_cfg");
const tx_log_writer_1 = require("../internal/tx-log-writer");
const lists_1 = require("../internal/util/lists");
const scripts_runner_1 = require("../internal/util/scripts-runner");
const algo_operator_1 = require("../lib/algo-operator");
const comparators_1 = require("../lib/comparators");
const files_1 = require("../lib/files");
const script_checkpoints_1 = require("../lib/script-checkpoints");
const task_names_1 = require("./task-names");
function filterNonExistent(scripts) {
    return scripts.filter(script => !fs_extra_1.default.pathExistsSync(script));
}
exports.filterNonExistent = filterNonExistent;
// returns all items before the current one and
// mutates the original array to remove them
function splitAfter(scriptsFromScriptsDir, splitAfterScript) {
    for (let i = 0; i < scriptsFromScriptsDir.length; i++) {
        const scriptName = scriptsFromScriptsDir[i];
        if (scriptName === splitAfterScript) {
            return scriptsFromScriptsDir.splice(0, i + 1);
        }
    }
    return scriptsFromScriptsDir.splice(0, scriptsFromScriptsDir.length);
}
exports.splitAfter = splitAfter;
/** Partitions an unsorted string list into sorted parts:
    `[1 2 2 3 4 3 4 2 1]` returns `[[1 2 2 3 4] [3 4] [2] [1]]` */
function partitionIntoSorted(unsorted) {
    return (0, lists_1.partitionByFn)((a, b) => (0, comparators_1.cmpStr)(a, b) === 1, // split when a > b
    unsorted);
}
async function runMultipleScripts(runtimeEnv, scriptNames, onSuccessFn, force, logDebugTag, allowWrite, algoOp) {
    const deployerCfg = new deployer_cfg_1.DeployerConfig(runtimeEnv, algoOp);
    for (const scripts of partitionIntoSorted(scriptNames)) {
        await runSortedScripts(runtimeEnv, scripts, onSuccessFn, force, logDebugTag, allowWrite, deployerCfg);
    }
}
exports.runMultipleScripts = runMultipleScripts;
// Function only accepts sorted scripts -- only this way it loads the state correctly.
async function runSortedScripts(runtimeEnv, scriptNames, onSuccessFn, force, logDebugTag, allowWrite, deployerCfg) {
    const log = (0, debug_1.default)(logDebugTag);
    deployerCfg.cpData = (0, script_checkpoints_1.loadCheckpointsRecursive)();
    deployerCfg.txWriter = new tx_log_writer_1.TxWriterImpl('');
    const deployer = (0, deployer_cfg_1.mkDeployer)(allowWrite, deployerCfg);
    const scriptsFromScriptsDir = (0, script_checkpoints_1.lsScriptsDir)();
    for (const relativeScriptPath of scriptNames) {
        const prevScripts = splitAfter(scriptsFromScriptsDir, relativeScriptPath);
        (0, script_checkpoints_1.loadCheckpointsIntoCPData)(deployerCfg.cpData, prevScripts);
        if (prevScripts[prevScripts.length - 1] !== relativeScriptPath) {
            deployerCfg.cpData.merge((0, script_checkpoints_1.loadCheckpoint)(relativeScriptPath), relativeScriptPath);
        }
        if (!force && deployerCfg.cpData.networkExistsInCurrentCP(runtimeEnv.network.name)) {
            log(`Skipping: Checkpoint exists for script ${relativeScriptPath}`);
            // '\x1b[33m%s\x1b[0m' this is used for setting the message color to yellow.
            console.warn('\x1b[33m%s\x1b[0m', `Skipping: Checkpoint exists for script ${relativeScriptPath}`);
            continue;
        }
        deployerCfg.txWriter.setScriptName(relativeScriptPath);
        log(`Running script ${relativeScriptPath}`);
        await (0, scripts_runner_1.runScript)(relativeScriptPath, runtimeEnv, deployer);
        onSuccessFn(deployerCfg.cpData, relativeScriptPath);
    }
}
async function executeRunTask({ scripts }, runtimeEnv, algoOp) {
    const logDebugTag = "algob:tasks:run";
    const nonExistent = filterNonExistent(scripts);
    if (nonExistent.length !== 0) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.RUN_FILES_NOT_FOUND, {
            scripts: nonExistent
        });
    }
    await runMultipleScripts(runtimeEnv, (0, files_1.assertDirChildren)(script_checkpoints_1.scriptsDirectory, scripts), (_cpData, _relativeScriptPath) => { }, true, logDebugTag, false, algoOp);
}
function default_1() {
    (0, config_env_1.task)(task_names_1.TASK_RUN, "Runs a user-defined script after compiling the project")
        .addVariadicPositionalParam("scripts", "A js file to be run within algob's environment")
        .setAction((input, env) => executeRunTask(input, env, (0, algo_operator_1.createAlgoOperator)(env.network)));
}
exports.default = default_1;
//# sourceMappingURL=run.js.map