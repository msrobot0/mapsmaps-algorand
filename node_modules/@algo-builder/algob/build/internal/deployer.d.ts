import { types as rtypes } from "@algo-builder/runtime";
import { types as wtypes } from "@algo-builder/web";
import type { LogicSigAccount, modelsv2 } from "algosdk";
import * as algosdk from "algosdk";
import { txWriter } from "../internal/tx-log-writer";
import { AlgoOperator } from "../lib/algo-operator";
import type { ASCCache, CheckpointFunctions, CheckpointRepo, ConfirmedTxInfo, Deployer, FundASCFlags, LogicSig, LsigInfo, RuntimeEnv, SCParams } from "../types";
import { DeployerConfig } from "./deployer_cfg";
declare class DeployerBasicMode {
    protected readonly runtimeEnv: RuntimeEnv;
    protected readonly cpData: CheckpointRepo;
    protected readonly loadedAsaDefs: wtypes.ASADefs;
    protected readonly algoOp: AlgoOperator;
    protected readonly txWriter: txWriter;
    readonly accounts: rtypes.Account[];
    readonly accountsByName: rtypes.AccountMap;
    readonly indexerClient: algosdk.Indexer | undefined;
    checkpoint: CheckpointFunctions;
    constructor(deployerCfg: DeployerConfig);
    protected get networkName(): string;
    /**
     * Queries ASA Info from asset name
     * @param name asset name
     */
    getASAInfo(name: string): rtypes.ASAInfo;
    private _getAccount;
    /**
     * Returns asset definition for given name
     * @param name Asset name
     * @param asaParams Asa parameters if user wants to override existing asa definition
     */
    getASADef(name: string, asaParams?: Partial<wtypes.ASADef>): wtypes.ASADef;
    /**
     * Returns checkpoint metadata
     * @param key key for the map
     */
    getCheckpointKV(key: string): string | undefined;
    isDefined(name: string): boolean;
    get asa(): Map<string, rtypes.ASAInfo>;
    get algodClient(): algosdk.Algodv2;
    waitForConfirmation(txId: string): Promise<ConfirmedTxInfo>;
    /**
     * Queries blockchain using algodv2 for asset information by index
     * @param assetIndex asset index
     * @returns asset info from network
     */
    getAssetByID(assetIndex: number | bigint): Promise<modelsv2.Asset>;
    log(msg: string, obj: any): void;
    /**
     * Loads deployed Asset Definition from checkpoint.
     * NOTE: This function returns "deployed" ASADef, as immutable properties
     * of asaDef could be updated during tx execution (eg. update asset clawback)
     * @param asaName asset name in asa.yaml
     */
    loadASADef(asaName: string): wtypes.ASADef | undefined;
    /**
     * Loads stateful smart contract info from checkpoint
     * @param nameApproval Approval program name
     * @param nameClear clear program name
     */
    getApp(nameApproval: string, nameClear: string): rtypes.SSCInfo | undefined;
    /**
     * Loads stateful smart contract info from checkpoint
     * @param appName name of the app (passed by user during deployment)
     */
    getAppByName(appName: string): rtypes.SSCInfo | undefined;
    /**
     * Loads a single signed delegated logic signature account from checkpoint
     */
    getDelegatedLsig(lsigName: string): LogicSigAccount | undefined;
    /**
     * Loads a logic signature account from checkpoint
     * @param lsigName logic signature name
     */
    getContractLsig(lsigName: string): LogicSigAccount | undefined;
    /**
     * Loads logic signature for contract mode
     * @param name ASC name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    loadLogic(name: string, scTmplParams?: SCParams): Promise<LogicSigAccount>;
    /**
     * Loads logic signature from cache for contract mode. This helps user to avoid
     * passing template parameters always during loading logic signature.
     * @param name ASC name
     * @returns loaded logic signature from artifacts/cache/<file_name>.teal.yaml
     */
    loadLogicFromCache(name: string): Promise<LogicSigAccount>;
    /**
     * Alias to `this.compileASC` with last two parameters being swapped.
     * Deprecated: this function will be removed in the next release.
     */
    ensureCompiled(name: string, force?: boolean, scTmplParams?: SCParams): Promise<ASCCache>;
    /**
     * Returns ASCCache (with compiled code)
     * @param name: Smart Contract filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param force: if force is true file will be compiled for sure, even if it's checkpoint exist
     */
    compileASC(name: string, scTmplParams?: SCParams, force?: boolean): Promise<ASCCache>;
    /**
     * Returns cached program (from artifacts/cache) `ASCCache` object by filename.
     * TODO: beta support - this will change
     * @param name ASC name used during deployment
     */
    getDeployedASC(name: string): Promise<ASCCache | undefined>;
    /**
     * Loads multisigned logic signature account from .lsig or .blsig file
     * @param name filename
     * @returns multi signed logic signature from assets/<file_name>.(b)lsig
     */
    loadMultiSig(name: string): Promise<LogicSig>;
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    sendAndWait(rawTxns: Uint8Array | Uint8Array[]): Promise<ConfirmedTxInfo>;
    /**
     * Opt-In to ASA for a single account. The opt-in transaction is
     * signed by account secret key
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param accountName
     * @param flags Transaction flags
     */
    optInAccountToASA(asa: string, accountName: string, flags: wtypes.TxParams): Promise<void>;
    /**
     * Description: Opt-In to ASA for a contract account (represented by logic signture).
     * The opt-in transaction is signed by the logic signature
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param lsig logic signature
     * @param flags Transaction flags
     */
    optInLsigToASA(asa: string, lsig: LogicSigAccount, flags: wtypes.TxParams): Promise<void>;
    /**
     * Opt-In to stateful smart contract (SSC) for a single account
     * signed by account secret key
     * @param sender sender account
     * @param appID application index
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInAccountToApp(sender: rtypes.Account, appID: number, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInLsigToApp(appID: number, lsig: LogicSigAccount, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    /**
     * Asserts ASA is defined in a checkpoint by asset id / string,
     * First: search for ASAInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param asset asset index or asset name
     */
    private assertASAExist;
    /**
     * Asserts App is defined in a checkpoint by app id.
     * First: search for SSCInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param appID Application index
     */
    private assertAppExist;
    /**
     * Group transactions into asa and app, check for cp deletion
     * @param txn Transaction execution parameter
     */
    private _assertCpNotDeleted;
    /**
     * Checks if checkpoint is deleted for a particular transaction
     * if checkpoint exist and is marked as deleted,
     * throw error(except for opt-out transactions), else pass
     * @param execParams Transaction execution parameters
     */
    assertCPNotDeleted(execParams: wtypes.ExecParams | wtypes.ExecParams[]): void;
}
/**
 * This class is what user interacts with in deploy task
 */
export declare class DeployerDeployMode extends DeployerBasicMode implements Deployer {
    get isDeployMode(): boolean;
    addCheckpointKV(key: string, value: string): void;
    /**
     * Asserts if asset is not already present in checkpoint
     * @param name Asset name
     */
    assertNoAsset(name: string): void;
    /**
     * Persist checkpoint till current call.
     */
    persistCP(): void;
    /**
     * Register ASA Info in checkpoints
     */
    registerASAInfo(asaName: string, asaInfo: rtypes.ASAInfo): void;
    /**
     * Register SSC Info in checkpoints
     */
    registerSSCInfo(sscName: string, sscInfo: rtypes.SSCInfo): void;
    /**
     * Log transaction with message using txwriter
     */
    logTx(message: string, txConfirmation: ConfirmedTxInfo): void;
    /**
     * Creates and deploys ASA using asa.yaml.
     * @name  ASA name - deployer will search for the ASA in the /assets/asa.yaml file
     * @flags  deployment flags
     */
    deployASA(name: string, flags: rtypes.ASADeploymentFlags, asaParams?: Partial<wtypes.ASADef>): Promise<rtypes.ASAInfo>;
    /**
     * Creates and deploys ASA without using asa.yaml.
     * @name ASA name
     * @asaDef ASA definitions
     * @flags deployment flags
     */
    deployASADef(name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    /**
     * This function will send Algos to ASC account in "Contract Mode"
     * @param name     - ASC filename
     * @param flags    - Deployments flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    fundLsig(name: string, flags: FundASCFlags, payFlags: wtypes.TxParams, scTmplParams?: SCParams): Promise<void>;
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * @param name: Stateless Smart Contract filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param signer: Signer Account which will sign the smart
     * contract(optional in case of contract account)
     */
    _mkLsig(name: string, scTmplParams?: SCParams, signer?: rtypes.Account): Promise<LsigInfo>;
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * https://developer.algorand.org/docs/features/asc1/stateless/sdks/#account-delegation-sdk-usage
     * @param name: Stateless Smart Contract filename (must be present in assets folder)
     * @param signer: Signer Account which will sign the smart contract
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    mkDelegatedLsig(name: string, signer: rtypes.Account, scTmplParams?: SCParams): Promise<LsigInfo>;
    /**
     * Stores logic signature info in checkpoint for contract mode
     * @param name ASC name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    mkContractLsig(name: string, scTmplParams?: SCParams): Promise<LsigInfo>;
    /**
     * Deploys Algorand Stateful Smart Contract
     * @param approvalProgram filename which has approval program
     * @param clearProgram filename which has clear program
     * @param flags AppDeploymentFlags
     * @param payFlags Transaction Params
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param appName name of the app to deploy. This name (if passed) will be used as
     * the checkpoint "key", and app information will be associated with this name
     */
    deployApp(approvalProgram: string, clearProgram: string, flags: rtypes.AppDeploymentFlags, payFlags: wtypes.TxParams, scTmplParams?: SCParams, appName?: string): Promise<rtypes.SSCInfo>;
    /**
     * Update programs for a contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID ID of the application being configured or empty if creating
     * @param newApprovalProgram New Approval Program filename
     * @param newClearProgram New Clear Program filename
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param appName name of the app to deploy. This name (if passed) will be used as
     * the checkpoint "key", and app information will be associated with this name
     */
    updateApp(sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newApprovalProgram: string, newClearProgram: string, flags: rtypes.AppOptionalFlags, scTmplParams?: SCParams, appName?: string): Promise<rtypes.SSCInfo>;
}
/**
 * This class is what user interacts with in run task mode
 */
export declare class DeployerRunMode extends DeployerBasicMode implements Deployer {
    get isDeployMode(): boolean;
    persistCP(): void;
    assertNoAsset(name: string): void;
    registerASAInfo(name: string, asaInfo: rtypes.ASAInfo): void;
    registerSSCInfo(name: string, sscInfo: rtypes.SSCInfo): void;
    logTx(message: string, txConfirmation: ConfirmedTxInfo): void;
    addCheckpointKV(_key: string, _value: string): void;
    deployASA(_name: string, _flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    deployASADef(name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    fundLsig(_name: string, _flags: FundASCFlags, _payFlags: wtypes.TxParams, _scInitParams?: unknown): Promise<LsigInfo>;
    mkDelegatedLsig(_name: string, _signer: rtypes.Account, _scInitParams?: unknown): Promise<LsigInfo>;
    deployApp(approvalProgram: string, clearProgram: string, flags: rtypes.AppDeploymentFlags, payFlags: wtypes.TxParams, scInitParam?: unknown, appName?: string): Promise<rtypes.SSCInfo>;
    /**
     * This functions updates SSC in the network.
     * Note: updateApp when ran in RunMode it doesn't store checkpoints
     * @param sender Sender account
     * @param payFlags transaction parameters
     * @param appID application index
     * @param newApprovalProgram new approval program name
     * @param newClearProgram new clear program name
     * @param flags SSC optional flags
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    updateApp(sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newApprovalProgram: string, newClearProgram: string, flags: rtypes.AppOptionalFlags, scTmplParams?: SCParams): Promise<rtypes.SSCInfo>;
}
export {};
