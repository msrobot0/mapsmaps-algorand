"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeSignedTxnFromFile = exports.executeTransaction = exports.signTransactions = exports.makeAndSignTx = exports.makeASAOptInTx = exports.makeAssetCreateTxn = exports.isSignedTx = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const files_1 = require("./files");
const script_checkpoints_1 = require("./script-checkpoints");
/**
 * Returns true if encoded transaction (fetched from file) is already signed
 * @param encodedTx msgpack encoded transaction */
function isSignedTx(encodedTx) {
    try {
        (0, algosdk_1.decodeSignedTransaction)(encodedTx);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isSignedTx = isSignedTx;
/**
 * Returns SDK transaction object for ASA creation
 * @param name asset name
 * @param asaDef asset definition (passed in `/assets/asa.yaml)
 * @param flags basic transaction flags like `feePerByte`, `totalFee`, etc
 * @param txSuggestedParams suggested transaction params
 */
function makeAssetCreateTxn(name, asaDef, flags, txSuggestedParams) {
    // If TxParams has noteb64 or note , it gets precedence
    let note;
    if (flags.noteb64 ?? flags.note) {
        // TxParams note
        note = web_1.tx.encodeNote(flags.note, flags.noteb64);
    }
    else if (asaDef.noteb64 ?? asaDef.note) {
        // ASA definition note
        note = web_1.tx.encodeNote(asaDef.note, asaDef.noteb64);
    }
    // https://github.com/algorand/docs/blob/master/examples/assets/v2/javascript/AssetExample.js#L104
    return algosdk_1.default.makeAssetCreateTxnWithSuggestedParams(flags.creator.addr, note, BigInt(asaDef.total), Number(asaDef.decimals), asaDef.defaultFrozen ? asaDef.defaultFrozen : false, asaDef.manager !== "" ? asaDef.manager : undefined, asaDef.reserve !== "" ? asaDef.reserve : undefined, asaDef.freeze !== "" ? asaDef.freeze : undefined, asaDef.clawback !== "" ? asaDef.clawback : undefined, asaDef.unitName, name, asaDef.url ?? "", asaDef.metadataHash, txSuggestedParams);
}
exports.makeAssetCreateTxn = makeAssetCreateTxn;
/**
 * Returns SDK transaction object for ASA Opt-In operation
 * @param addr the address of the user to be opted-in
 * @param assetID the unique asset ID for which the opt-in transaction will be performed
 * @param params suggested transaction params
 */
function makeASAOptInTx(addr, assetID, params, payFlags) {
    const execParam = {
        type: web_1.types.TransactionType.OptInASA,
        sign: web_1.types.SignType.SecretKey,
        fromAccount: { addr: addr, sk: new Uint8Array(0) },
        assetID: assetID,
        payFlags: payFlags
    };
    return web_1.tx.mkTransaction(execParam, params);
}
exports.makeASAOptInTx = makeASAOptInTx;
/**
 * Returns signed transaction
 * @param txn unsigned transaction
 * @param signer sign and secret key parameters
 */
function signTransaction(txn, signer) {
    switch (signer.sign) {
        case web_1.types.SignType.SecretKey: {
            return txn.signTxn(signer.fromAccount.sk);
        }
        case web_1.types.SignType.LogicSignature: {
            signer.lsig.lsig.args = signer.args ?? [];
            return algosdk_1.default.signLogicSigTransactionObject(txn, signer.lsig).blob;
        }
        default: {
            throw new Error("Unknown type of signature");
        }
    }
}
/**
 * Make transaction parameters and update deployASA, deployApp & ModifyAsset params
 * @param deployer Deployer object
 * @param txn Execution parameters
 * @param index index of current execParam
 * @param txIdxMap Map for index to name
 */
/* eslint-disable sonarjs/cognitive-complexity */
async function mkTx(deployer, txn, index, txIdxMap) {
    // if execParams for ASA related transaction have assetID as asaName,
    // then set to assetIndex using info from checkpoint
    switch (txn.type) {
        case web_1.types.TransactionType.OptInASA:
        case web_1.types.TransactionType.TransferAsset:
        case web_1.types.TransactionType.ModifyAsset:
        case web_1.types.TransactionType.FreezeAsset:
        case web_1.types.TransactionType.RevokeAsset: {
            if (typeof txn.assetID === "string") {
                const asaInfo = deployer.getASAInfo(txn.assetID);
                txn.assetID = asaInfo.assetIndex;
            }
            break;
        }
        case web_1.types.TransactionType.DestroyAsset: {
            if (typeof txn.assetID === "string") {
                txIdxMap.set(index, [txn.assetID, deployer.getASADef(txn.assetID, {})]);
                const asaInfo = deployer.getASAInfo(txn.assetID);
                txn.assetID = asaInfo.assetIndex;
            }
            break;
        }
    }
    switch (txn.type) {
        case web_1.types.TransactionType.DeployASA: {
            if (txn.asaDef === undefined) {
                txn.asaDef = deployer.getASADef(txn.asaName, txn.overrideAsaDef);
            }
            (0, runtime_1.parseASADef)(txn.asaDef);
            deployer.assertNoAsset(txn.asaName);
            txIdxMap.set(index, [txn.asaName, txn.asaDef]);
            break;
        }
        case web_1.types.TransactionType.DeployApp: {
            const name = txn.appName ?? String(txn.approvalProgram) + "-" + String(txn.clearProgram);
            deployer.assertNoAsset(name);
            const approval = await deployer.ensureCompiled(txn.approvalProgram);
            const clear = await deployer.ensureCompiled(txn.clearProgram);
            txn.approvalProg = new Uint8Array(Buffer.from(approval.compiled, "base64"));
            txn.clearProg = new Uint8Array(Buffer.from(clear.compiled, "base64"));
            txIdxMap.set(index, [name, { total: 1, decimals: 1, unitName: "MOCK", defaultFrozen: false }]);
            break;
        }
        case web_1.types.TransactionType.UpdateApp: {
            const cpKey = txn.appName ?? String(txn.newApprovalProgram) + "-" + String(txn.newClearProgram);
            const approval = await deployer.ensureCompiled(txn.newApprovalProgram);
            const clear = await deployer.ensureCompiled(txn.newClearProgram);
            txn.approvalProg = new Uint8Array(Buffer.from(approval.compiled, "base64"));
            txn.clearProg = new Uint8Array(Buffer.from(clear.compiled, "base64"));
            txIdxMap.set(index, [cpKey, { total: 1, decimals: 1, unitName: "MOCK", defaultFrozen: false }]);
            break;
        }
        case web_1.types.TransactionType.ModifyAsset: {
            // fetch asset mutable properties from network and set them (if they are not passed)
            // before modifying asset
            const assetInfo = await deployer.getAssetByID(BigInt(txn.assetID));
            if (txn.fields.manager === "")
                txn.fields.manager = undefined;
            else
                txn.fields.manager = txn.fields.manager ?? assetInfo.params.manager;
            if (txn.fields.freeze === "")
                txn.fields.freeze = undefined;
            else
                txn.fields.freeze = txn.fields.freeze ?? assetInfo.params.freeze;
            if (txn.fields.clawback === "")
                txn.fields.clawback = undefined;
            else
                txn.fields.clawback = txn.fields.clawback ?? assetInfo.params.clawback;
            if (txn.fields.reserve === "")
                txn.fields.reserve = undefined;
            else
                txn.fields.reserve = txn.fields.reserve ?? assetInfo.params.reserve;
            break;
        }
    }
    const suggestedParams = await (0, web_1.getSuggestedParams)(deployer.algodClient);
    return web_1.tx.mkTransaction(txn, await (0, web_1.mkTxParams)(deployer.algodClient, txn.payFlags, Object.assign({}, suggestedParams)));
}
/**
 * Create and Sign SDK transaction(s) from transaction execution parameters (passed by user).
 * @param deployer Deployer object
 * @param execParams Execution parameters
 * @param txIdxMap Map for index to [cpname, asaDef]
 * @returns [transaction(s), signed transaction(s)]
 */
async function makeAndSignTx(deployer, execParams, txIdxMap) {
    let signedTxn;
    let txns = [];
    if (Array.isArray(execParams)) {
        if (execParams.length > 16) {
            throw new Error("Maximum size of an atomic transfer group is 16");
        }
        for (const [idx, txn] of execParams.entries()) {
            txns.push(await mkTx(deployer, txn, idx, txIdxMap));
        }
        txns = algosdk_1.default.assignGroupID(txns);
        signedTxn = txns.map((txn, index) => {
            const signed = signTransaction(txn, execParams[index]);
            deployer.log(`Signed transaction ${index}`, signed);
            return signed;
        });
    }
    else {
        const txn = await mkTx(deployer, execParams, 0, txIdxMap);
        signedTxn = signTransaction(txn, execParams);
        deployer.log(`Signed transaction:`, signedTxn);
        txns = [txn];
    }
    return [txns, signedTxn];
}
exports.makeAndSignTx = makeAndSignTx;
/**
 * Signs transaction object(s) and returns raw signed transaction
 * Note: `signTransaction` is used to sign single transaction and `signTransactions` takes
 * array of SDK transaction object with signers, signs it.
 * @param txnAndSign Transaction object(s) with signers
 */
function signTransactions(txnAndSign) {
    let txns = [];
    const signers = [];
    for (const [idx, value] of txnAndSign.entries()) {
        txns[idx] = value.transaction;
        signers[idx] = value.sign;
    }
    txns = algosdk_1.default.assignGroupID(txns);
    return txns.map((txn, index) => {
        return signTransaction(txn, signers[index]);
    });
}
exports.signTransactions = signTransactions;
/**
 * Execute single transaction or group of transactions (atomic transaction)
 * executes `ExecParams` or `Transaction` Object, SDK Transaction object passed to this function
 * will be signed and sent to network. User can use SDK functions to create transactions.
 * Note: If passing transaction object a signer/s must be provided.
 * @param deployer Deployer
 * @param transactionParam transaction parameters or atomic transaction parameters
 * https://github.com/scale-it/algo-builder/blob/docs/docs/guide/execute-transaction.md
 * or TransactionAndSign object(SDK transaction object and signer parameters)
 */
async function executeTransaction(deployer, transactions) {
    let isSDK = false;
    let signedTxn;
    if (Array.isArray(transactions)) {
        if (transactions.length === 0) {
            throw new web_1.BuilderError(web_1.ERRORS.GENERAL.EXECPARAMS_LENGTH_ERROR);
        }
        if (web_1.types.isSDKTransactionAndSign(transactions[0])) {
            signedTxn = signTransactions(transactions);
            isSDK = true;
        }
    }
    else {
        if (web_1.types.isSDKTransactionAndSign(transactions)) {
            signedTxn = signTransaction(transactions.transaction, transactions.sign);
            isSDK = true;
        }
    }
    if (isSDK && signedTxn) {
        const confirmedTx = await deployer.sendAndWait(signedTxn);
        console.log(confirmedTx);
        return confirmedTx;
    }
    // Update type here because we are sure this is not transaction object type
    transactions = Array.isArray(transactions)
        ? transactions
        : transactions;
    deployer.assertCPNotDeleted(transactions);
    try {
        const txIdxMap = new Map();
        const [txns, signedTxn] = await makeAndSignTx(deployer, transactions, txIdxMap);
        const confirmedTx = await deployer.sendAndWait(signedTxn);
        console.log(confirmedTx);
        if (deployer.isDeployMode) {
            await (0, script_checkpoints_1.registerCheckpoints)(deployer, txns, txIdxMap);
        }
        return confirmedTx;
    }
    catch (error) {
        if (deployer.isDeployMode) {
            deployer.persistCP();
        }
        throw error;
    }
}
exports.executeTransaction = executeTransaction;
/**
 * Decode signed txn from file and send to network.
 * probably won't work, because transaction contains fields like
 * firstValid and lastValid which might not be equal to the
 * current network's blockchain block height.
 * @param deployer Deployer
 * @param fileName raw(encoded) signed txn file
 */
async function executeSignedTxnFromFile(deployer, fileName) {
    const signedTxn = (0, files_1.loadEncodedTxFromFile)(fileName);
    if (signedTxn === undefined) {
        throw new Error(`File ${fileName} does not exist`);
    }
    console.debug("Decoded txn from %s: %O", fileName, algosdk_1.default.decodeSignedTransaction(signedTxn));
    const confirmedTx = await deployer.sendAndWait(signedTxn);
    console.log(confirmedTx);
    return confirmedTx;
}
exports.executeSignedTxnFromFile = executeSignedTxnFromFile;
//# sourceMappingURL=tx.js.map