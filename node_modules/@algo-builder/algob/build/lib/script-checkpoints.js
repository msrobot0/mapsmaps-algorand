"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckpointFunctionsImpl = exports.loadCheckpointsIntoCPData = exports.loadCheckpointsRecursive = exports.lsScriptsDir = exports.loadCheckpoint = exports.loadCheckpointByCPName = exports.toSSCMap = exports.toMap = exports.registerCheckpoints = exports.persistCheckpoint = exports.CheckpointRepoImpl = exports.appendToCheckpoint = exports.CheckpointImpl = exports.toScriptFileName = exports.toCheckpointFileName = exports.testsDirectory = exports.scriptsDirectory = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const deep_equal_1 = __importDefault(require("deep-equal"));
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
exports.scriptsDirectory = "scripts";
exports.testsDirectory = "test";
const artifactsPath = "artifacts";
const checkpointFileSuffix = ".cp.yaml";
function toCheckpointFileName(scriptName) {
    return path_1.default.join(artifactsPath, scriptName + checkpointFileSuffix);
}
exports.toCheckpointFileName = toCheckpointFileName;
function toScriptFileName(filename) {
    filename = filename.replace(artifactsPath + path_1.default.sep, '');
    filename = filename.slice(0, -(checkpointFileSuffix.length));
    return filename;
}
exports.toScriptFileName = toScriptFileName;
class CheckpointImpl {
    constructor(metadata) {
        this.timestamp = +new Date();
        this.metadata = (metadata === undefined ? new Map() : metadata);
        this.asa = new Map();
        const mp = new Map();
        this.ssc = new Map();
        this.dLsig = new Map();
    }
}
exports.CheckpointImpl = CheckpointImpl;
function appendToCheckpoint(checkpoints, networkName, append) {
    const orig = checkpoints[networkName];
    if (!orig) {
        checkpoints[networkName] = Object.assign({}, append);
        return checkpoints;
    }
    orig.timestamp = append.timestamp;
    orig.metadata = new Map([...orig.metadata, ...append.metadata]);
    const allAssetNames = [...append.asa.keys(), ...append.ssc.keys()];
    for (const assetName of allAssetNames) {
        if ((orig.asa.get(assetName) && !(0, deep_equal_1.default)(orig.asa.get(assetName), append.asa.get(assetName))) ??
            (orig.ssc.get(assetName) && !(0, deep_equal_1.default)(orig.ssc.get(assetName), append.ssc.get(assetName)))) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.CHECKPOINT_ERROR_DUPLICATE_ASSET_DEFINITION, { assetName: assetName });
        }
    }
    orig.asa = new Map([...orig.asa, ...append.asa]);
    orig.ssc = new Map([...orig.ssc, ...append.ssc]);
    orig.dLsig = new Map([...orig.dLsig, ...append.dLsig]);
    return checkpoints;
}
exports.appendToCheckpoint = appendToCheckpoint;
class CheckpointRepoImpl {
    constructor() {
        this.strippedCP = {};
        this.precedingCP = {};
        this.allCPs = {};
        this.scriptMap = {};
    }
    _mergeTo(target, cp, scriptMap) {
        const keys = Object.keys(cp);
        return keys.reduce((out, key) => {
            return appendToCheckpoint(out, key, cp[key]);
        }, target);
    }
    merge(cp, scriptName) {
        this.strippedCP = cp;
        this.precedingCP = this._mergeTo(this.precedingCP, cp, this.scriptMap);
        this.mergeToGlobal(cp, scriptName);
        return this;
    }
    mergeToGlobal(cp, scriptName) {
        const keys = Object.keys(cp);
        for (const k of keys) {
            const current = cp[k];
            const allAssetNames = [...current.asa.keys(), ...current.ssc.keys(), ...current.dLsig.keys()];
            for (const assetName of allAssetNames) {
                if (!(this.scriptMap[assetName])) {
                    this.scriptMap[assetName] = scriptName;
                }
                else {
                    if (this.scriptMap[assetName] !== scriptName) {
                        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.CHECKPOINT_ERROR_DUPLICATE_ASSET_DEFINITION, { assetName: [this.scriptMap[assetName], scriptName] });
                    }
                }
            }
        }
        this.allCPs = this._mergeTo(this.allCPs, cp, this.scriptMap);
        return this;
    }
    _ensureNet(cp, networkName) {
        if (!cp[networkName]) {
            cp[networkName] = new CheckpointImpl();
        }
        return cp[networkName];
    }
    putMetadata(networkName, key, value) {
        this._ensureNet(this.allCPs, networkName).metadata.set(key, value);
        this._ensureNet(this.strippedCP, networkName).metadata.set(key, value);
        this._ensureNet(this.precedingCP, networkName).metadata.set(key, value);
        return this;
    }
    getMetadata(networkName, key) {
        if (this.precedingCP[networkName]) {
            return this.precedingCP[networkName].metadata.get(key);
        }
        return undefined;
    }
    registerASA(networkName, name, info) {
        this._ensureNet(this.precedingCP, networkName).asa.set(name, info);
        this._ensureNet(this.strippedCP, networkName).asa.set(name, info);
        this._ensureNet(this.allCPs, networkName).asa.set(name, info);
        return this;
    }
    _ensureRegister(map, name, info) {
        const nestedMap = map.get(name);
        if (nestedMap) {
            nestedMap.set(info.timestamp, info);
        }
        else {
            const newMap = new Map();
            newMap.set(info.timestamp, info);
            map.set(name, newMap);
        }
    }
    registerSSC(networkName, name, info) {
        this._ensureRegister(this._ensureNet(this.precedingCP, networkName).ssc, name, info);
        this._ensureRegister(this._ensureNet(this.strippedCP, networkName).ssc, name, info);
        this._ensureRegister(this._ensureNet(this.allCPs, networkName).ssc, name, info);
        return this;
    }
    registerLsig(networkName, name, info) {
        this._ensureNet(this.precedingCP, networkName).dLsig.set(name, info);
        this._ensureNet(this.strippedCP, networkName).dLsig.set(name, info);
        this._ensureNet(this.allCPs, networkName).dLsig.set(name, info);
        return this;
    }
    isDefined(networkName, name) {
        const netCP = this.allCPs[networkName];
        return netCP !== undefined &&
            (netCP.asa.get(name) !== undefined || netCP.ssc.get(name) !== undefined ||
                netCP.dLsig.get(name) !== undefined);
    }
    networkExistsInCurrentCP(networkName) {
        return Boolean(this.strippedCP[networkName]);
    }
}
exports.CheckpointRepoImpl = CheckpointRepoImpl;
function persistCheckpoint(scriptName, checkpoint) {
    const scriptPath = toCheckpointFileName(scriptName);
    const scriptDir = path_1.default.dirname(scriptPath);
    fs.mkdirSync(scriptDir, { recursive: true });
    fs.writeFileSync(scriptPath, yaml_1.default.stringify(checkpoint));
}
exports.persistCheckpoint = persistCheckpoint;
/**
 * Register checkpoints for ASA and SSC
 * @param deployer Deployer object
 * @param txns transaction array
 * @param txIdxMap transaction map: to match transaction order
 * transaction index mapped to [asset name, asset definition]
 */
/* eslint-disable sonarjs/cognitive-complexity */
async function registerCheckpoints(deployer, txns, txIdxMap) {
    for (const [idx, txn] of txns.entries()) {
        let txConfirmation;
        const res = txIdxMap.get(idx);
        switch (txn.type) {
            case 'acfg': {
                txConfirmation = await deployer.waitForConfirmation(txn.txID());
                const key = deployer.checkpoint.getAssetCheckpointKeyFromIndex(txn.assetIndex);
                if (key && (0, runtime_1.checkIfAssetDeletionTx)(txn)) {
                    const temp = deployer.getASAInfo(key);
                    temp.deleted = true;
                    deployer.registerASAInfo(key, temp);
                    deployer.logTx("Deleting ASA: " + String(txn.assetIndex), txConfirmation);
                    break;
                }
                if (res) {
                    const asaInfo = {
                        creator: (0, algosdk_1.encodeAddress)(txn.from.publicKey),
                        txId: txn.txID(),
                        assetIndex: Number(txConfirmation['asset-index']),
                        confirmedRound: Number(txConfirmation['confirmed-round']),
                        assetDef: res[1],
                        deleted: false
                    };
                    // res[0] -> asset name, res[1] -> ASADef
                    deployer.registerASAInfo(res[0], asaInfo);
                    deployer.logTx("Deploying ASA: " + res[0], txConfirmation);
                }
                break;
            }
            case 'appl': {
                txConfirmation = await deployer.waitForConfirmation(txn.txID());
                const key = deployer.checkpoint.getAppCheckpointKeyFromIndex(txn.appIndex);
                if (key) {
                    const temp = deployer.checkpoint.getAppfromCPKey(key);
                    if (txn.appOnComplete === Number(runtime_1.types.TxOnComplete.DeleteApplication) && temp) {
                        temp.deleted = true;
                        deployer.registerSSCInfo(key, temp);
                        deployer.logTx("Deleting SSC: " + String(txn.appIndex), txConfirmation);
                        break;
                    }
                }
                if (res) {
                    const sscInfo = {
                        creator: (0, algosdk_1.encodeAddress)(txn.from.publicKey),
                        txId: txn.txID(),
                        appID: Number(txConfirmation['application-index']),
                        applicationAccount: (0, algosdk_1.getApplicationAddress)(Number(txConfirmation['application-index'])),
                        confirmedRound: Number(txConfirmation['confirmed-round']),
                        timestamp: Math.round(+new Date() / 1000),
                        deleted: false
                    };
                    const val = deployer.checkpoint.getAppfromCPKey(res[0]);
                    if (val?.appID === sscInfo.appID) {
                        deployer.logTx("Updating SSC: " + res[0], txConfirmation);
                    }
                    else {
                        deployer.logTx("Deploying SSC: " + res[0], txConfirmation);
                    }
                    deployer.registerSSCInfo(res[0], sscInfo);
                }
                break;
            }
        }
    }
}
exports.registerCheckpoints = registerCheckpoints;
// http://xahlee.info/js/js_object_to_map_datatype.html
function toMap(obj) {
    const mp = new Map();
    Object.keys(obj).forEach(k => { mp.set(k, obj[k]); });
    return mp;
}
exports.toMap = toMap;
;
// converts objects loaded from yaml file to nested map
function toSSCMap(obj) {
    const mp = new Map();
    Object.keys(obj).forEach(k => {
        const nestedMp = new Map();
        const nestedVal = obj[k];
        Object.keys(nestedVal).forEach(l => {
            nestedMp.set(l, nestedVal[l]);
        });
        mp.set(k, nestedMp);
    });
    return mp;
}
exports.toSSCMap = toSSCMap;
;
function convertCPValsToMaps(cpWithObjects) {
    cpWithObjects.asa = toMap(cpWithObjects.asa);
    cpWithObjects.ssc = toSSCMap(cpWithObjects.ssc);
    cpWithObjects.dLsig = toMap(cpWithObjects.dLsig);
    cpWithObjects.metadata = toMap(cpWithObjects.metadata);
    return cpWithObjects;
}
function loadCheckpointByCPName(checkpointName) {
    // Some structures are objects, some others are maps. Oh why.
    const checkpoints = (0, runtime_1.loadFromYamlFileSilent)(checkpointName, { mapAsMap: false });
    for (const k of Object.keys(checkpoints)) {
        convertCPValsToMaps(checkpoints[k]);
    }
    return checkpoints;
}
exports.loadCheckpointByCPName = loadCheckpointByCPName;
function loadCheckpoint(scriptName) {
    return loadCheckpointByCPName(toCheckpointFileName(scriptName));
}
exports.loadCheckpoint = loadCheckpoint;
function lsFiles(directoryName) {
    const list = [];
    fs.readdirSync(directoryName).forEach(file => {
        const fullPath = path_1.default.join(directoryName, file);
        const f = fs.statSync(fullPath);
        if (f.isFile()) {
            list.push(fullPath);
        }
    });
    return list;
}
;
function ensureCheckpointsPath() {
    const checkpointsPath = path_1.default.join(".", artifactsPath, exports.scriptsDirectory);
    fs.mkdirSync(checkpointsPath, { recursive: true });
    return checkpointsPath;
}
function findCheckpointsRecursive() {
    return (0, runtime_1.lsTreeWalk)(ensureCheckpointsPath())
        .filter(filename => filename.endsWith(checkpointFileSuffix));
}
function lsScriptsDir() {
    return lsFiles(exports.scriptsDirectory);
}
exports.lsScriptsDir = lsScriptsDir;
function loadCheckpointsRecursive() {
    return findCheckpointsRecursive().reduce((out, filename) => {
        return out.mergeToGlobal(loadCheckpointByCPName(filename), toScriptFileName(filename));
    }, new CheckpointRepoImpl());
}
exports.loadCheckpointsRecursive = loadCheckpointsRecursive;
function loadCheckpointsIntoCPData(cpData, scriptPaths) {
    let checkpointData = cpData;
    for (const s of scriptPaths) {
        checkpointData = cpData.merge(loadCheckpoint(s), s);
    }
    return checkpointData;
}
exports.loadCheckpointsIntoCPData = loadCheckpointsIntoCPData;
class CheckpointFunctionsImpl {
    constructor(cpData, networkName) {
        this.cpData = cpData;
        this.networkName = networkName;
    }
    /**
     * Queries a stateful smart contract info from checkpoint using key.
     * @param key Key here is clear program name appended to approval program name
     * with hypen("-") in between (approvalProgramName-clearProgramName)
     */
    getAppfromCPKey(key) {
        const resultMap = this.cpData.precedingCP[this.networkName]?.ssc ??
            new Map();
        const nestedMap = resultMap.get(key);
        if (nestedMap) {
            return [...nestedMap][nestedMap.size - 1][1];
        }
        else {
            return undefined;
        }
    }
    /**
     * Returns SSC checkpoint key using application index,
     * returns undefined if it doesn't exist
     * @param index Application index
     */
    getAppCheckpointKeyFromIndex(index) {
        const resultMap = this.cpData.precedingCP[this.networkName]?.ssc ?? new Map();
        for (const [key, nestedMap] of resultMap) {
            if (this.getLatestTimestampValue(nestedMap) === index) {
                return key;
            }
        }
        return undefined;
    }
    /**
     * Returns ASA checkpoint key using asset index,
     * returns undefined if it doesn't exist
     * @param index Asset Index
     */
    getAssetCheckpointKeyFromIndex(index) {
        const resultMap = this.cpData.precedingCP[this.networkName]?.asa ?? new Map();
        for (const [key, value] of resultMap) {
            if (value.assetIndex === index) {
                return key;
            }
        }
        return undefined;
    }
    /**
     * Returns latest timestamp value from map
     * @param map Map
     */
    getLatestTimestampValue(map) {
        let res = -1;
        const cmpValue = -1;
        map.forEach((value, key) => {
            if (key >= cmpValue) {
                res = value.appID;
            }
        });
        return res;
    }
}
exports.CheckpointFunctionsImpl = CheckpointFunctionsImpl;
//# sourceMappingURL=script-checkpoints.js.map