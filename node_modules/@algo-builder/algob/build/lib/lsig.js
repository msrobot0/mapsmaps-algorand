"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signLogicSigMultiSig = exports.getDummyLsig = exports.getLsigFromCache = exports.getLsig = exports._lsigFromRes = void 0;
/* eslint @typescript-eslint/no-var-requires: "off" */
const runtime_1 = require("@algo-builder/runtime");
const algosdk_1 = require("algosdk");
const project_structure_1 = require("../internal/core/project-structure");
const compile_1 = require("./compile");
/**
 * Make logic signature from result
 * @param result : ASC cache (contains filename, hash, tealcode ..etc)
 */
async function _lsigFromRes(result) {
    const program = result.base64ToBytes;
    const lsigAccount = new algosdk_1.LogicSigAccount(program, []);
    // below line saves data in cp is {tag: <value>} which we need, otherwise it'll save as
    // { type: 'buffer', data: <value> } and throws error upon running examples
    if (lsigAccount.lsig.tag) {
        lsigAccount.lsig.tag = new Uint8Array(lsigAccount.lsig.tag);
    }
    return lsigAccount;
}
exports._lsigFromRes = _lsigFromRes;
/**
 * Make logic signature from .teal file
 * @param name : ASC filename
 * @param algodClient : algodClient
 * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
 */
async function getLsig(name, algodClient, scTmplParams) {
    const compileOp = new compile_1.CompileOp(algodClient);
    const result = await compileOp.ensureCompiled(name, false, scTmplParams);
    return await _lsigFromRes(result);
}
exports.getLsig = getLsig;
/**
 * Make logic signature from "cached" teal code
 * @param name : ASC filename
 */
async function getLsigFromCache(filename) {
    const filePath = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.CACHE_DIR, filename + ".yaml");
    const result = (0, runtime_1.loadFromYamlFileSilent)(filePath);
    return await _lsigFromRes(result);
}
exports.getLsigFromCache = getLsigFromCache;
/**
 * Create and return a dummy logic signature
 */
function getDummyLsig() {
    return new algosdk_1.LogicSigAccount(new Uint8Array(56), []);
}
exports.getDummyLsig = getDummyLsig;
/**
 * Appends signature (using signer's sk) to multi-signed logic signature. If multisig is not found
 * then new multisig is created
 * eg. appending own signature to a signed lsig (received from multisignature account address network)
 * @param lsig Logic Sig object
 * @param signer: Signer Account which will sign the smart contract
 * @param mparams: passed when signing a new multisig
 * @returns multi signed logic signature (with appended signature using signer's sk)
 */
function signLogicSigMultiSig(lsigAccount, signer, mparams) {
    if (lsigAccount.lsig.msig === undefined) { // if multisig not found, create new msig
        if (mparams === undefined) {
            throw new Error('MultiSig Metadata is undefined, which is required for single sign multisig');
        }
        lsigAccount.signMultisig(mparams, signer.sk);
    }
    else {
        lsigAccount.appendToMultisig(signer.sk); // else append signature to msig
    }
    return lsigAccount;
}
exports.signLogicSigMultiSig = signLogicSigMultiSig;
//# sourceMappingURL=lsig.js.map