"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KMDOperator = exports.createMsigAddress = exports.loadAccountsFromEnv = exports.mkAccountIndex = exports.validateAccount = exports.loadAccountsFromFileSync = exports.loadAccountsFromFile = exports.mkAccounts = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const fs = __importStar(require("fs"));
const yaml_1 = __importDefault(require("yaml"));
const config_errors_1 = __importDefault(require("../internal/core/config/config-errors"));
/**
 * Returns an array of SDK accounts (addr, sk) */
function mkAccounts(input) {
    const accounts = [];
    const errs = new config_errors_1.default("");
    let a;
    let idx = 0;
    for (const i of input) {
        ++idx;
        if (i.path) {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.HD_ACCOUNT, { path: i.path });
        }
        else if (i.sk) {
            a = i;
        }
        else {
            a = fromMnemonic(i);
        }
        if (validateAccount(a, errs.putter("account_inputs", idx.toString()))) {
            accounts.push(a);
        }
    }
    if (!errs.isEmpty()) {
        throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.MALFORMED, { errors: errs.toString() });
    }
    return accounts;
}
exports.mkAccounts = mkAccounts;
function fromMnemonic(ia) {
    const a = parseMnemonic(ia.mnemonic);
    if (a.addr !== ia.addr && ia.addr !== "") {
        throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.MNEMONIC_ADDR_MISSMATCH, { name: ia.name, addr: ia.addr, mnemonic: ia.mnemonic });
    }
    return { name: ia.name, addr: a.addr, sk: a.sk };
}
function parseMnemonic(mnemonic) {
    try {
        return (0, algosdk_1.mnemonicToSecretKey)(mnemonic);
    }
    catch (e) {
        if (e instanceof Error) {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.WRONG_MNEMONIC, { errmsg: e.message }, e);
        }
        throw e;
    }
}
function _loadAccounts(content) {
    const parsed = yaml_1.default.parse(content);
    return mkAccounts(parsed);
}
/**
 * Loads accounts from `filename`. The file should be a YAML file with list of objects
 * which is either `HDAccount`, `MnemonicAccount` or an `Account`.
 * @param filename file to load accounts from
 */
async function loadAccountsFromFile(filename) {
    return _loadAccounts(await fs.promises.readFile(filename, 'utf8'));
}
exports.loadAccountsFromFile = loadAccountsFromFile;
/**
 * Same as `loadAccountsFromFile` but uses sync method instead of async
 * @param filename file to load accounts from
 */
function loadAccountsFromFileSync(filename) {
    return _loadAccounts(fs.readFileSync(filename, 'utf8'));
}
exports.loadAccountsFromFileSync = loadAccountsFromFileSync;
// returns false if account validation doesn't pass
function validateAccount(a, errs) {
    if (a.addr === "") {
        errs.push("addr", "can't be empty", "string");
    }
    if (!(a.sk && a.sk instanceof Uint8Array && a.sk.length === 64)) {
        errs.push("sk", "Must be an instance of Uint8Array(64)", 'Uint8Array');
    }
    if (!(typeof a.name === 'string' && a.name !== "")) {
        errs.push("name", "can't be empty", 'string');
    }
    return errs.isEmpty;
}
exports.validateAccount = validateAccount;
function mkAccountIndex(accountList) {
    const out = new Map();
    for (const a of accountList) {
        out.set(a.name, a);
    }
    return out;
}
exports.mkAccountIndex = mkAccountIndex;
/**
 * load accounts from environment in node.js (set in process.ENV)
 */
function loadAccountsFromEnv() {
    const algobAccountsString = process.env.ALGOB_ACCOUNTS;
    if (algobAccountsString) {
        let accounts = [];
        try {
            accounts = JSON.parse(algobAccountsString);
        }
        catch (error) {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.MALFORMED, { errors: 'Some accounts are malformed or have missing fields' });
        }
        validateAccounts(accounts);
        const algobAccounts = [];
        for (const account of accounts) {
            try {
                const accountSDK = (0, algosdk_1.mnemonicToSecretKey)(account.mnemonic);
                algobAccounts.push({ name: account.name, addr: accountSDK.addr, sk: accountSDK.sk });
            }
            catch (error) {
                throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.WRONG_MNEMONIC, { errmsg: 'failed to decode mnemonic in ' + JSON.stringify(account) });
            }
        }
        return algobAccounts;
    }
    return [];
}
exports.loadAccountsFromEnv = loadAccountsFromEnv;
/**
 * returns multisignature account address
 * @param version version of msig
 * @param threshold represents min no. of signatures for a tx to be approved
 * @param accountList account address of multisig (note: order is important)
 * @returns multisig metadata ({v: .., thr: .., addr: ..}) and the multisig addresses
 */
function createMsigAddress(version, threshold, accountList) {
    const mparams = {
        version: version,
        threshold: threshold,
        addrs: accountList
    };
    return [mparams, (0, algosdk_1.multisigAddress)(mparams)];
}
exports.createMsigAddress = createMsigAddress;
function validateAccounts(algobAccounts) {
    for (const account of algobAccounts) {
        if (account.name === undefined) {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.FIELD_REQUIRED, { errors: 'Field account name must be defined and not empty in ' + JSON.stringify(account) });
        }
        if (account.mnemonic === undefined) {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.FIELD_REQUIRED, { errors: 'Field mnemonic string must be defined and not empty in ' + JSON.stringify(account) });
        }
        if (account.name === "") {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.FIELD_REQUIRED, { errors: 'Field account name must be defined and not empty in ' + JSON.stringify(account) });
        }
        if (account.mnemonic === "") {
            throw new web_1.BuilderError(web_1.ERRORS.ACCOUNT.FIELD_REQUIRED, { errors: 'Field mnemonic string must be defined and not empty in ' + JSON.stringify(account) });
        }
    }
}
class KMDOperator {
    constructor(kmdcl) {
        this.kmdcl = kmdcl;
    }
    kmdWalletAddrNames(kwallet) {
        const m = {};
        for (const a of kwallet.accounts) {
            m[a.address] = a.name;
        }
        return m;
    }
    async loadKMDAccounts(kcfg) {
        const accounts = [];
        try {
            const wallets = (await this.kmdcl.listWallets()).wallets;
            const walletIDs = {};
            for (const w of wallets)
                walletIDs[w.name] = w.id;
            for (const w of kcfg.wallets) {
                const id = walletIDs[w.name];
                if (id === undefined) {
                    console.warn("wallet id=", id, "defined in config but it doesn't exist in KMD");
                    continue;
                }
                const names = this.kmdWalletAddrNames(w);
                const token = (await this.kmdcl.initWalletHandle(id, w.password)).wallet_handle_token;
                const keys = await this.kmdcl.listKeys(token);
                for (const addr of keys.addresses) {
                    const n = names[addr];
                    if (n === undefined) {
                        console.debug("KMD account with address:", addr, " not found in wallet:1", w.name);
                        continue;
                    }
                    // console.debug("Adding KMD account name:", n)
                    const k = await this.kmdcl.exportKey(token, w.password, addr);
                    accounts.push({ name: n, addr: addr, sk: new Uint8Array(k.private_key) });
                }
            }
        }
        catch (e) {
            if (e.code === 'ECONNREFUSED') {
                throw new web_1.BuilderError(web_1.ERRORS.KMD.CONNECTION, { ctx: e }, e);
            }
            if (e instanceof Error) {
                throw new web_1.BuilderError(web_1.ERRORS.KMD.ERROR, { ctx: JSON.stringify(e) }, e);
            }
            throw e;
        }
        return accounts;
    }
}
exports.KMDOperator = KMDOperator;
//# sourceMappingURL=account.js.map