"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tealdbg = exports.lsigExt = exports.pyExt = exports.tealExt = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const fs_extra_1 = require("fs-extra");
const path = __importStar(require("path"));
const gen_accounts_1 = require("../builtin-tasks/gen-accounts");
const project_structure_1 = require("../internal/core/project-structure");
const time_1 = require("../lib/time");
const tx_1 = require("./tx");
exports.tealExt = ".teal";
exports.pyExt = ".py";
exports.lsigExt = ".lsig";
class Tealdbg {
    constructor(deployer, execParams) {
        this.deployer = deployer;
        this.execParams = execParams;
    }
    /**
     * Get account state(s) (fetched using account address) for dry run.
     * For eg. app_local_get, app_local_put requires an accounts ledger state to be uploaded.
     * @param txn transaction parameters
     */
    async getAccountsForDryRun(txn) {
        // get addresses of Txn.Accounts (in case of stateful tx params) & Txn.Sender
        const txAccounts = txn.accounts ?? []; // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion
        const addrs = [...txAccounts, web_1.tx.getFromAddress(txn)];
        const accountsForDryRun = [];
        for (const addr of addrs) {
            const accInfo = await this.deployer.algodClient.accountInformation(addr).do();
            if (!accInfo) {
                continue;
            }
            const acc = new algosdk_1.modelsv2.Account({
                address: accInfo.address,
                amount: accInfo.amount,
                amountWithoutPendingRewards: accInfo['amount-without-pending-rewards'],
                appsLocalState: accInfo['apps-local-state'],
                appsTotalSchema: accInfo['apps-total-schema'],
                assets: accInfo.assets,
                createdApps: accInfo['created-apps'],
                createdAssets: accInfo['created-assets'],
                pendingRewards: accInfo['pending-rewards'],
                rewardBase: accInfo['reward-base'],
                rewards: accInfo.rewards,
                round: accInfo.round,
                status: accInfo.status
            });
            accountsForDryRun.push(acc);
        }
        return accountsForDryRun;
    }
    /**
     * Get application state(s) (fetched by appID) for dry run.
     * For eg. app_global_get, app_global_put requires app state.
     * @param txn transaction parameters
     */
    async getAppsForDryRun(txn) {
        if (!(txn.type === web_1.types.TransactionType.ClearApp ||
            txn.type === web_1.types.TransactionType.CloseApp ||
            txn.type === web_1.types.TransactionType.DeleteApp ||
            txn.type === web_1.types.TransactionType.UpdateApp ||
            txn.type === web_1.types.TransactionType.OptInToApp ||
            txn.type === web_1.types.TransactionType.CallApp)) {
            return [];
        }
        // maybe txn.foreignApps won't work: https://github.com/algorand/go-algorand/issues/2609
        // this would be required with app_global_get_ex ops (access external contract's state)
        const appIDs = [...(txn.foreignApps ?? []), txn.appID];
        const appsForDryRun = [];
        for (const appID of appIDs) {
            const app = await this.deployer.algodClient.getApplicationByID(appID).do();
            const globalStateSchema = new algosdk_1.modelsv2.ApplicationStateSchema(app.params['global-state-schema']['num-uint'], app.params['global-state-schema']['num-byte-slice']);
            const localStateSchema = new algosdk_1.modelsv2.ApplicationStateSchema(app.params['local-state-schema']['num-uint'], app.params['local-state-schema']['num-byte-slice']);
            const globalState = (app.params['global-state'] || []).map(({ key, value }) => (new algosdk_1.modelsv2.TealKeyValue(key, new algosdk_1.modelsv2.TealValue(value.type, value.bytes, value.uint))));
            const appParams = new algosdk_1.modelsv2.ApplicationParams({
                approvalProgram: app.params['approval-program'],
                clearStateProgram: app.params['clear-state-program'],
                creator: app.params.creator,
                globalState,
                globalStateSchema,
                localStateSchema,
                extraProgramPages: app.params['extra-program-pages']
            });
            const appForDryRun = new algosdk_1.modelsv2.Application(app.id, appParams);
            appsForDryRun.push(appForDryRun);
        }
        return appsForDryRun;
    }
    /**
     * Create dry run request object using SDK transaction(s) from wtypes.ExecParams
     * User can dump the response (using this.dryRunResponse) or start debugger session
     * @returns SDK dryrun request object
     */
    async createDryRunReq() {
        let [_, signedTxn] = await (0, tx_1.makeAndSignTx)(this.deployer, this.execParams, new Map());
        if (!Array.isArray(signedTxn)) {
            signedTxn = [signedTxn];
        }
        const encodedSignedTxns = [];
        for (const s of signedTxn) {
            const decodedTx = (0, algosdk_1.decodeSignedTransaction)(s);
            encodedSignedTxns.push({ ...decodedTx, txn: decodedTx.txn.get_obj_for_encoding() });
        }
        // query application and account state and pass them to a debug session
        const execParamsArr = Array.isArray(this.execParams) ? this.execParams : [this.execParams];
        const appsForDryRun = [];
        const accountsForDryRun = [];
        for (const e of execParamsArr) {
            appsForDryRun.push(...(await this.getAppsForDryRun(e)));
            accountsForDryRun.push(...(await this.getAccountsForDryRun(e)));
        }
        // issue: https://github.com/algorand/js-algorand-sdk/issues/410
        // task: https://www.pivotaltracker.com/story/show/179060295
        return new algosdk_1.modelsv2.DryrunRequest({
            accounts: accountsForDryRun.length > 0 ? accountsForDryRun : undefined,
            apps: appsForDryRun.length > 0 ? appsForDryRun : undefined,
            txns: encodedSignedTxns,
            sources: undefined
        });
    }
    /**
     * Gets dryrun response in json from the request object
     * Returns a response with disassembly, logic-sig-messages with PASS/REJECT and sig-trace
     * @param outFile name of file to dump the response. Dumped in `assets/<file>`
     * @param force if true, overwrites an existing dryrun response dump
     */
    async dryRunResponse(outFile, force) {
        const dryRunRequest = await this.createDryRunReq();
        const dryRunResponse = await this.deployer.algodClient.dryrun(dryRunRequest).do();
        if (outFile) {
            const outPath = path.join(project_structure_1.ASSETS_DIR, outFile);
            await (0, gen_accounts_1.writeToFile)(JSON.stringify(dryRunResponse, null, 2), force ?? false, outPath);
        }
        return dryRunResponse;
    }
    /**
     * Start a debugger session using child_process.spawn() using the given args.
     * Kills an existing session first (using killall -9 <process>)
     * @param tealdbgArgs arguments to `tealdbg debug`. Eg. `--mode signature`, `--group-index 0`
     */
    async runDebugger(tealdbgArgs) {
        (0, child_process_1.spawn)(`killall`, ['-9', 'tealdbg']); // kill existing tealdbg process first
        const childProcess = (0, child_process_1.spawn)(`tealdbg`, ['debug', ...tealdbgArgs], {
            stdio: "inherit",
            cwd: process.cwd()
        });
        return await new Promise((resolve, reject) => {
            childProcess.once("close", (status) => {
                childProcess.removeAllListeners("error");
                if (status === 0) {
                    resolve(true);
                    return;
                }
                reject(new Error("script process returned non 0 status"));
            });
            childProcess.once("error", (status) => {
                childProcess.removeAllListeners("close");
                reject(new Error("script process returned non 0 status"));
            });
        });
    }
    /**
     * Sets args to pass to `tealdbg debug` command. Currently supported args are
     * tealFile, mode, groupIndex.
     * @param debugCtxParams args passed by user for debugger session
     * @param pathToCache path to --dryrun-dump (msgpack encoded) present in `/cache/dryrun`
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    getTealDbgParams(debugCtxParams, pathToCache) {
        const tealdbgArgs = [];
        /* Push path of tealfile to debug. If not passed then debugger will use assembled code by default
         * Supplying the program will allow debugging the "original source" and not the decompiled version. */
        const file = debugCtxParams.tealFile;
        if (file) {
            let pathToFile;
            if (file.endsWith(exports.pyExt)) {
                let tealFromPyTEAL;
                // note: currently tealdbg only accepts "teal" code, so we need to compile pyTEAL to TEAL first
                // issue: https://github.com/algorand/go-algorand/issues/2538
                pathToFile = path.join(project_structure_1.CACHE_DIR, 'dryrun', path.parse(file).name + '.' + (0, time_1.timestampNow)().toString() + exports.tealExt);
                // load pyCache from "artifacts/cache"
                if (fs.existsSync(path.join(project_structure_1.CACHE_DIR, file + ".yaml"))) {
                    const pathToPyCache = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.CACHE_DIR, file + ".yaml");
                    const pyCache = (0, runtime_1.loadFromYamlFileSilent)(pathToPyCache);
                    tealFromPyTEAL = pyCache.tealCode;
                }
                /* Use cached TEAL code if:
                 *  + we already have compiled pyteal code in artifacts/cache
                 *  + template paramteres (scInitParam) are not passed by user
                 * NOTE: if template parameters are passed, recompilation is forced to compile
                 * pyTEAL with the passed params (as the generated TEAL code could differ from cache)
                 */
                if (tealFromPyTEAL !== undefined && debugCtxParams.scInitParam === undefined) {
                    console.info('\x1b[33m%s\x1b[0m', `Using cached TEAL code for ${file}`);
                }
                else {
                    tealFromPyTEAL = (0, runtime_1.getProgram)(file, debugCtxParams.scInitParam);
                }
                this.writeFile(pathToFile, tealFromPyTEAL);
            }
            else {
                pathToFile = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, file);
            }
            tealdbgArgs.push(pathToFile);
        }
        // push path to --dryrun-dump (msgpack encoded) present in `/cache/dryrun`
        tealdbgArgs.push('-d', pathToCache);
        /* Set mode(application/signature) if passed. By default,
         * the debugger scans the program to determine the type of contract. */
        if (debugCtxParams.mode !== undefined) {
            const mode = debugCtxParams.mode === runtime_1.types.ExecutionMode.APPLICATION ? 'application' : 'signature';
            tealdbgArgs.push('--mode', mode);
        }
        // set groupIndex flag if a transaction group is passed in this.wtypes.ExecParams
        const grpIdx = debugCtxParams.groupIndex;
        if (grpIdx !== undefined) {
            const execParamsArr = Array.isArray(this.execParams) ? this.execParams : [this.execParams];
            if (grpIdx >= execParamsArr.length) {
                throw new Error(`groupIndex(= ${grpIdx}) exceeds transaction group length(= ${execParamsArr.length})`);
            }
            tealdbgArgs.push('--group-index', grpIdx.toString());
        }
        return tealdbgArgs;
    }
    /**
     * Runs a debugging session:
     *  + Construct dryrun request using wtypes.ExecParams passed by user
     *  + Set arguments for tealdbg debug
     *  + Run debugger session using child_process.spawn()
     * @param debugCtxParams args passed by user for debugger session
     */
    async run(debugCtxParams) {
        // construct encoded dryrun request using SDK
        const dryRunRequest = await this.createDryRunReq();
        const encodedReq = (0, algosdk_1.encodeObj)(dryRunRequest.get_obj_for_encoding(true));
        // output the dump in cache/dryrun directory (.msgp file is used as input to teal debugger)
        // similar to 'goal <txns> --dryrun-dump'
        const msgpDumpFileName = 'dump-' + (0, time_1.timestampNow)().toString() + '.msgp';
        const pathToCache = path.join(project_structure_1.CACHE_DIR, 'dryrun', msgpDumpFileName);
        this.writeFile(pathToCache, encodedReq);
        // run tealdbg debug on dryrun-dump using args
        const tealdbgArgs = this.getTealDbgParams(debugCtxParams ?? {}, pathToCache);
        await this.runDebugger(tealdbgArgs);
    }
    // write (dryrun dump) to file in `cache/dryrun`
    writeFile(filename, content) {
        (0, fs_extra_1.ensureDirSync)(path.dirname(filename));
        fs.writeFileSync(filename, content);
    }
}
exports.Tealdbg = Tealdbg;
//# sourceMappingURL=dryrun.js.map