"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoOperatorImpl = exports.createAlgoOperator = exports.ALGORAND_MIN_TX_FEE = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const driver_1 = require("../lib/driver");
const lsig_1 = require("../lib/lsig");
const compile_1 = require("./compile");
const tx = __importStar(require("./tx"));
const confirmedRound = "confirmed-round";
// This was not exported in algosdk
exports.ALGORAND_MIN_TX_FEE = 1000;
// Extracted from interaction with Algorand node (100k microAlgos)
const ALGORAND_ASA_OWNERSHIP_COST = 100000;
function createAlgoOperator(network) {
    return new AlgoOperatorImpl((0, driver_1.createClient)(network));
}
exports.createAlgoOperator = createAlgoOperator;
class AlgoOperatorImpl {
    constructor(algocl) {
        this.algodClient = algocl;
        this.compileOp = new compile_1.CompileOp(this.algodClient);
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    async sendAndWait(rawTxns) {
        const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
        return await this.waitForConfirmation(txInfo.txId);
    }
    // Source:
    // https://github.com/algorand/docs/blob/master/examples/assets/v2/javascript/AssetExample.js#L21
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const response = await this.algodClient.status().do();
        let lastround = response["last-round"];
        while (true) {
            const pendingInfo = await this.algodClient.pendingTransactionInformation(txId).do();
            if (pendingInfo["pool-error"]) {
                throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
            }
            if (pendingInfo[confirmedRound] !== null && pendingInfo[confirmedRound] > 0) {
                return pendingInfo;
            }
            lastround++;
            await this.algodClient.statusAfterBlock(lastround).do();
        }
    }
    ;
    /**
     * Queries blockchain using algodClient for asset information by index */
    async getAssetByID(assetIndex) {
        return await this.algodClient.getAssetByID(Number(assetIndex)).do();
    }
    getTxFee(params, txSize) {
        if (params.flatFee) {
            return Math.max(exports.ALGORAND_MIN_TX_FEE, params.fee);
        }
        return Math.max(exports.ALGORAND_MIN_TX_FEE, txSize);
    }
    getUsableAccBalance(accountInfo) {
        // Extracted from interacting with Algorand node:
        // 7 opted-in assets require to have 800000 micro algos (frozen in account).
        // 11 assets require 1200000.
        const assets = accountInfo.assets;
        return BigInt(accountInfo.amount) - BigInt((assets.length + 1) * ALGORAND_ASA_OWNERSHIP_COST);
    }
    getOptInTxSize(params, accounts, flags) {
        const randomAccount = accounts.values().next().value;
        // assetID can't be known before ASA creation
        // it shouldn't be easy to find out the latest asset ID
        // In original source code it's uint64:
        // https://github.com/algorand/go-algorand/blob/1424855ad2b5f6755ff3feba7e419ee06f2493da/data/basics/userBalance.go#L278
        const assetID = Number.MAX_SAFE_INTEGER; // not 64 bits but 55 bits should be enough
        const sampleASAOptInTX = tx.makeASAOptInTx(randomAccount.addr, assetID, params, flags);
        const rawSignedTxn = sampleASAOptInTX.signTxn(randomAccount.sk);
        return rawSignedTxn.length;
    }
    async _optInAccountToASA(asaName, assetIndex, account, params, flags) {
        console.log(`ASA ${String(account.name)} opt-in for ASA ${String(asaName)}`);
        const sampleASAOptInTX = tx.makeASAOptInTx(account.addr, assetIndex, params, flags);
        const rawSignedTxn = sampleASAOptInTX.signTxn(account.sk);
        await this.sendAndWait(rawSignedTxn);
    }
    async optInAccountToASA(asaName, assetIndex, account, flags) {
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        await this._optInAccountToASA(asaName, assetIndex, account, txParams, flags);
    }
    async optInLsigToASA(asaName, assetIndex, lsig, flags) {
        console.log(`Contract ${lsig.address()} opt-in for ASA ${asaName}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const optInLsigToASATx = tx.makeASAOptInTx(lsig.address(), assetIndex, txParams, flags);
        const rawLsigSignedTx = algosdk_1.default.signLogicSigTransactionObject(optInLsigToASATx, lsig).blob;
        const txInfo = await this.algodClient.sendRawTransaction(rawLsigSignedTx).do();
        await this.waitForConfirmation(txInfo.txId);
    }
    async optInToASAMultiple(asaName, asaDef, flags, accounts, assetIndex) {
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const optInAccounts = await this.checkBalanceForOptInTx(asaName, txParams, asaDef, accounts, flags.creator, flags);
        for (const account of optInAccounts) {
            await this._optInAccountToASA(asaName, assetIndex, account, txParams, flags);
        }
    }
    async checkBalanceForOptInTx(name, params, asaDef, accounts, creator, flags) {
        if (!asaDef.optInAccNames || asaDef.optInAccNames.length === 0) {
            return [];
        }
        const optInTxFee = this.getTxFee(params, this.getOptInTxSize(params, accounts, flags));
        const optInAccs = [];
        for (const accName of asaDef.optInAccNames) {
            const account = accounts.get(accName);
            if (!account) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_NOT_FOUND, {
                    accountName: accName
                });
            }
            optInAccs.push(account);
            if (account.addr === creator.addr) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_TRIED_TO_OPT_IN_CREATOR);
            }
            const accountInfo = await this.algodClient.accountInformation(account.addr).do();
            const requiredAmount = optInTxFee + ALGORAND_ASA_OWNERSHIP_COST;
            const usableAmount = this.getUsableAccBalance(accountInfo);
            if (usableAmount < requiredAmount) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_INSUFFICIENT_BALANCE, {
                    accountName: accName,
                    balance: usableAmount,
                    requiredBalance: requiredAmount,
                    asaName: name
                });
            }
        }
        return optInAccs;
    }
    async deployASA(name, asaDef, flags, accounts, txWriter) {
        const message = 'Deploying ASA: ' + name;
        console.log(message);
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const assetTX = tx.makeAssetCreateTxn(name, asaDef, flags, txParams);
        const rawSignedTxn = assetTX.signTxn(flags.creator.sk);
        const txInfo = await this.algodClient.sendRawTransaction(rawSignedTxn).do();
        const txConfirmation = await this.waitForConfirmation(txInfo.txId);
        const assetIndex = txConfirmation['asset-index'];
        txWriter.push(message, txConfirmation);
        return {
            creator: flags.creator.addr,
            txId: txInfo.txId,
            assetIndex: Number(assetIndex),
            confirmedRound: Number(txConfirmation[confirmedRound]),
            assetDef: asaDef,
            deleted: false
        };
    }
    /**
     * Sends Algos to ASC account (Contract Account)
     * @param name     - ASC filename
     * @param flags    - FundASC flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param txWriter - transaction log writer
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async fundLsig(name, flags, payFlags, txWriter, scTmplParams) {
        const lsig = await (0, lsig_1.getLsig)(name, this.algodClient, scTmplParams);
        const contractAddress = lsig.address();
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        let message = "Funding Contract: " + String(contractAddress);
        console.log(message);
        const closeToRemainder = undefined;
        const note = web_1.tx.encodeNote(payFlags.note, payFlags.noteb64);
        const t = algosdk_1.default.makePaymentTxnWithSuggestedParams(flags.funder.addr, contractAddress, flags.fundingMicroAlgo, closeToRemainder, note, params);
        const signedTxn = t.signTxn(flags.funder.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxn = await this.waitForConfirmation(txInfo.txId);
        message = message.concat("\nLsig: " + name);
        txWriter.push(message, confirmedTxn);
        return {
            creator: flags.funder.addr,
            contractAddress: contractAddress,
            lsig: lsig
        };
    }
    /**
     * Function to deploy Stateful Smart Contract
     * @param approvalProgram name of file in which approval program is stored
     * @param clearProgram name of file in which clear program is stored
     * @param flags         AppDeploymentFlags
     * @param payFlags      TxParams
     * @param txWriter
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async deployApp(approvalProgram, clearProgram, flags, payFlags, txWriter, scTmplParams) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const app = await this.ensureCompiled(approvalProgram, false, scTmplParams);
        const approvalProg = new Uint8Array(Buffer.from(app.compiled, "base64"));
        const clear = await this.ensureCompiled(clearProgram, false, scTmplParams);
        const clearProg = new Uint8Array(Buffer.from(clear.compiled, "base64"));
        const execParam = {
            type: web_1.types.TransactionType.DeployApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: flags.sender,
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            approvalProg: approvalProg,
            clearProg: clearProg,
            payFlags: payFlags,
            localInts: flags.localInts,
            localBytes: flags.localBytes,
            globalInts: flags.globalInts,
            globalBytes: flags.globalBytes,
            extraPages: flags.extraPages,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets,
            appArgs: flags.appArgs,
            note: flags.note,
            lease: flags.lease
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const txId = txn.txID().toString();
        const signedTxn = txn.signTxn(flags.sender.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxInfo = await this.waitForConfirmation(txId);
        const appId = confirmedTxInfo['application-index'];
        const message = `Signed transaction with txID: ${txId}\nCreated new app-id: ${appId}`; // eslint-disable-line @typescript-eslint/restrict-template-expressions
        console.log(message);
        txWriter.push(message, confirmedTxInfo);
        return {
            creator: flags.sender.addr,
            txId: txInfo.txId,
            confirmedRound: Number(confirmedTxInfo[confirmedRound]),
            appID: Number(appId),
            applicationAccount: (0, algosdk_1.getApplicationAddress)(Number(appId)),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false
        };
    }
    /**
     * Update programs (approval, clear) for a stateful smart contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID index of the application being configured
     * @param newApprovalProgram New Approval Program filename
     * @param newClearProgram New Clear Program filename
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param txWriter - transaction log writer
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    async updateApp(sender, payFlags, appID, newApprovalProgram, newClearProgram, flags, txWriter, scTmplParams) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const app = await this.ensureCompiled(newApprovalProgram, false, scTmplParams);
        const approvalProg = new Uint8Array(Buffer.from(app.compiled, "base64"));
        const clear = await this.ensureCompiled(newClearProgram, false, scTmplParams);
        const clearProg = new Uint8Array(Buffer.from(clear.compiled, "base64"));
        const execParam = {
            type: web_1.types.TransactionType.UpdateApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appID: appID,
            newApprovalProgram: newApprovalProgram,
            newClearProgram: newClearProgram,
            approvalProg: approvalProg,
            clearProg: clearProg,
            payFlags: payFlags,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets,
            appArgs: flags.appArgs,
            note: flags.note,
            lease: flags.lease
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const txId = txn.txID().toString();
        const signedTxn = txn.signTxn(sender.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxInfo = await this.waitForConfirmation(txId);
        const message = `Signed transaction with txID: ${txId}\nUpdated app-id: ${appID}`; // eslint-disable-line @typescript-eslint/restrict-template-expressions
        console.log(message);
        txWriter.push(message, confirmedTxInfo);
        return {
            creator: sender.addr,
            txId: txInfo.txId,
            confirmedRound: Number(confirmedTxInfo[confirmedRound]),
            appID: appID,
            applicationAccount: (0, algosdk_1.getApplicationAddress)(appID),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false
        };
    }
    /**
     * Opt-In to stateful smart contract
     *  - signed by account's secret key
     * @param sender: Account for which opt-in is required
     * @param appID: Application Index: (ID of the application)
     * @param payFlags: Transaction Params
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    async optInAccountToApp(sender, appID, payFlags, flags) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const execParam = {
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appID: appID,
            payFlags: payFlags,
            appArgs: flags.appArgs,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const signedTxn = txn.signTxn(sender.sk);
        await this.sendAndWait(signedTxn);
    }
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    async optInLsigToApp(appID, lsig, payFlags, flags) {
        console.log(`Contract ${lsig.address()} opt-in for SSC ID ${appID}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const execParam = {
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.LogicSignature,
            fromAccountAddr: lsig.address(),
            lsig: lsig,
            appID: appID,
            payFlags: payFlags,
            appArgs: flags.appArgs,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets
        };
        const optInLsigToAppTx = web_1.tx.mkTransaction(execParam, params);
        const rawLsigSignedTx = algosdk_1.default.signLogicSigTransactionObject(optInLsigToAppTx, lsig).blob;
        await this.sendAndWait(rawLsigSignedTx);
    }
    async ensureCompiled(name, force, scTmplParams) {
        return await this.compileOp.ensureCompiled(name, force, scTmplParams);
    }
}
exports.AlgoOperatorImpl = AlgoOperatorImpl;
//# sourceMappingURL=algo-operator.js.map