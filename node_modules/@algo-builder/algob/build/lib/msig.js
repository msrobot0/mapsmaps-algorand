"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMultiSig = exports.validateMsig = exports.loadBinaryLsig = exports.readBinaryMultiSig = exports.readMsigFromFile = exports.decodeMsigObj = exports.blsigExt = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const fs_1 = __importDefault(require("fs"));
const project_structure_1 = require("../internal/core/project-structure");
const tx_1 = require("./tx");
exports.blsigExt = ".blsig";
const lsigExt = ".lsig";
/**
 * This function decodes msig object from logic signature
 * @param {String} name : multisig filename
 * @returns {MultiSig} : decoded msig (object with decoded public keys and their signatures)
 */
async function decodeMsigObj(msig) {
    const parsedMsig = JSON.parse(msig).msig;
    validateMsig(parsedMsig);
    // decoding multisigned logic signature
    for (const acc of parsedMsig.subsig) {
        acc.pk = (0, algosdk_1.decodeAddress)(acc.pk).publicKey;
        if (acc.s) {
            acc.s = new Uint8Array(Buffer.from(acc.s, 'base64')); // decode base64 signature (signed pk)
        }
    }
    return parsedMsig;
}
exports.decodeMsigObj = decodeMsigObj;
/**
 * This function reads multisig from /assets/<filename>.lsig
 *              and returns the decoded multisig object
 * @param {string} msig : multisigned msig obj
 * @returns {MultiSig} : decoded Msig Object
 */
async function readMsigFromFile(filename) {
    if (!filename.endsWith(lsigExt)) {
        throw new Error(`filename "${filename}" must end with "${lsigExt}"`);
    }
    try {
        const p = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, filename);
        const msig = fs_1.default.readFileSync(p, 'utf8').split("LogicSig: ")[1];
        return await decodeMsigObj(msig);
    }
    catch (e) {
        if (web_1.types.isFileError(e) && e?.errno === -2) {
            return undefined;
        } // handling a not existing file
        throw e;
    }
}
exports.readMsigFromFile = readMsigFromFile;
/**
 * This function reads raw multisig from /assets/<filename>.lsig
 * and returns the base64 string
 * @param {string} filename : filename [must have .blsig ext]
 * @returns {string} : base64 string
 */
async function readBinaryMultiSig(filename) {
    if (!filename.endsWith(exports.blsigExt)) {
        throw new Error(`filename "${filename}" must end with "${exports.blsigExt}"`);
    }
    try {
        const p = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, filename);
        return fs_1.default.readFileSync(p, 'base64');
    }
    catch (e) {
        if (web_1.types.isFileError(e) && e?.errno === -2) {
            return undefined;
        } // handling a not existing file
        throw e;
    }
}
exports.readBinaryMultiSig = readBinaryMultiSig;
/**
 * Loads signed logic signature directly from .blsig file
 * @param {string} name filename
 * @returns {LogicSig} signed logic signature from assets/<file_name>.blsig
 */
async function loadBinaryLsig(name) {
    const data = await readBinaryMultiSig(name);
    if (data === undefined) {
        throw new Error(`File ${name} does not exist`);
    }
    const program = new Uint8Array(Buffer.from(data, 'base64'));
    return (0, algosdk_1.logicSigFromByte)(program);
}
exports.loadBinaryLsig = loadBinaryLsig;
/**
 * Validates msig by checking for v and thr field
 * @param {MultiSig} msig
 */
function validateMsig(msig) {
    if (msig === undefined || msig.v === undefined || msig.thr === undefined) {
        throw new Error("Error fetching multisigned logic signature from file - invalid/undefined msig");
    }
}
exports.validateMsig = validateMsig;
/**
 * Signs a raw multi-sig transaction object
 * @param signerAccount account(addr, sk) to sign the transaction
 * @param rawTxn encoded transaction fetched from file in /assets
 * @param mparams multisig metadata. Required if creating a new signed multisig transaction.
 * @returns signed transaction object
 */
function signMultiSig(signerAccount, rawTxn, mparams) {
    let decodedTxn, msig;
    let multisigMetaData; // extracted from existing multisig OR passed by user
    if ((0, tx_1.isSignedTx)(rawTxn)) {
        decodedTxn = (0, algosdk_1.decodeSignedTransaction)(rawTxn);
        msig = decodedTxn.msig;
        validateMsig(msig);
        const addresses = [];
        for (const sig of msig.subsig) {
            addresses.push((0, algosdk_1.encodeAddress)(Uint8Array.from(sig.pk)));
        }
        multisigMetaData = {
            version: msig.v,
            threshold: msig.thr,
            addrs: addresses
        };
    }
    else {
        if (mparams === undefined) {
            throw new Error(`Multisig MetaData (version, threshold, addresses) not passed. This is required for creating a new multisig. Aborting`);
        }
        decodedTxn = (0, algosdk_1.decodeUnsignedTransaction)(rawTxn);
        multisigMetaData = mparams;
    }
    console.log("Msig: %O", msig);
    // note: append requires raw(encoded) transaction object, but signMultisig requires decoded tx obj
    const signedTxn = (0, tx_1.isSignedTx)(rawTxn)
        ? (0, algosdk_1.appendSignMultisigTransaction)(rawTxn, multisigMetaData, signerAccount.sk)
        : (0, algosdk_1.signMultisigTransaction)(decodedTxn, multisigMetaData, signerAccount.sk);
    const decodedSignedTxn = (0, algosdk_1.decodeSignedTransaction)(signedTxn.blob);
    console.log("Msig: %O", decodedSignedTxn.msig);
    return signedTxn;
}
exports.signMultiSig = signMultiSig;
//# sourceMappingURL=msig.js.map