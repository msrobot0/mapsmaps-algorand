"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadEncodedTxFromFile = exports.assertDirectDirChildren = exports.assertDirChildren = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const project_structure_1 = require("../internal/core/project-structure");
function normalizePaths(mainPath, paths) {
    return paths.map(n => path_1.default.relative(mainPath, n));
}
function assertDirChildren(dir, scriptNames) {
    const normalized = normalizePaths(".", scriptNames);
    const nonScriptPaths = normalized
        .filter(scriptName => !path_1.default.relative(".", scriptName).startsWith(dir));
    if (nonScriptPaths.length !== 0) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.SCRIPTS_OUTSIDE_SCRIPTS_DIRECTORY, {
            scripts: nonScriptPaths
        });
    }
    return normalized;
}
exports.assertDirChildren = assertDirChildren;
function assertDirectDirChildren(dir, scriptNames) {
    const normalized = normalizePaths(".", scriptNames);
    const badPaths = normalized.filter(scriptName => path_1.default.dirname(scriptName) !== dir);
    if (badPaths.length !== 0) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOY_SCRIPT_NON_DIRECT_CHILD, {
            scripts: badPaths
        });
    }
    return normalized;
}
exports.assertDirectDirChildren = assertDirectDirChildren;
/**
 * This function reads raw signed txn from file /assets/<filename.ext>
 * and returns the encoded txn as Uint8array
 * @param fileName : file name
 * @returns signed transaction encoded as Uint8array
 */
function loadEncodedTxFromFile(fileName) {
    try {
        const p = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, fileName);
        const buffer = fs_extra_1.default.readFileSync(p);
        return Uint8Array.from(buffer);
    }
    catch (e) {
        if (web_1.types.isFileError(e) && e?.errno === -2) {
            return undefined;
        } // handling a not existing file
        throw e;
    }
}
exports.loadEncodedTxFromFile = loadEncodedTxFromFile;
//# sourceMappingURL=files.js.map